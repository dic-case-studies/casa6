##################### generated by xml-casa (v2) from vpmanager.xml #################
##################### 5d35ac075fad57789813a8b6b1890749 ##############################
from __future__ import absolute_import 
from .__casac__ import vpmanager as _vpmanager
from .platform import str_encode as _str_ec
from .platform import str_decode as _str_dc
from .platform import dict_encode as _dict_ec
from .platform import dict_decode as _dict_dc
from .platform import dict_encode as _quant_ec
from .platform import dict_decode as _quant_dc
from .platform import encode as _any_ec
from .platform import decode as _any_dc
from .typecheck import validator as _pc
from .coercetype import coerce as _coerce


class vpmanager:
    ### self
    def __init__(self, *args, **kwargs):
        """The vpmanager constructor has no arguments.
        """
        self._swigobj = kwargs.get('swig_object',None)
        if self._swigobj is None:
            self._swigobj = _vpmanager()

    def saveastable(self, tablename=''):
        """Save the vp or pb descriptions as a table.  Each description is in a different
        row of the table.
        """
        schema = {'tablename': {'type': 'cStr'}}
        doc = {'tablename': tablename}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _saveastable_result = self._swigobj.saveastable(_str_ec(_pc.document['tablename']))
        return _saveastable_result

    def loadfromtable(self, tablename=''):
        """Load the vp or pb descriptions from a table created, e.g., with saveastable().
        """
        schema = {'tablename': {'type': 'cStr'}}
        doc = {'tablename': tablename}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _loadfromtable_result = self._swigobj.loadfromtable(_str_ec(_pc.document['tablename']))
        return _loadfromtable_result

    def summarizevps(self, verbose=False):
        """Summarize the currently accumulated VP descriptions to the logger.
        """
        schema = {'verbose': {'type': 'cBool'}}
        doc = {'verbose': verbose}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _summarizevps_result = self._swigobj.summarizevps(_pc.document['verbose'])
        return _summarizevps_result

    def setcannedpb(self, telescope='VLA', othertelescope='', dopb=True, commonpb='DEFAULT', dosquint=False, paincrement=[ ], usesymmetricbeam=False):
        """We have many vp/pb models ready to go for a variety of telescopes.  If 'DEFAULT' isselected, the system default for that telescope and frequency is used.
        """
        schema = {'telescope': {'type': 'cStr'}, 'othertelescope': {'type': 'cStr'}, 'dopb': {'type': 'cBool'}, 'commonpb': {'type': 'cStr'}, 'dosquint': {'type': 'cBool'}, 'paincrement': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'usesymmetricbeam': {'type': 'cBool'}}
        doc = {'telescope': telescope, 'othertelescope': othertelescope, 'dopb': dopb, 'commonpb': commonpb, 'dosquint': dosquint, 'paincrement': paincrement, 'usesymmetricbeam': usesymmetricbeam}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _setcannedpb_result = _dict_dc(self._swigobj.setcannedpb(_str_ec(_pc.document['telescope']), _str_ec(_pc.document['othertelescope']), _pc.document['dopb'], _str_ec(_pc.document['commonpb']), _pc.document['dosquint'], _any_ec(_pc.document['paincrement']), _pc.document['usesymmetricbeam']))
        return _setcannedpb_result

    def setpbairy(self, telescope='VLA', othertelescope='', dopb=True, dishdiam=[ ], blockagediam=[ ], maxrad=[ ], reffreq=[ ], squintdir=[ ], squintreffreq=[ ], dosquint=False, paincrement=[ ], usesymmetricbeam=False):
        """Information sufficient to create a portion of the Airy disk voltage pattern.
        The Airy disk pattern is formed by Fourier transforming a uniformly illuminated
        aperture and is given by
        begin{equation}
        vp_p(i) = ( areaRatio * 2.0 * j_{1}(x)/x
        - 2.0 * j_{1}(x*lengthRatio)/(x*lengthRatio) )/ areaNorm,
        end{equation}
        where areaRatio is the dish area divided by the blockage area, lengthRatio
        is the dish diameter divided by the blockage diameter, and
        begin{equation}
        x = frac{i * maxrad * 7.016 * dishdiam/24.5m}{N_{samples} * 1.566 * 60}.
        end{equation}
        """
        schema = {'telescope': {'type': 'cStr'}, 'othertelescope': {'type': 'cStr'}, 'dopb': {'type': 'cBool'}, 'dishdiam': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'blockagediam': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'maxrad': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'reffreq': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'squintdir': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'squintreffreq': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'dosquint': {'type': 'cBool'}, 'paincrement': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'usesymmetricbeam': {'type': 'cBool'}}
        doc = {'telescope': telescope, 'othertelescope': othertelescope, 'dopb': dopb, 'dishdiam': dishdiam, 'blockagediam': blockagediam, 'maxrad': maxrad, 'reffreq': reffreq, 'squintdir': squintdir, 'squintreffreq': squintreffreq, 'dosquint': dosquint, 'paincrement': paincrement, 'usesymmetricbeam': usesymmetricbeam}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _setpbairy_result = _dict_dc(self._swigobj.setpbairy(_str_ec(_pc.document['telescope']), _str_ec(_pc.document['othertelescope']), _pc.document['dopb'], _any_ec(_pc.document['dishdiam']), _any_ec(_pc.document['blockagediam']), _any_ec(_pc.document['maxrad']), _any_ec(_pc.document['reffreq']), _any_ec(_pc.document['squintdir']), _any_ec(_pc.document['squintreffreq']), _pc.document['dosquint'], _any_ec(_pc.document['paincrement']), _pc.document['usesymmetricbeam']))
        return _setpbairy_result

    def setpbcospoly(self, telescope='VLA', othertelescope='', dopb=True, coeff=[ float(-1) ], scale=[ float(-1) ], maxrad=[ ], reffreq=[ ], isthispb='PB', squintdir=[ ], squintreffreq=[ ], dosquint=False, paincrement=[ ], usesymmetricbeam=False):
        """A voltage pattern or primary beam of the form
        begin{equation}
        VP(x) = sum_{i} ( coeff_{i} cos^{2i}( scale_{i} x).
        end{equation}
        This is a generalization of the WSRT primary beam model.
        """
        schema = {'telescope': {'type': 'cStr'}, 'othertelescope': {'type': 'cStr'}, 'dopb': {'type': 'cBool'}, 'coeff': {'type': 'cFloatVec', 'coerce': [_coerce.to_list,_coerce.to_floatvec]}, 'scale': {'type': 'cFloatVec', 'coerce': [_coerce.to_list,_coerce.to_floatvec]}, 'maxrad': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'reffreq': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'isthispb': {'type': 'cStr'}, 'squintdir': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'squintreffreq': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'dosquint': {'type': 'cBool'}, 'paincrement': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'usesymmetricbeam': {'type': 'cBool'}}
        doc = {'telescope': telescope, 'othertelescope': othertelescope, 'dopb': dopb, 'coeff': coeff, 'scale': scale, 'maxrad': maxrad, 'reffreq': reffreq, 'isthispb': isthispb, 'squintdir': squintdir, 'squintreffreq': squintreffreq, 'dosquint': dosquint, 'paincrement': paincrement, 'usesymmetricbeam': usesymmetricbeam}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _setpbcospoly_result = _dict_dc(self._swigobj.setpbcospoly(_str_ec(_pc.document['telescope']), _str_ec(_pc.document['othertelescope']), _pc.document['dopb'], _pc.document['coeff'], _pc.document['scale'], _any_ec(_pc.document['maxrad']), _any_ec(_pc.document['reffreq']), _str_ec(_pc.document['isthispb']), _any_ec(_pc.document['squintdir']), _any_ec(_pc.document['squintreffreq']), _pc.document['dosquint'], _any_ec(_pc.document['paincrement']), _pc.document['usesymmetricbeam']))
        return _setpbcospoly_result

    def setpbgauss(self, telescope='VLA', othertelescope='', dopb=True, halfwidth=[ ], maxrad=[ ], reffreq=[ ], isthispb='PB', squintdir=[ ], squintreffreq=[ ], dosquint=False, paincrement=[ ], usesymmetricbeam=False):
        """Make a Gaussian primary beam given by
        begin{equation}
        PB(x) =  e^{- (x/(halfwidth*sqrt{1/log(2)})) }.
        end{equation}
        """
        schema = {'telescope': {'type': 'cStr'}, 'othertelescope': {'type': 'cStr'}, 'dopb': {'type': 'cBool'}, 'halfwidth': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'maxrad': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'reffreq': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'isthispb': {'type': 'cStr'}, 'squintdir': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'squintreffreq': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'dosquint': {'type': 'cBool'}, 'paincrement': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'usesymmetricbeam': {'type': 'cBool'}}
        doc = {'telescope': telescope, 'othertelescope': othertelescope, 'dopb': dopb, 'halfwidth': halfwidth, 'maxrad': maxrad, 'reffreq': reffreq, 'isthispb': isthispb, 'squintdir': squintdir, 'squintreffreq': squintreffreq, 'dosquint': dosquint, 'paincrement': paincrement, 'usesymmetricbeam': usesymmetricbeam}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _setpbgauss_result = _dict_dc(self._swigobj.setpbgauss(_str_ec(_pc.document['telescope']), _str_ec(_pc.document['othertelescope']), _pc.document['dopb'], _any_ec(_pc.document['halfwidth']), _any_ec(_pc.document['maxrad']), _any_ec(_pc.document['reffreq']), _str_ec(_pc.document['isthispb']), _any_ec(_pc.document['squintdir']), _any_ec(_pc.document['squintreffreq']), _pc.document['dosquint'], _any_ec(_pc.document['paincrement']), _pc.document['usesymmetricbeam']))
        return _setpbgauss_result

    def setpbinvpoly(self, telescope='VLA', othertelescope='', dopb=True, coeff=[ float(-1) ], maxrad=[ ], reffreq=[ ], isthispb='PB', squintdir=[ ], squintreffreq=[ ], dosquint=False, paincrement=[ ], usesymmetricbeam=False):
        """The inverse polynomial describes the inverse of the VP or PB
        as a polynomial of even powers:
        begin{equation}
        1/VP(x) = sum_{i} coeff_{i} * x^{2i}.
        end{equation}
        """
        schema = {'telescope': {'type': 'cStr'}, 'othertelescope': {'type': 'cStr'}, 'dopb': {'type': 'cBool'}, 'coeff': {'type': 'cFloatVec', 'coerce': [_coerce.to_list,_coerce.to_floatvec]}, 'maxrad': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'reffreq': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'isthispb': {'type': 'cStr'}, 'squintdir': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'squintreffreq': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'dosquint': {'type': 'cBool'}, 'paincrement': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'usesymmetricbeam': {'type': 'cBool'}}
        doc = {'telescope': telescope, 'othertelescope': othertelescope, 'dopb': dopb, 'coeff': coeff, 'maxrad': maxrad, 'reffreq': reffreq, 'isthispb': isthispb, 'squintdir': squintdir, 'squintreffreq': squintreffreq, 'dosquint': dosquint, 'paincrement': paincrement, 'usesymmetricbeam': usesymmetricbeam}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _setpbinvpoly_result = _dict_dc(self._swigobj.setpbinvpoly(_str_ec(_pc.document['telescope']), _str_ec(_pc.document['othertelescope']), _pc.document['dopb'], _pc.document['coeff'], _any_ec(_pc.document['maxrad']), _any_ec(_pc.document['reffreq']), _str_ec(_pc.document['isthispb']), _any_ec(_pc.document['squintdir']), _any_ec(_pc.document['squintreffreq']), _pc.document['dosquint'], _any_ec(_pc.document['paincrement']), _pc.document['usesymmetricbeam']))
        return _setpbinvpoly_result

    def setpbnumeric(self, telescope='VLA', othertelescope='', dopb=True, vect=[ float(-1) ], maxrad=[ ], reffreq=[ ], isthispb='PB', squintdir=[ ], squintreffreq=[ ], dosquint=False, paincrement=[ ], usesymmetricbeam=False):
        """Supply a vector of vp/pb sample values taken on a regular grid between x=0 and
        x=maxrad.  We perform sinc interpolation to fill in the lookup table.
        """
        schema = {'telescope': {'type': 'cStr'}, 'othertelescope': {'type': 'cStr'}, 'dopb': {'type': 'cBool'}, 'vect': {'type': 'cFloatVec', 'coerce': [_coerce.to_list,_coerce.to_floatvec]}, 'maxrad': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'reffreq': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'isthispb': {'type': 'cStr'}, 'squintdir': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'squintreffreq': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'dosquint': {'type': 'cBool'}, 'paincrement': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'usesymmetricbeam': {'type': 'cBool'}}
        doc = {'telescope': telescope, 'othertelescope': othertelescope, 'dopb': dopb, 'vect': vect, 'maxrad': maxrad, 'reffreq': reffreq, 'isthispb': isthispb, 'squintdir': squintdir, 'squintreffreq': squintreffreq, 'dosquint': dosquint, 'paincrement': paincrement, 'usesymmetricbeam': usesymmetricbeam}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _setpbnumeric_result = _dict_dc(self._swigobj.setpbnumeric(_str_ec(_pc.document['telescope']), _str_ec(_pc.document['othertelescope']), _pc.document['dopb'], _pc.document['vect'], _any_ec(_pc.document['maxrad']), _any_ec(_pc.document['reffreq']), _str_ec(_pc.document['isthispb']), _any_ec(_pc.document['squintdir']), _any_ec(_pc.document['squintreffreq']), _pc.document['dosquint'], _any_ec(_pc.document['paincrement']), _pc.document['usesymmetricbeam']))
        return _setpbnumeric_result

    def setpbimage(self, telescope='VLA', othertelescope='', dopb=True, realimage='', imagimage='', compleximage='', antnames=[ '*' ]):
        """Experimental: Supply an image of the E Jones elements. The format of the
        image is:
        begin{description}
        item[Shape] nx by ny by 4 complex polarizations (RR, RL, LR, LL or
        XX, XY, YX, YY) by 1 channel.
        item[Direction coordinate] Az, El
        item[Stokes coordinate] All four ``stokes'' parameters must be present
        in the sequence RR, RL, LR, LL or XX, XY, YX, YY.
        item[Frequency] Only one channel is currently needed - frequency
        dependence beyond that is ignored.
        end{description}
        
        If a compleximage is specified the real and imaginary images is to be left empty.
        
        The other option is to provide the real and imaginary part of the E-Jones as seperale {tt float} images
        On that case
        one or two images may be specified - the real (must be present) and
        imaginary parts (optional).
        
        Note that beamsquint must be intrinsic to the images themselves.
        This will be accounted for correctly by regridding of the images
        from Az-El to Ra-Dec according to the parallactic angle.
        
        antnames is the Vector of names  for which this response pattern apply '*' is for all
        The name has to match exactly the name of the Antennas in the ANTENNA table of the MS with which
        you want to use this VPManager table or object.
        """
        schema = {'telescope': {'type': 'cStr'}, 'othertelescope': {'type': 'cStr'}, 'dopb': {'type': 'cBool'}, 'realimage': {'type': 'cStr'}, 'imagimage': {'type': 'cStr'}, 'compleximage': {'type': 'cStr'}, 'antnames': {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}}
        doc = {'telescope': telescope, 'othertelescope': othertelescope, 'dopb': dopb, 'realimage': realimage, 'imagimage': imagimage, 'compleximage': compleximage, 'antnames': antnames}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _setpbimage_result = _dict_dc(self._swigobj.setpbimage(_str_ec(_pc.document['telescope']), _str_ec(_pc.document['othertelescope']), _pc.document['dopb'], _str_ec(_pc.document['realimage']), _str_ec(_pc.document['imagimage']), _str_ec(_pc.document['compleximage']), [_str_ec(_x) for _x in _pc.document['antnames']]))
        return _setpbimage_result

    def setpbpoly(self, telescope='VLA', othertelescope='', dopb=True, coeff=[ float(-1) ], maxrad=[ ], reffreq=[ ], isthispb='PB', squintdir=[ ], squintreffreq=[ ], dosquint=False, paincrement=[ ], usesymmetricbeam=False):
        """The VP or PB is described as a polynomial of even powers:
        begin{equation}
        VP(x) = sum_{i} coeff_{i} * x^{2i}.
        end{equation}
        """
        schema = {'telescope': {'type': 'cStr'}, 'othertelescope': {'type': 'cStr'}, 'dopb': {'type': 'cBool'}, 'coeff': {'type': 'cFloatVec', 'coerce': [_coerce.to_list,_coerce.to_floatvec]}, 'maxrad': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'reffreq': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'isthispb': {'type': 'cStr'}, 'squintdir': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'squintreffreq': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'dosquint': {'type': 'cBool'}, 'paincrement': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'usesymmetricbeam': {'type': 'cBool'}}
        doc = {'telescope': telescope, 'othertelescope': othertelescope, 'dopb': dopb, 'coeff': coeff, 'maxrad': maxrad, 'reffreq': reffreq, 'isthispb': isthispb, 'squintdir': squintdir, 'squintreffreq': squintreffreq, 'dosquint': dosquint, 'paincrement': paincrement, 'usesymmetricbeam': usesymmetricbeam}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _setpbpoly_result = _dict_dc(self._swigobj.setpbpoly(_str_ec(_pc.document['telescope']), _str_ec(_pc.document['othertelescope']), _pc.document['dopb'], _pc.document['coeff'], _any_ec(_pc.document['maxrad']), _any_ec(_pc.document['reffreq']), _str_ec(_pc.document['isthispb']), _any_ec(_pc.document['squintdir']), _any_ec(_pc.document['squintreffreq']), _pc.document['dosquint'], _any_ec(_pc.document['paincrement']), _pc.document['usesymmetricbeam']))
        return _setpbpoly_result

    def setpbantresptable(self, telescope='', othertelescope='', dopb=True, antresppath=''):
        """Declare a reference to an antenna responses table containing a set of VP/PB definitions.
        """
        schema = {'telescope': {'type': 'cStr'}, 'othertelescope': {'type': 'cStr'}, 'dopb': {'type': 'cBool'}, 'antresppath': {'type': 'cReqPath', 'coerce': _coerce.expand_path}}
        doc = {'telescope': telescope, 'othertelescope': othertelescope, 'dopb': dopb, 'antresppath': antresppath}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _setpbantresptable_result = self._swigobj.setpbantresptable(_str_ec(_pc.document['telescope']), _str_ec(_pc.document['othertelescope']), _pc.document['dopb'], _str_ec(_pc.document['antresppath']))
        return _setpbantresptable_result

    def reset(self):
        """Reinitialize the VPManager database.
        Erase all VPs and defaults defined on the command line.
        """
        _reset_result = self._swigobj.reset()
        return _reset_result

    def setuserdefault(self, vplistnum=int(-1), telescope='', anttype=''):
        """Selects the VP which is to be used by the imager for the given telescope and antenna type.
        Overwrites a previous default. Returns True if successful.
        """
        schema = {'vplistnum': {'type': 'cInt'}, 'telescope': {'type': 'cStr'}, 'anttype': {'type': 'cStr'}}
        doc = {'vplistnum': vplistnum, 'telescope': telescope, 'anttype': anttype}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _setuserdefault_result = self._swigobj.setuserdefault(_pc.document['vplistnum'], _str_ec(_pc.document['telescope']), _str_ec(_pc.document['anttype']))
        return _setuserdefault_result

    def getuserdefault(self, telescope='', anttype=''):
        """Get the vp list number of the present default VP/PB for the given parameters.
        """
        schema = {'telescope': {'type': 'cStr'}, 'anttype': {'type': 'cStr'}}
        doc = {'telescope': telescope, 'anttype': anttype}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _getuserdefault_result = self._swigobj.getuserdefault(_str_ec(_pc.document['telescope']), _str_ec(_pc.document['anttype']))
        return _getuserdefault_result

    def getanttypes(self, telescope='', obstime=[ ], freq=[ ], obsdirection=[ ]):
        """Get a list of the available antenna types.
        """
        schema = {'telescope': {'type': 'cStr'}, 'obstime': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'freq': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'obsdirection': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}}
        doc = {'telescope': telescope, 'obstime': obstime, 'freq': freq, 'obsdirection': obsdirection}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _getanttypes_result = [_str_dc(_x) for _x in self._swigobj.getanttypes(_str_ec(_pc.document['telescope']), _any_ec(_pc.document['obstime']), _any_ec(_pc.document['freq']), _any_ec(_pc.document['obsdirection']))]
        return _getanttypes_result

    def numvps(self, telescope='', obstime=[ ], freq=[ ], obsdirection=[ ]):
        """Can be used to, e.g., determine the number of antenna types.
        Note: if a global response is defined for the telescope, this will increase the count of
        available vps/pbs by 1.
        """
        schema = {'telescope': {'type': 'cStr'}, 'obstime': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'freq': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'obsdirection': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}}
        doc = {'telescope': telescope, 'obstime': obstime, 'freq': freq, 'obsdirection': obsdirection}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _numvps_result = self._swigobj.numvps(_str_ec(_pc.document['telescope']), _any_ec(_pc.document['obstime']), _any_ec(_pc.document['freq']), _any_ec(_pc.document['obsdirection']))
        return _numvps_result

    def getvp(self, telescope='', antennatype='', obstime=[ ], freq=[ ], obsdirection='AZEL 0deg 90deg'):
        """Record is empty if no matching vp/pb could be found.
        """
        schema = {'telescope': {'type': 'cStr'}, 'antennatype': {'type': 'cStr'}, 'obstime': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'freq': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'obsdirection': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}}
        doc = {'telescope': telescope, 'antennatype': antennatype, 'obstime': obstime, 'freq': freq, 'obsdirection': obsdirection}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _getvp_result = _dict_dc(self._swigobj.getvp(_str_ec(_pc.document['telescope']), _str_ec(_pc.document['antennatype']), _any_ec(_pc.document['obstime']), _any_ec(_pc.document['freq']), _any_ec(_pc.document['obsdirection'])))
        return _getvp_result

    def getvps(self, telescope='', antennas=[  ], obstimestart='1970/01/01T00:00:00', obstimeend='1970/01/01T00:00:00', minfreq='1GHz', maxfreq='1GHz', obsdirection='AZEL 0deg 90deg'):
        """Record is empty if no matching vp/pb could be found.
        """
        schema = {'telescope': {'type': 'cStr'}, 'antennas': {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}, 'obstimestart': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'obstimeend': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'minfreq': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'maxfreq': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'obsdirection': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}}
        doc = {'telescope': telescope, 'antennas': antennas, 'obstimestart': obstimestart, 'obstimeend': obstimeend, 'minfreq': minfreq, 'maxfreq': maxfreq, 'obsdirection': obsdirection}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _getvps_result = _dict_dc(self._swigobj.getvps(_str_ec(_pc.document['telescope']), [_str_ec(_x) for _x in _pc.document['antennas']], _any_ec(_pc.document['obstimestart']), _any_ec(_pc.document['obstimeend']), _any_ec(_pc.document['minfreq']), _any_ec(_pc.document['maxfreq']), _any_ec(_pc.document['obsdirection'])))
        return _getvps_result

    def createantresp(self, imdir='', starttime='', bandnames=[  ], bandminfreq=[  ], bandmaxfreq=[  ]):
        """The AntennaResponses table serves CASA to look up the location of images describing the
        response of observatory antennas. Three types of images are supported: "VP" - real voltage patterns,
        "AIF" - complex aperture illumination patterns, "EFP" - complex electric field patterns.
        For each image, a validity range can be defined in Azimuth, Elevation, and Frequency.
        Furthermore, an antenna type (for heterogeneous arrays), a receiver type (for the case of
        several receivers on the same antenna having overlapping frequency bands), and a beam number
        (for the case of multiple beams per antenna) are associated with each response image.
        
        The images need to be stored in a single directory DIR of arbitrary name and need to
        have file names following the pattern
        begin{verbatim}
        obsname_beamnum_anttype_rectype_azmin_aznom_azmax_elmin_elnom_elmax_freqmin_freqnom_freqmax_frequnit_comment_functype.im
        end{verbatim}
        where the individual name elements mean the following (none of the elements may contain
        the space character, but they may be empty strings if they are not numerical values):
        begin{description}
        item[obsname] - name of the observatory as in the Observatories table, e.g. "ALMA"
        item[beamnum] - the numerical beam number (integer) for the case of multiple beams, e.g. 0
        item[anttype] - name of the antenna type, e.g. "DV"
        item[rectype] - name of the receiver type, e.g. ""
        item[azmin, aznom, azmax] - numerical value (degrees) of the minimal, the nominal, and
        the maximal Azimuth where this response is valid, e.g. "-10.5_0._10.5"
        item[elmin, elnom, elmax] - numerical value (degrees) of the minimal, the nominal, and
        the maximal Elevation where this response is valid, e.g. "10._45._80."
        item[freqmin, freqnom, freqmax] - numerical value (degrees) of the minimal, the nominal, and
        the maximal Frequency (in units of frequnit) where this response is valid, e.g. "84._100._116."
        item[frequnit] - the unit of the previous three frequencies, e.g. "GHz"
        item[comment] - any string containing only characters permitted in file names and not empty space
        item[functype] - the type of the image as defined above ("VP", "AIF", or "EFP")
        end{description}
        
        The createantresp method will then extract the parameters from all the images in DIR
        and create the lookup table in the same directory.
        """
        schema = {'imdir': {'type': 'cStr'}, 'starttime': {'type': 'cStr'}, 'bandnames': {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}, 'bandminfreq': {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}, 'bandmaxfreq': {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}}
        doc = {'imdir': imdir, 'starttime': starttime, 'bandnames': bandnames, 'bandminfreq': bandminfreq, 'bandmaxfreq': bandmaxfreq}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _createantresp_result = self._swigobj.createantresp(_str_ec(_pc.document['imdir']), _str_ec(_pc.document['starttime']), [_str_ec(_x) for _x in _pc.document['bandnames']], [_str_ec(_x) for _x in _pc.document['bandminfreq']], [_str_ec(_x) for _x in _pc.document['bandmaxfreq']])
        return _createantresp_result

    def getrespimagename(self, telescope='', starttime='', frequency='', functype='ANY', anttype='', azimuth='0deg', elevation='45deg', rectype='', beamnumber=int(0)):
        """Given the observatory name, the antenna type, the receiver type, the observing frequency, the
        observing direction, and the beam number, find the applicable response image and return its name.
        """
        schema = {'telescope': {'type': 'cStr'}, 'starttime': {'type': 'cStr'}, 'frequency': {'type': 'cStr'}, 'functype': {'type': 'cStr'}, 'anttype': {'type': 'cStr'}, 'azimuth': {'type': 'cStr'}, 'elevation': {'type': 'cStr'}, 'rectype': {'type': 'cStr'}, 'beamnumber': {'type': 'cInt'}}
        doc = {'telescope': telescope, 'starttime': starttime, 'frequency': frequency, 'functype': functype, 'anttype': anttype, 'azimuth': azimuth, 'elevation': elevation, 'rectype': rectype, 'beamnumber': beamnumber}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _getrespimagename_result = _str_dc(self._swigobj.getrespimagename(_str_ec(_pc.document['telescope']), _str_ec(_pc.document['starttime']), _str_ec(_pc.document['frequency']), _str_ec(_pc.document['functype']), _str_ec(_pc.document['anttype']), _str_ec(_pc.document['azimuth']), _str_ec(_pc.document['elevation']), _str_ec(_pc.document['rectype']), _pc.document['beamnumber']))
        return _getrespimagename_result

