<casaxml xsi:schemaLocation="http://casa.nrao.edu/schema/casa.xsd file:///opt/casa/code/tools/xml/casa.xsd" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://casa.nrao.edu/schema/psetTypes.html">

  
<tool module="components" name="componentlist">
<code>
  <include>componentlist_forward.h</include>
  <private>
    <include>componentlist_private.h</include>
  </private>
</code>
  
<shortdescription>A tool for the manipulation of groups of components</shortdescription>
    

<description>

  A componentlist is a tool that contains functions that manipulate
  components. A component is a functional representation of the sky
  brightness - point source, disk, Gaussian, etc.
 
  Note for those new to CASA: components are not used explicitly in
  cleaning, rather the model is stored as an image.  Components are
  useful for e.g. simulation and modifying images (ia.modify), but one
  will not in general have a clean component list associated with
  cleaning data.

  The simplest way to make a componentlist tool is to use cl.addcomponent:
  cl.done()   # it is safest to close it before beginning
  # add a single point source component with 
  # Stokes I=2.3Jy and other Stokes parameters 0  
  cl.addcomponent(dir='J2000 10h30m00 -20d00m00.0', flux=[2.3,0,0,0])  
  cl.rename(&quot;myList.cl&quot;)  # save to disk
 
  One can open a list on disk with cl.open(filename).
 
  Componentlists can be converted to/from records (python dictionaries) 
  with cl.torecord() and cl.fromrecord(record).

</description>



<method name="componentlist" type="constructor">
  <shortdescription>Construct an empty componentlist</shortdescription>
  <description>  
    Use this constructor to construct a componentlist tool that does not
    contain any components. Components can be appended to the list using
    the addcomponent or simulate functions, 
    and the list can be stored to disk by giving it a name with cl.rename
  </description>
</method>
 
<method name="open" type="function">
  <shortdescription>Construct a cl from a table on disk</shortdescription>
  
  <description>
    Use this constructor to construct a componentlist tool by reading
    the data from an table. To ensure that this table contains
    all the necessary columns and to allow the table format to be
    enhanced in the future, it is highly recommended that the table be
    created using a componentlist tool.
    
    The table that contains the componentlist may be opened read-only by
    setting the readonly flag to True. When this is done some of the
    functions in the componentlist tool cannot be used. These include
    the ``set'', ``convert'', ``remove'', ``replace'', ``purge'',
    ``recover'', and ``sort'' functions.
  </description>
  <input>
    
     <param name="filename" type="string">
     <description>The filename of the table</description>
     <value/>
     </param>
  
     <param name="nomodify" type="bool">
     <description>Should the table be opened read only</description>
     <value>false</value>
     </param>
  
     <param name="log" type="bool">
     <description>Send a message to the logger</description>
     <value>true</value>
     </param> 
</input>
<returns type="bool"/>
<example>
cl.open('crux.cl')
</example>
</method>

 
<method name="asciitocomponentlist" type="function">
  <shortdescription>Create a componentlist from an ascii file {\bf (Not implemented yet)}</shortdescription>
  <description>
    This constructor will allow conversion of a number of ascii-file-based
    formats to componentlists. 
  </description>


  <input>
    
    <param name="filename" type="string">
      <description>Name of output component list table</description>
    </param>
    
    <param name="asciifile" type="string">
      <description>Name of input ascii file</description>
    </param>
    
    <param name="refer" type="string">
      <description>Input reference frame</description>
      <value>B1950</value>
      <value>J2000</value>
    </param>
    
    <param name="format" type="string">
      <description>Name of format (only ST supported)</description>
      <value>ST</value>
    </param>
    
    <param name="direction" type="record">
      <description>Direction measure (for relative coordinates)</description>
      <value/>
    </param>
    
    <param name="spectrum" type="record">
      <description>Default spectrum field, valid spectrum field
      [type=&quot;Constant&quot;, frequency=[type=&quot;frequency&quot; , refer=&quot;LSR&quot; , m0=[unit=&quot;GHz&quot; , value=1.0]]
      </description>
      <value/>
    </param>
    
    <param name="flux" type="record">
      <description>Default flux field, valid flux field
      [value=[0.0, 0.0, 0.0, 0.0], unit='Jy', polarization=&quot;Stokes&quot;]</description>
      <value/>
    </param>
    
    <param name="log" type="bool">
      <description>Send a message to the logger</description>
      <value>true</value>
    </param> 
  </input>
  <returns type="int">Number of components found</returns>
</method>

 
<method name="concatenate" type="function">
  <shortdescription>Append components from another componentlist.</shortdescription>
  
  <keyword>concatenate</keyword>
  <description>
    The concatenate function copies the specified component(s), from
    the specified to list, to the end of the current list.  The
    components are specified by numbering them from one to the length
    of the list.  You cannot append components to a list that has been
    opened read only but the list you are copying from may be
    readonly.

    You use a vector of indices to copy a number of components at
    once. By default all components are copied.
  </description>
  <input>
    
     <param name="list" type="any">
     <description>list to copy from. Can be a componentlist record or a componentlist file name from disk </description>
     <value/>
     </param> 
    
     <param name="which" type="intVec">
     <description>which components to copy, -1 unset</description>
     <value><value>-1</value></value>
     </param> 
    
     <param name="log" type="bool">
     <description>Send a message to the logger</description>
     <value>true</value>
     </param> 
  </input>
  <returns type="bool"/>
  <example>    
       cl.addcomponent(flux=1.0, dir='J2000 19h00m00 -40d00m00')
       cl.addcomponent(flux=2.0, dir='J2000 19h10m00 -40d00m00')
       cl.addcomponent(flux=3.0, dir='J2000 19h00m00 -40d00m00')
       cl2 = cltool();
       cl2.concatenate(cl.torecord(), [0,2]);
       cl.done()
       cl2.rename('part_list.cl');
       cl2.done()
    We make a 3 component component list and
    copies the first and third component to another a componentlist
    that was initially empty. These components are then saved to the
    table called part_list.cl.

      cl.close() ### make sure we start with empty componentlist
      cl.concatenate('crux.cl', [0,2]);
      cl.rename('crux-copy.cl');
      cl.done()
    
    This example reads a componentlist from a casa table and
    copies the first and third component to another a componentlist
    that was initially empty. These components are then saved to the
    table called crux-copy.cl.
  </example>
</method>

<method name="fromrecord" type="function">
  
  <shortdescription>make a componentlist tool from a record</shortdescription>
  
  <keyword>fromrecord</keyword>
  <description>
    
    This function allows the componentlist records that are returned
    by other functions (for e.g from imageanalysis tool) be converted
    to a tool to be manipulated or to be saved on disk
    
  </description>
  <input>
    
    <param name="record" type="record">
      <description> a component list record </description>
      <value/>
    </param> 
    
    
  </input>
  <returns type="bool"/>
  <example>
    
      
      cl2 = cltool()
     
      cl2.fromrecord(ia.findsources())
      cl2.rename('sourcesfound.cl')
      cl2.done()
    
  </example>
  <comments>
    This example uses the image analysis tool source finding function
    that returns a componentlist record. A componentlist tool is
    created and the componentlist is saved to disk.
  </comments>
</method>


<method name="torecord" type="function">

   <shortdescription>convert componentlist to a record</shortdescription>
   
  <keyword>fromrecord</keyword>
  <description>

    This function allows the componentlist to be converted to a
    record. Usually useful to pass to other functions in image
    analysis for e.g

  </description>
  <input>
    
    
     
  </input>
  <returns type="record">Componentlist tool </returns>
  <example>
    
      cl2=cltool()
      cl.open('mycomp.cl')
     
      cl2.fromrecord(ia.deconvolvecomponentlist(cl.torecord()))
      cl2.rename('deconvolved_sources.cl')
      cl2.done()
    
  </example>
  <comments>
    This example uses the image analysis tool to deconvolve the
    components in componentlist 'mycomp.cl' and stores the resultant
    componentlist in 'deconvolved_sources.cl'
  </comments>
</method>

 
<method name="remove" type="function">
  <shortdescription>Remove a component from the list.</shortdescription>
  
  <keyword>remove</keyword>
  <description>

    The remove function removes the specified component(s) from the
    list. Components are specified by numbering them from one to the
    length of the list. So removing component one will remove the
    first component. After using this function all the
    remaining components will be shuffled down so that component two
    becomes component one.  You cannot remove components from a list
    that has been opened read only.

    You can specify a vector of indices to remove a number of
    components at once. For example in a five element list removing
    elements [1,3,5] will result in a two element list, now indexed as 
    elements one and two, containing what was previously the second
    and fourth components. 
  
    Components that have been deleted using this function are not
    lost. The recover function can be used to get them back unless the
    purge function has been executed. Then they are completely gone.

  </description>
  <input>
    
     <param name="which" type="intVec">
     <description>indices of which component(s) to remove
     a vector containing unique integers between
     0 and one less than the length of the list, -1 for all</description>
     <value><value>-1</value></value>
     </param> 
    
     <param name="log" type="bool">
     <description>Send a message to the logger</description>
     <value>true</value>
     </param> 
  </input>
  <returns type="bool"/>
  <example>
    
      cl.open('crux.cl')
      cl.remove(1)
    
  </example>
  <comments>
    This example reads a componentlist from an \aipspp\ table and
    removes the first element from the list.
  </comments>
</method>

 
<method name="purge" type="function">
  <shortdescription>Permanently delete removed components.</shortdescription>
   
  <keyword>purge</keyword>
  <description>

    The remove function deletes components from the list but does not
    remove them from memory. They remain accessible and can be
    obtained with the recover function. The purge function frees up
    the memory occupied by the removed components. You cannot use the
    recover function to obtain the removed components after the purge
    function has been called.

  </description>
  <returns type="bool"/>
  <example>
    
      cl.open('crux.cl')
      cl.remove(1)
      cl.purge()
    
  </example>
  <comments>
    This example reads a componentlist from a table and removes the first
    element from the list and then frees up the memory associated with 
    the removed component.
  </comments>
</method>

 
   <method name="recover" type="function">
   <shortdescription>Obtain removed components.</shortdescription>
   
  <keyword>recover</keyword>
  <description>
    The recover function appends components to the end of the list
    that have been deleted with the remove function. This does not
    include components that were removed before the purge function was
    last executed.
  </description>
  <input>
    
     <param name="log" type="bool">
     <description>Send a message to the logger</description>
     <value>true</value>
     </param> 
  </input>
  <returns type="bool"/>
  <example>
    
      cl.open('crux.cl')
      cl.remove(1)
      cl.recover()
    
  </example>
  <comments> 
    This example reads a componentlist from a table and removes the
    first element from the list. The recover function is then called
    to append the component to the end of the list. Overall the list
    is unchanged although the first component has been moved to the end.
  </comments>
</method>

 
   <method name="length" type="function">
   <shortdescription>Find the number of components in the list.</shortdescription>
   
  <keyword>length</keyword>
  <description>
    The length function returns a non-negative integer that
    indicates how many components the list currently contains. 
  </description>
  <returns type="int"/>
  <example>
    
      cl.open('crux.cl')
      n = cl.length()
    
  </example>
  <comments>
    This example creates an empty componentlist. Hence the variable
    'n' will be zero after the length function is executed.
  </comments>
</method>

 
<method name="indices" type="function">
   <shortdescription>Return a vector of indices. (Not implemented yet)</shortdescription>
   
  <keyword>indices</keyword>
  <description>
    The indices function will returns a vector of non-negative
    integers that can be used to index through the list. This vector
    always contains the integers starting at one and increasing
    sequentially to the length of the list. Its main use is in for
    loops as is illustrated in the example below.
  </description>
  <returns type="intVec"/>
</method>

 
<method name="sort" type="function">
   <shortdescription>Sort the components in a list</shortdescription>
   
  <keyword>sort</keyword>
  <description>
    The sort function can sort all the components in a list using a
    variety of criteria. Currently the following criteria are
    available:
      Flux: Sorts the list so that the brightest components, 
        as defined by Stokes I, are at the beginning of the list.
      Position: Sorts the list so that components that are
        closest to a reference position, which is currently fixed at 
        (ra,dec)=(0,0), are at the beginning of the list.
      Polarization: Sorts the list so that components with the
        largest fractional polarization, sqrt(Q**2+U**2+V**2)/I, are
        at the front of the list. Components where I=0 are placed at 
        the end of the list.
    The parsing of the string containg the sorting criteria is case
    insensitive. You cannot sort a list that has been opened read only.
  </description>
  <input>
    
     <param name="criteria" type="string">
     <description>a string containg the criteria to use to sort the list</description>
     <value>Polarization</value>
     <value>Position</value>
     <value>Flux</value>
     </param>
    
     <param name="log" type="bool">
     <description>Send a message to the logger</description>
     <value>true</value>
     </param> 
  </input>
  <returns type="bool"/>
  <example>
    
      cl.open('crux.cl')
      cl.sort('Polarization')
    
  </example>
  <comments>
    This example reads a componentlist from disk and then proceeds to
    sort the components so that the most polarized components are at
    the front of the list.
  </comments>
</method>

 
<method name="isphysical" type="function">
   <shortdescription>Check if a component is physically plausible</shortdescription>
   
  <keyword>isphysical</keyword>
  <description>
    The isphysical function is used to check if the specified
    components meet a number of criteria that must be true if the
    component could be used to model a physical process. These
    criteria are:
     1. I &gt;= sqrt(Q**2 + U**2 + V**2)
     2. That the flux, when represented using the Stokes
          representation, has a zero imaginary value.

    The ``Flux properties'' section of the ComponentModels module
    documentation describes how it is possible to generate a
    component which has non-zero imaginary value in the Stokes
    representation.

    It is possible to check a number of components at once by
    specifying the indicies of all the components. The returned value
    will only be True if all the specified components are physical.

  </description>
  <input>
    
    <param name="which" type="intVec">
     <description>A vector of indices
     Indices must be between 0 and one less than the list length, inclusively</description>
     <value><value>-1</value></value>
     </param>
  </input>
  <returns type="bool"/>
  <example>
    
      cl2 = cltool()
      cl2.simulate(2)
      cl2.setflux(1, value=[10, 1+3j, 1-4j, 0], polarization=&quot;linear&quot;);
      print cl2.isphysical([0,1])
    
  </example>
  <comments>
    This example creates a non-physical component hence the print
    statement will return False.
  </comments>
</method>

 
<method name="sample" type="function">
   <shortdescription>Sample the flux of the list in a specified direction. (Not implemented yet)</shortdescription>
   
  <keyword>sample</keyword>
  <description>

    The sample function will returns a vector containing the flux in
    Janskys/pixel of all the components in the list, in the specified
    direction, at the specified frequency. The returned vector always
    contains four elements corresponding to the Stokes parameters
    I,Q,U,V.

  </description>
  <input>
    
     <param name="direction" type="any">
     <description>The direction to sample
     any valid direction measure. A valid Direction measure or vector of string or string, e.g me.direction('J2000','19h30m00', '-20d00m00') or ['J2000','19h30m00', '-20d00m00'] or 'J2000 19h30m00 -20d00m00'</description>
     <value>J2000 00h00m00.00 90d00m00.0</value>
     </param>
    
     <param name="pixellatsize" type="any">
     <description>the x-size of the in pixels to use when sampling
     any quantity that has angular units.</description>
     <value>0.0deg</value>
     </param>
    
     <param name="pixellongsize" type="any">
     <description>the y-size of the in pixels to use when sampling
     any quantity that has angular units.</description>
     <value>0.0deg</value>
     </param>
    
     <param name="frequency" type="any">
     <description>The frequency to sample at
     Any frequency measure</description>
     <value>1.4GHz</value>
     </param>
  </input>
  <returns type="doubleVec">
  <description>A vector with four elements containing the flux in Janskys/pixel
    in the I,Q,U,V polarizations
  </description></returns>

</method>

 
<method name="rename" type="function">
  <shortdescription>Give the list a name so it can save itself. use close to save to disk</shortdescription>
   
  <keyword>rename</keyword>
  <description>

    The rename function is used to specify the name of the table
    associated with this componentlist.
    
    When a componentlist is created it is not associated with an casa
    table. So when the componentlist is removed from memory its
    contents are lost. But if a name is attached to the componentlist,
    using the rename function, then its contents are saved in a table
    with the specified name when the componentlist is closed
    
    NOTE: that by just using rename the componentlist is not ensured
    to be on disk; to be sure use close after rename

    If the componentlist is created using the open() constructor then
    this function will rename the table associated with the list to
    the user specified name. You cannot rename a componentlist that
    has been opened read only.
    
    
    
  </description>
  <input>
    
     <param name="filename" type="string">
     <description>The filename of the table</description>
     </param>
    
     <param name="log" type="bool">
     <description>Send a message to the logger</description>
     <value>true</value>
     </param> 
  </input>
  <returns type="bool"/>
  <example>
    
    
    cl.simulate(1);
    cl.setshape(0, 'gaussian', '35mas', '27mas', '-10d')
    cl.setflux(0, [1.0, 0.2, 0.1, 0.01]);
    cl.rename('smallblob.cl');
    cl.close();
    
    cl.open('smallblob.cl')
    n=cl.length()

    This example starts with an  empty componentlist tool and then adds
    one component to it. The parameters of this component are then
    modified to change the shape and flux and the list saved in the
    casa table called 'smallblob.cl' The data is not written to
    disk until the list is closed, and when it is the componentlist is
    reset. So you need to reopen it if you want to interact with it.
  </example>
 

</method>

 
<method name="simulate" type="function">
   <shortdescription>Add some simulated components to the list</shortdescription>
   
  <keyword>simulate</keyword>
  <description>
    The simulate function adds simulated components to the list. The
    simulation criterion is very simple, all the components added are
    identical! They are point sources at the J2000 north pole with a
    flux in Stokes I of 1~Jy, and zero in the other polarizations. The
    spectrum is constant. The 'set' functions (eg. setflux, setfreq)
    can be used to change these parameters to desired ones.

    The howmany argument indicates how many components to append to
    the list.
  </description>
  <input>
    
     <param name="howmany" type="int">
     <description>How many components to simulate, greater than zero</description>
     <value>1</value>
     </param>
    
     <param name="log" type="bool">
     <description>Send a message to the logger</description>
     <value>true</value>
     </param> 
  </input>
  <returns type="bool"/>
  <example>

      cl.simulate(2)
      cl.setflux(1, [2.78, 0, 0, 0]);
      cl.rename('test.cl');
      cl.close();
    
  
  
    This example creates a componentlist with two components.  The setflux function is used to
    modify the second component.  The list is then saved on disk. 
    I use short scripts like this a lot during testing. 

    

  
  </example>
</method>

 
<method name="addcomponent" type="function">
   <shortdescription>Add a component to the list</shortdescription>
   
  <keyword>addcomponent</keyword>
  <description>

    The addcomponent function is a convenience function that ties
    together the simulate function, and the various set
    functions. This function adds a component to the end of the
    list. For a description of the arguments see the following
    functions.
      [flux, fluxunit, polarization] See setflux
      [ra, raunit, dec, decunit] See setrefdir
      [dirframe] See setrefdirframe
      [shape, majoraxis, minoraxis, positionangle] See setshape
      [freq] A frequency quantity which is split into a value and
        units and passed to the setfreq function 
      [freqframe] See setfreq 
      [spectrumtype, index] The spectral index alpha such that flux density S 
        as a function of frequency nu is: S~nu**alpha.
	See also the setspectrum or setstokesspectrum functions.
      [label] See setlabel 
  </description>
  <input>

     <param name="flux" type="any">
     <description>The flux value.
     A vector with four real or complex numbers</description>


   <value/>
   </param>
     <param name="fluxunit" type="string">
     <description>The units of the flux.
     Any string with the same dimensions as the Jansky</description>
     <value>Jy</value>
     </param>
    
     <param name="polarization" type="string">
     <description>The polarization of the value field.
     ``Stokes'', ``linear'' or ``circular''</description>
     <value>Circular</value>
     <value>Linear</value>
     <value>Stokes</value>
     </param>
    
     <param name="dir" type="any">
     <description>The direction measure of the source, it can a be any direction measure from the measures tool or a string of the type 'J2000 10h30m00 -20d00m00.0' or a vector of strings of the type ['J2000', '10:30:00.00', '-20.00.00.0']. Basically the string or strings should have the direction frame and quantities for Ra and Dec</description>
     <value>J2000 00h00m00.0 90d00m00.0</value>
     </param>

    
    
     <param name="shape" type="string">
     <description>The new shape type.
     A string that is either 'point', 'Gaussian', or 'disk'</description>
     <value>disk</value>
     <value>Gaussian</value>
     <value>point</value>
     </param>
    
     <param name="majoraxis" type="any">
     <description>The width (FWHM in the case of a Gaussian) of the larger axis.
     A quantity with angular units</description>
     <value>2.0arcmin</value>
     </param>
    
     <param name="minoraxis" type="any">
     <description>The width (FWHM in the case of a Gaussian) of the smaller axis.
     A quantity with angular units</description>
     <value>1.0arcmin</value>
     </param>
    
     <param name="positionangle" type="any">
     <description>The rotation of the axes with respect to
                             the reference frame.
     A quantity with angular units</description>
     <value>0.0deg</value>
     </param>
    
     <param name="freq" type="any">
     <description>The reference frequency.
     A quantity with units equivalent to the 'Hz' and frame or a frequency measure, e.g ['TOPO', '1.6GHz'], or simply default frame (LSRK) '1.6GHz' </description>
     <value>LSRK 1.415GHz</value>
     </param>
    
    
     <param name="spectrumtype" type="string">
     <description>The spectrum type,
     a string that is one of 'constant', 'spectral index', or 'plp'</description>
     <value>spectral index</value>
     <value>constant</value>
     </param>
    
     <param type="any" name="index" limittypes="int, intArray, double, doubleArray">
     <description>The spectral index or coeffecients for plp.</description>
     <value>1.0</value>
     </param>
    
     <param name="optionalparms" type="doubleVec">
     <description>optional parameters in vector (for future use)</description>
     <value><value>0.0</value></value>
     </param>

     <param name="label" type="string">
     <description>The label for the component</description>
     <value/>
     </param>
  </input>
  <returns type="bool"/>
  <example>
      cl.open('my.cl')
      cl.addcomponent(
        shape='point', flux=[1.0, 0.0, 0.0, 0.0], dir='J2000 19h00m00 -20d00m00',
        spectrumtype='plp', index=[1, 2, 3]
      )

      In this example, a point source with a power log polynomial
      spectrum having the specified indices is added.
  </example>

</method>

 
<method name="close" type="function">
  <shortdescription>Save the componentlist to disk and reset its state.</shortdescription>
  
  <keyword>close</keyword>
  <description>
    The close function resets the componentlist to its default state. In
    this state it contains no components and is not associated with
    any table. 
    
    This function flushes all the components in memory to disk if the
    componentlist is associated with a table. The table is then
    closed, and the contents of the list deleted.
    
    If the list is not associated with a table its contents are still
    deleted and memory used by the list is released.
  </description>
  <input>
    
     <param name="log" type="bool">
     <description>Send a message to the logger</description>
     <value>true</value>
     </param> 
  </input>
  <returns type="bool"/>
  <example>
    See the example for the
    <link anchor="componentmodels:componentlist.rename.function">rename</link> function.
  </example>
</method>

 
<method name="edit" type="function">
   <shortdescription>Start up the component editor gui (Not implemented yet)</shortdescription>
   
  <keyword>edit</keyword>
  <description>

  </description>
  <input>
    
     <param name="which" type="int">
     <description>An index specifying which component.
       An integer between 0 and one less than the list length</description>
     <choice>no default</choice>
     </param>
    
     <param name="log" type="bool">
     <description>Send a message to the logger</description>
     <value>true</value>
     </param> 
  </input>
  <returns type="bool"/>

</method>

 
<method name="done" type="function">
   <shortdescription>Delete the componentlist tool</shortdescription>
   
  <keyword>close</keyword>
  <description>
    The done function frees up all the memory associated with a
    componentlist tool. After calling this function the componentlist 
    tool cannot be used, either to manipulate the current list, or
    to open a new one. This function does not delete the disk
    file associated with a componentlist, but it will shut down the
    server process if there are no other componentlist tools being used.
  </description>
  <returns type="bool"/>
  <example>
    See the example for the rename function.
  </example>
</method>

 
<method name="select" type="function">
   <shortdescription>Mark components in the list</shortdescription>
   
  <keyword>select</keyword>
  <description>
    The select function is used to mark the specified components as
    ``selected''. This function will be used in conjunction with the
    planned graphical user interface. Other functions functions in the
    componentlist tool will behave no differently if a component is
    marked as ``selected''.

    Components are not selected when the list is initially read
    from disk or when a new component is added to the list using the 
    simulate function.
  </description>
  <input>
    
    <param name="which" type="intVec">
      <description>A vector of indices.
Indices must be between 0 and one less than the list length, inclusively</description>
     </param>
  </input>
  <returns type="bool"/>
  <example>
    
      cl.open('crux.cl')
      cl.select([1,3])
    
  </example>
  <comments>
    This example reads a list from disk and then marks the first and
    third component as selected.
  </comments>
</method>

 
<method name="deselect" type="function">
   <shortdescription>Unmark components in the list</shortdescription>
   
  <keyword>deselect</keyword>
  <description>

    The deselect function is used to remove the ``selected'' mark from
    specified components in the list. This function wiil be used in
    conjunction with the planned graphical user interface and no other
    functions in the componentlist will behave differently if a
    component is marked as ``selected'' or not.

    Components are not selected when the list is initially read from
    disk or when a new component is added to the list using the
    simulate function.  function. Deselecting a component that is
    already deselected is perfectly valid and results in no change.
  </description>
  <input>
    
     <param name="which" type="intVec">
     <description>A vector of indices
     Indices must be between 0 and one less than the list length, inclusively</description>
     </param>
  </input>
  <returns type="bool"/>
  <example>
    
      cl.open('crux.cl')
      cl.select([1,3])
      cl.deselect([2,3])
    
  </example>
  <comments>
    This example reads a list from disk. After the deselect operation
    only the first component is still selected.
  </comments>
</method>

 
<method name="selected" type="function">
   <shortdescription>Determine which components are selected</shortdescription>
   
  <keyword>selected</keyword>
  <description>
    The selected function is used to determine which components in a
    list are selected. It returns a vector with indices that indicate
    which components are selected. A zero length vector is returned if 
    no components are selected.

    Components are marked as selected using the
    <link anchor="componentmodels:componentlist.select.function">select</link>
    function. This function will be used in conjunction with the
    graphical user interface and other functions in the componentlist
    tool will behave no differently if a component is marked as
    ``selected'' or not.

  </description>
  <returns type="intVec"><description>A vector of integers between 0 and one less than the list length</description></returns>
  <example>
    
      cl.open('crux.cl')
      cl.select([1,3])
      cl.deselect([2,3])
      cl.selected()
    
  </example>
  <comments>
    This example reads a list from disk. After the deselect operation
    only the first component is still selected and the selected
    function will return [1]
  </comments>
</method>

 
<method name="getlabel" type="function">
   <shortdescription>Get the label of the specified component</shortdescription>
   
  <keyword>getlabel</keyword>
  <description>
     The getlabel function returns the label associated with the specified
     component. The label is an arbitrary text string that can be used 
     to tag a component.
  </description>
  <input>
    
     <param name="which" type="int">
	     <description>An index specifying which component.
		     An integer between 0 and one less than the list length, inclusively</description>
     </param>
  </input>
  <returns type="string"/>
  <example>
    
      cl.open('crux.cl')
      cl.getlabel(1)
    
  </example>
  <comments>
  This example prints the label associated with the first
  component. It returns 'Alpha Crux'.
  </comments>
</method>

 
<method name="setlabel" type="function">
   <shortdescription>Set the label of the specified components</shortdescription>
   
  <keyword>setlabel</keyword>
  <description>
     The setlabel function is used to reassign the label (an arbitrary
     text string) of the specified components to
     a new value. 
  </description>
  <input>
    
     <param name="which" type="int">
     
     <description>An index specifying the component to modify.
     An integer between 0 and one less than the list length, inclusively</description>
     <choice>no default</choice>
     </param>
    
     <param name="value" type="string">
     <description>The label for the specified components</description>
     </param>
    
     <param name="log" type="bool">
     <description>Send a message to the logger</description>
     <value>true</value>
     </param> 
  </input>
  <returns type="bool"/>
  <example>
    
      cl.open('centarusA.cl')
      cl.setlabel(1, 'Core')
       
  </example>
  <comments>
    This example reads a model of Centarus A which contains at least
    23 components. It then marks the first one as the core, the next
    nine as the left lobe, and the next thirteen as the right lobe. The
    lobes may, for example, be modelled using a collection of Gaussian
    shaped components.
  </comments>
</method>

 
   <method name="getfluxvalue" type="function">
   <shortdescription>Get the flux value of the specified component</shortdescription>
   
  <keyword>getfluxvalue</keyword>
  <description>
     The getfluxvalue function returns the value of the flux of the
     specified component using the current units and the current
     polarization representation. The functions 
     <link anchor="componentmodels:componentlist.getfluxunit.function">getfluxunit</link> \&amp;
     <link anchor="componentmodels:componentlist.getfluxpol.function">getfluxpol</link> \&amp;
     can be used to get the units and polarization
     representation that corresponds to the supplied value.
  </description>
  <input>
    
     <param name="which" type="int">
     <description>An index specifying which component.
     An integer between 0 and one less than the list length, inclusively</description>
     <choice>no default</choice>
     </param>
  </input>
  <returns type="doubleVec"><description>A vector of length 4 with the flux values in the current
		  units and polarization representation.</description></returns>
  <example>
    
      cl.open('crux.cl');
      flux = cl.getfluxvalue(1);
      unit = cl.getfluxunit(1);
      
    
    This example returns the values, units, polarization and error of the
    first component in the list.
  </example>
</method>

 
   <method name="getfluxunit" type="function">
   <shortdescription>Get the flux unit of the specified component</shortdescription>
   
  <keyword>getfluxunit</keyword>
  <description>
     The getfluxunit function returns the units of the flux of the
     specified component. The actual values are obtained using the 
     <link anchor="componentmodels:componentlist.getfluxvalue.function">getfluxvalue</link> function.
  </description>
  <input>
    
     <param name="which" type="int">
     <description>An index specifying which component.
     An integer between 0 and one less than the list length, inclusively</description>
     </param>
  </input>
  <returns type="string"><description>A string with the units of the flux for the specified component</description></returns>
  <example>
  See the example for the
  <link anchor="componentmodels:componentlist.getfluxvalue.function">getfluxvalue</link> function.
  </example>
</method>

 
   <method name="getfluxpol" type="function">
   <shortdescription>Get the polarization representation for the flux of the specified component {\bf (Not implmented yet)}</shortdescription>
   
  <keyword>getfluxpol</keyword>
  <description>
     The getfluxunit function returns the polarization representation
     of the flux of the specified component. The actual values are
     obtained using the
     <link anchor="componentmodels:componentlist.getfluxvalue.function">getfluxvalue</link>
     function.
  </description>
  <input>
    
     <param name="which" type="int">
     <description>An index specifying which component.
An integer between 0 and one less than the list length, inclusively</description>
     </param>
  </input>
  <returns type="string"><description>A string containing either ``Stokes'', ``linear'' or 
             ``circular''. If ``Stokes'' is returned, then the flux
             values are the \verb+[I,Q,U,V]+ components of the
             polarization and are always real. For ``linear and
             ``circular'' the values returned are complex. 
             If the value is
              ``linear'' then the values returned are the
             \verb+[XX,XY,YX,YY]+ components of the polarization.
             The parrallactic angle is assumed to
             be zero in this case. If the value is ``circular'' then
             the values returned are the \verb+[RR,RL,LR,LL]+
	     components of the polarization.</description></returns>
  <comments>
  See the example for the
  <link anchor="componentmodels:componentlist.getfluxvalue.function">getfluxvalue</link> function.
  </comments>
</method>

 
   <method name="getfluxerror" type="function">
   <shortdescription>Get the error in the flux of the specified component</shortdescription>
   
  <keyword>getfluxerror</keyword>
  <description>
     The getfluxerror function returns the error in the flux of the
     specified component using the current units and the current
     polarization representation. The functions 
     <link anchor="componentmodels:componentlist.getfluxvalue.function">getfluxvalue</link> \&amp;
     <link anchor="componentmodels:componentlist.getfluxunit.function">getfluxunit</link> \&amp;
     <link anchor="componentmodels:componentlist.getfluxpol.function">getfluxpol</link> \&amp;
     can be used to get the value, units and polarization
     representation that corresponds to the specified error.

     No error calculations are done by this tool. The error can be
     stored and retreived and if any of the parameters of the flux
     change the user is responsible for updating the errors.
  </description>
  <input>
    
     <param name="which" type="int">
     <description>Index specifying which component.
     An integer between 0 and one less than the list length, inclusively</description>
     </param>
  </input>
  <returns type="doubleVec"><description>A vector of length 4 with the errors in the flux values
		  in the current units and polarization representation.</description></returns>
  <comments>
  See the example for the
  <link anchor="componentmodels:componentlist.getfluxvalue.function">getfluxvalue</link> function.
  </comments>
</method>

 
   <method name="setflux" type="function">
   <shortdescription>Set the flux of the specified components</shortdescription>
   
  <keyword>setflux</keyword>
  <description>
     The setflux function is used to reassign the flux of the
     specified components to a new value. The flux value, unit and
     polarization can be specified and any number of components can be
     set to the new value.  (Currently, the parameter, error is
     ignored.)
  </description>
  <input>
    
     <param name="which" type="int">
     <description>A vector of indices specifying the components to modify.
     A vector with indices between 0 and one less than the list length, inclusively</description>
     </param>
    
     <param name="value" type="any">
     <description>The flux values for the specified components
     A vector with four real or complex numbers</description>
     <value/>
     </param>
    
     <param name="unit" type="string">
     <description>The units of the flux.
     Any string with the same dimensions as the Jansky</description>
     <value>Jy</value>
     </param>
    
     <param name="polarization" type="string">
     <description>The polarization of the value field</description>
     <value>circular</value>
     <value>linear</value>
     <value>Stokes</value>
     </param>
    
     <param name="error" type="any">
     <description>The error in the value field.
     A complex vector of length four.</description>

     <value/>
     </param>
    
     <param name="log" type="bool">
     <description>Send a message to the logger</description>
     <value>true</value>
     </param> 
  </input>
  <returns type="bool"/>
  <example>
    
      cl.open('crux.cl');
      cl.setflux(0, [1,0,0,0], unit='jy', 
	         polarization='Stokes', error=[.3, 0, 0, 0])
    
  </example>
  <comments>
  This example sets all the components in the list to a flux of 1 Jy
  in I and zero in the Q,~U,~\&amp;~V polarizations.
  </comments>
</method>

 
   <method name="convertfluxunit" type="function">
   <shortdescription>Change (convert) the flux units of the specified components</shortdescription>
   
  <keyword>convertfluxunit</keyword>
  <description>
    The convertfluxunit function is used to convert the flux to another 
    unit. The units \emph{must} have the same dimensions as the Jansky.
  </description>
  <input>
    
     <param name="which" type="int">
     <description>A vector of indices specifying the components to modify.
     A vector with indices between 0 and one less than the list length, inclusively</description>
     </param>
    
     <param name="unit" type="string">
     <description>The units of the flux.
     Any string with the same dimensions as the Jansky</description>
     <value>Jy</value>
     </param>
  </input>
  <returns type="bool"/>
  <example>
    
      cl.open('crux.cl')
      print cl.getfluxvalue(1)
      cl.convertflux(1, 'WU')
      print cl.getfluxvalue(1)
    
  </example>
  <comments>
    This example converts the flux of component 1 to ``Westerbork
    Units''. Assuming the units were originally Jansky's then the
    numbers printed before and after the call to the convertfluxunit
    function will differ by a factor of 200.
  </comments>
</method>

 
   <method name="convertfluxpol" type="function">
   <shortdescription>Change (convert) the polarization representation of the specified components</shortdescription>
   
  <keyword>convertfluxpol</keyword>
  <description>
    The convertfluxpol function is used to convert the flux to another 
    polarization representation. There are are three representations
    used, namely , 'Stokes', 'linear' \&amp; 'circular'
  </description>
  <input>
    
     <param name="which" type="int">
     <description>A vector of indices specifying the components to modify.
     A vector with indices between 0 and one less than the list length, inclusively</description>
     </param>
    
     <param name="polarization" type="string">
     <description>The new polarization representation</description>
     <value>circular</value>
     <value>linear</value>
     <value>Stokes</value>
     </param>
  </input>
  <returns type="bool"/>
  <example>
    
      cl.open('centarusA.cl')
      print cl.getfluxvalue(1)
      cl.convertfluxpol(1, 'linear')
      print cl.getfluxvalue(1)
    
  </example>
  <comments>
    This example converts the flux of the first component to a linear
    representation. If the flux was originally [1,0.1,0,0.01] (in
    the Stokes representation) then the resultant flux will be 
    [1.1, 0.01i, -0.01i, 0.9]. Note that the flux is returned as a
    complex vector when the polarization representation is not Stokes.
  </comments>
</method>

 
   <method name="getrefdir" type="function">
   <shortdescription>Return the reference direction</shortdescription>
   
  <keyword>getrefdir</keyword>
  <description>
    The getrefdir function returns, as a direction measure, the
    reference direction for the specified component. The reference
    direction is for all the currently supported component shapes the
    direction of the centre of the component.
  </description>
  <input>
    
     <param name="which" type="int">
     <description>An index specifying which component.
     An integer between 0 and one less than the list length, inclusively</description>
     </param>
  </input>
  <returns type="record"><description>Workaround should return an MDirection</description></returns>
  <example>
    
      cl.open('crux.cl')
      dir = cl.getrefdir(1)
    
  </example>
  <comments>
    This example returns the direction of the centre of the first
    component in the componentlist. The returned value is a direction
    measure that can be used as an argument to many functions.
  </comments>
</method>

 
   <method name="getrefdirra" type="function">
   <shortdescription>Get the RA of the reference direction. (Not implemented not)</shortdescription>
   
  <keyword>getrefdirra</keyword>
  <description>

  </description>
  <input>
    
     <param name="which" type="int">
     <description>An index specifying which component.
     An integer between 0 and one less than the list length, inclusively</description>
     </param>
    
     <param name="unit" type="string">
     <description>The angular unit of the returned value.
     Any string containing an angular unit or 'angle' or 'time'</description>
     <value>deg</value>
     </param>
    
     <param name="precision" type="int">
     <description>The number of digits in the returned string.
     Numbers between 1 and 16 make the most sense</description>
     <value>6</value>
     </param>
  </input>
  <returns type="string"><description>A formatted string containing the RA of the reference direction.</description></returns>

</method>

 
   <method name="getrefdirdec" type="function">
   <shortdescription>Get the declination of the reference direction.(Not implemented yet)</shortdescription>
   
  <keyword>getrefdirdec</keyword>
  <description>

    The getrefdirdec function returns the declination of the reference
    direction of the component as a formatted string. If the reference
    frame is something other than J2000 or B1950 the value returned is
    the longitude or the altitude.

    See the getrefdirra function for a description of the unit and
    precision arguments.

  </description>
  <input>
    
     <param name="which" type="int">
     <description>An index specifying which component.
	     An integer between 0 and one less than the list length, inclusively</description>
     </param>
    
     <param name="unit" type="string">
     <description>The angular unit of the returned value.
     Any string containing an angular unit or 'angle' or 'time'</description>
     <value>deg</value>
     </param>
    
     <param name="precision" type="int">
     <description>The number of digits in the returned string.
     Numbers between 1 and 16 make the most sense</description>
     <value>6</value>
     </param>
 </input>
 <returns type="string"><description>A formatted string containing the declination
		 of the reference direction.</description></returns>
  <example>
    See the example for the
    <link anchor="componentmodels:componentlist.getrefdirra.function">getrefdirra</link> function.
  </example>
</method>

 
   <method name="getrefdirframe" type="function">
   <shortdescription>Get the reference frame of the reference direction.</shortdescription>
   
  <keyword>getrefdirframe</keyword>
  <description>
    The getrefdirframe function returns the reference frame of the reference
    direction of the component as a string. The returned string is
    always in upper case. Common frames are, 'J2000', 'B1950' and 'GALACTIC'.

  </description>
  <input>
    
     <param name="which" type="int">
     <description>An index specifying which component.
     An integer between 0 and one less than the list length, inclusively</description>
     </param>
  </input>
  <returns type="string"><description>A formatted string containing the reference frame
		  of the reference direction.</description></returns>
  <example>
    See the example for the
    <link anchor="componentmodels:componentlist.getrefdirra.function">getrefdirra</link> function.
  </example>
</method>

 
   <method name="setrefdir" type="function">
   <shortdescription>Set the reference direction</shortdescription>
   
  <keyword>setrefdir</keyword>
  <description>
    The setrefdir function sets the reference direction of the
    specified components to a new value. The direction is defined by
    separately specifying the right ascension and the declination.

    The right ascension is specified as a string or a real number

    Ra can be in standard angle units 'deg', 'rad', or time formatted as such 'HH:MM:SS.sss'
    eg., '19:34:63.8' or angle formatted as such  '+DDD.MM.SS.sss' eg.,
    '127.23.12.37'. 

    Similarly the declination is specified as a string or a real
    number and the decunit can be any angular unit or 'angle' or
    'time'.
  </description>
  <input>
    
     <param name="which" type="int">
     <description>A vector of indices specifying the components to modify.
     A vector with indices between 0 and one less than the list length, inclusively</description>
     <value>1</value>
     </param>
    
     <param name="ra" type="any">
     <description>The RA of the new direction,
     A formatted string or a number</description>
     <value/>
     </param>
    
     <param name="dec" type="any">
     <description>The declination of the new direction.
     A formatted string or a number</description>
     <value/>
     </param>
 
    
     <param name="log" type="bool">
     <description>Send a message to the logger</description>
     <value>true</value>
     </param> 
  </input>
  <returns type="bool"/>
  <example>
    
      cl.simulate(3)
      cl.setrefdir(0, '12:26:35.9', '-63.5.56')
      cl.setrefdir(1, '12h26m35.9', '-63d5m56')
      cl.setrefdir(2, '-173.35deg', '-1.10128rad')
      cl.rename('testcls.cl')  
      cl.close() # write to disk
    
  </example>
  <comments>
    This example sets the reference direction for three newly created
    components to the same value.
  </comments>
</method>

 
   <method name="setrefdirframe" type="function">
   <shortdescription>Set the reference frame for the direction</shortdescription>
   
  <keyword>setrefdirframe</keyword>
  <description>

    The setrefdirframe function sets the reference frame for the
    reference direction of the specified components (what a mouthful)!

    Currently the reference frame does not include additional
    information like when and where the observation took place. Hence
    only reference frames that are independent of this information can be
    used. This includes the common ones of 'J2000', 'B1950', and
    'Galactic'. The <link anchor="measures">measures</link> module contains a
    complete listing of all possible reference frames. The parsing of
    the reference frame string is case-insensitive.

  </description>
  <input>
    
     <param name="which" type="int">
     <description>A vector of indices specifying the components to modify.
     A vector with indices between 0 and one less than the list length, inclusively</description>
     </param>
    
     <param name="frame" type="string">
     <description>The new reference frame,
     A string like 'B1950', 'J2000' or 'galactic'</description>
     </param>
    
     <param name="log" type="bool">
     <description>Send a message to the logger</description>
     <value>true</value>
     </param> 
  </input>
  <returns type="bool"/>
  <example>
    
      cl.open('crux.cl');
      cl.setrefdirframe(0, 'B1950');
    
  </example>
  <comments>
    This example sets the reference frame for all the components in
    the list to the B1950 reference frame. You would use this example
    if you had entered the B1950 coordinates for the direction of all
    the components in the list but had forgotten that the default
    reference frame was J2000 for newly created components.
  </comments>
</method>

 
   <method name="convertrefdir" type="function">
   <shortdescription>Convert the reference direction to a new frame</shortdescription>
   
  <keyword>convertrefdir</keyword>
  <description>
    The convertrefdir function changes the specified components to use a
    new direction reference frame. Using this function will change the
    right-ascension and declination of the component(s), unlike the
    setrefdirframe which does not.

    Please see the
    <link anchor="componentmodels:componentlist.setrefdirframe.function">setrefdirframe</link>
    function for a description of what frames are allowed.

  </description>
  <input>
    
     <param name="which" type="int">
     <description>A vector of indices specifying the components to modify.
     A vector with indices between 0 and one less than the list length, inclusively</description>
     </param>
    
     <param name="frame" type="string">
     <description>The new reference frame
     A string like 'B1950', 'J2000' or 'galactic'</description>
     </param>
  </input>
  <returns type="bool"/>
  <example>
    
      cl.open('crux.cl');
      cl.convertrefdirframe(0, 'J2000');
    
  </example>
  <comments>
    This example illustrates what you would do if you had a list where
    all the directions were in the B1950 reference frame but you
    needed the coordinates in the J2000 reference frame. Unlike the
    <link anchor="componentmodels:componentlist.setrefdirframe.function">setrefdirframe</link>
    function this one adjusts the right ascension and declination values.
  </comments>
</method>

 
   <method name="shapetype" type="function">
   <shortdescription>Returns the shape type of the component</shortdescription>
   
  <keyword>shapetype</keyword>
  <description>
    The shapetype function returns the current shape of the specified
    component. The shape defines how the flux of the component varies
    with direction on the sky. Currently there are three shapes
    available. These are 'Point', 'Gaussian', and 'Disk'. This
    function returns one of these four strings.

  </description>
  <input>
    
     <param name="which" type="int">
     <description>An index specifying which component.
     An integer between 0 and one less than the list length, inclusively</description>
     </param>
  </input>
  <returns type="string"><description>A string specifying the current component shape</description></returns>
  <example>
    
      cl.open('crux.cl')
      print 'The first component has a', cl.shapetype(0), ' shape'
    
  </example>
  <comments>
    This example prints the following:
      The first component has a Point  shape
  </comments>
</method>

 
   <method name="getshape" type="function">
   <shortdescription>Return the shape parameters the component</shortdescription>
   
  <keyword>getshape</keyword>
  <description>

    The getshape function returns the shape parameters of a component
    in a record. As different shapes can have a differing number and
    type of parameters the shape parameters are returned in a record
    with fields that correspond to parameters relevant to the current
    shape.

    For a point shape there are only two fields; type and
    direction. These are the shape type, and the reference
    direction. These values are also returned by the
    <link anchor="componentmodels:componentlist.shapetype.function">shapetype</link> and
    <link anchor="componentmodels:componentlist.getrefdir.function">getrefdir</link>
    functions.

    For both the Gaussian and disk shapes there are three additional
    fields; majoraxis, minoraxis, positionangle. These are angular
    <link anchor="quanta">quantities</link>, and hence are records with a value
    and a unit. 

  </description>
  <input>
    
     <param name="which" type="int">
     <description>An index specifying which component.
     An integer between 0 and one less than the list length, inclusively</description>
     </param>
  </input>
  <returns type="record">
	  <description>A record with fields that contain the parameters of the
		  component shape.
  </description>
</returns>
  <example>
    See the examples for the
    <link anchor="componentmodels:componentlist.setshape.function">setshape</link> and
    <link anchor="componentmodels:componentlist.convertshape.function">convertshape</link>
    functions.  
  </example>
</method>

 
   <method name="setshape" type="function">
   <shortdescription>Change the shape of the component</shortdescription>
   
  <keyword>setshape</keyword>
  <description>
    The setshape function changes the shape of the specified components
    to the user specified shape.

    The type argument defines what the sort of new shape to use. This
    can be either 'point', 'Gaussian', or 'disk'. 
    The parsing of this string is case insensitive. 
    

    If the shape type is 'point' then the remaining arguments in this
    function are ignored. There are no other parameters needed to
    specify a point shape. 

    But if the shape is 'Gaussian', or 'disk', 
    the remaining arguments are needed to fully specify the shape. 
    The majoraxis, minoraxis and positionangle arguments are quantities (see the
    <link anchor="quanta">quanta</link> module for a definition of a
    quantity). Hence they can be specified either as with string eg.,
    '1arcsec' or with a record eg., [value=1, unit='deg'].

    The major axis is the width of the larger axis. For the Gaussian
    shape this is the full width at half maximum. And the minor axis
    is the width of the orthogonal axis. The positionangle is the
    specifies the rotation of these two axes with respect to a line
    connecting the poles of the current direction reference frame. If
    the angle is positive the the north point of the component moves
    in the eastern direction.

  </description>
  <input>
    
     <param name="which" type="int">
     <description>A vector of indices specifying the components to modify.
     A vector with indices between 0 and one less than the list length, inclusively</description>
     </param>
    
     <param name="type" type="string">
     <description>The new shape type.
     A string that is either 'point', 'Gaussian', or 'disk'</description>
     <value>disk</value>
     <value>Gaussian</value>
     <value>Point</value>
     </param>
    
     <param name="majoraxis" type="any">
     <description>The width of the larger axis.
     A quantity with angular units</description>
     <value>1.0arcmin</value>
     </param>
    
     <param name="minoraxis" type="any">
	     <description>The width of the smaller axis.
     A quantity with angular units</description>
     <value>1.0arcmin</value>
     </param>
    
     <param name="positionangle" type="any">
     <description>The rotation of the axes with respect to
                             the reference frame.
     A quantity with angular units</description>
     <value>0.0deg</value>
     </param>
    
     <param name="majoraxiserror" type="any">
     <description>Error of width of the larger axis.
     A quantity with angular units</description>
     <value>0.0arcmin</value>
     </param>
    
     <param name="minoraxiserror" type="any">
	     <description>Error of the width of the smaller axis.
     A quantity with angular units</description>
     <value>0.0arcmin</value>
     </param>
    
     <param name="positionangleerror" type="any">
     <description>Error of the rotation of the axes with respect to
                             the reference frame.
     A quantity with angular units</description>
     <value>0.0deg</value>
     </param>
    
     <param name="optionalparms" type="doubleVec">
     <description>optional parameters in a vector (for future use)
     </description>
     <value><value>0.0</value></value>
     </param>

     <param name="log" type="bool">
     <description>Send a message to the logger</description>
     <value>true</value>
     </param> 
  </input>
  <returns type="bool"/>
  <example>
    
      cl.open('crux.cl', nomodify=False)
      cl.setshape(3, 'disk',  '45mas', '45mas')
      print cl.getshape(3)['majoraxis']
    
  </example>
  <comments>
    This example revises the model for Gamma-Crux changing its shape
    from a point to a circular disk of diameter 45mas. The output from 
    the print statement is &quot;[value=45, unit=mas]&quot;.
  </comments>
</method>

 
   <method name="convertshape" type="function">
   <shortdescription>Change the units of the shape parameters (Not implemented yet)</shortdescription>
   
  <keyword>convertshape</keyword>
  <description>

  </description>
  <input>
    
     <param name="which" type="int">
     <description>A vector of indices specifying the components to modify.
     A vector with indices between 0 and one less than the list length, inclusively</description>
     </param>
    
     <param name="majoraxis" type="string">
     <description>The units to use on the larger axis.
     A string with angular units</description>
     <value>rad</value>
     <value>deg</value>
     <value>mas</value>
     <value>arcsec</value>
     <value>arcmin</value>
     </param>
    
     <param name="minoraxis" type="string">
	     <description>The units to use on the smaller axis.
     A string with angular units</description>
     <value>rad</value>
     <value>deg</value>
     <value>mas</value>
     <value>arcsec</value>
     <value>arcmin</value>
     </param>
    
     <param name="positionangle" type="string">
     <description>The units to use for the rotation of
                             these axes.
     A string with angular units</description>
     <value>rad</value>
     <value>deg</value>
     </param>
  </input>
  <returns type="bool"/>

</method>

 
   <method name="spectrumtype" type="function">
   <shortdescription>Returns the spectral shape of the component</shortdescription>
   
  <keyword>spectrumtype</keyword>
  <description>
    The spectrumtype function returns the current spectral shape of the
    specified component. The spectral shape defines how the flux of
    the component varies with frequency. Returns one of "Constant",
    "Spectral Index", "Tabular Spectrum", and "Power Logarithmic Polynomial".

  </description>
  <input>
    
     <param name="which" type="int">
     <description>An index specifying which component.
     An integer between 0 and one less than the list length, inclusively</description>
     </param>
  </input>
  <returns type="string">
	  <description>A string specifying the spectral shape of the specified component</description></returns>
  <example>
    
      cl.open('crux.cl')
      print 'The first component has a', cl.spectrumtype(1), ' spectrum'
    
  </example>
  <comments>
    This example prints the following:
      The first component has a Constant  spectrum
  </comments>
</method>

 
   <method name="getspectrum" type="function">
   <shortdescription>Return the spectral parameters the component</shortdescription>
   
  <keyword>getshape</keyword>
  <description>

    The getspectrum function returns the spectral parameters of a
    component in a record. As different spectral shapes can have a
    differing number and type of parameters the spectral parameters
    are returned in a record with fields that correspond to parameters
    relevant to the current spectral shape.

    For a constant spectrum there are only two fields; type and
    frequency. These are the spectral type, and the reference
    frequency. These values are also returned by the
    <link anchor="componentmodels:componentlist.spectrumtype.function">spectrumtype</link> and
    <link anchor="componentmodels:componentlist.getfreq.function">getfreq</link>
    functions.

    For the spectral index spectral shape there is also an index
    field.  This contains a vector with four numbers, these are the
    spectral indicies for the I,Q,U,V components of the flux.

    The dictionary associated with a power log polynomial spectrum has the following structure:

    {
      'coeffs': array([ 1.,  2.,  3.]),
      'frequency': {
        'type': 'frequency', 
        'm0': {'value': 1.4200000000000002, 'unit': 'GHz'}, 
        'refer': 'LSRK'
      },
      'type': 'Power Logarithmic Polynomial',
      'error': array([ 0.,  0.,  0.])
    }

    The 'error' value is currently not used.


  </description>
  <input>
    
     <param name="which" type="int">
     <description>An index specifying which component.
     An integer between 0 and one less than the list length, inclusively</description>
     </param>
  </input>
  <returns type="record">
	  <description>A record with fields that contain the parameters of the
             spectral type.
	     </description></returns>
  <example>
    See the examples for the
    <link anchor="componentmodels:componentlist.setspectrum.function">setspectrum</link> and
    <link anchor="componentmodels:componentlist.getspectrum.function">getspectrum</link>
    functions.  
  </example>
</method>

 
 <method name="setstokesspectrum" type="function">
   <shortdescription>Change the spectrum of the component</shortdescription>
   
  <keyword>setstokesspectrum</keyword>
  <description>
    The setstokesspectrum function changes the spectrum of the specified components
    to the user specified spectrum. This is different from <link anchor="componentmodels:componentlist.setspectrum.function">setspectrum</link> as it provides ways to control variation of all 4 Stokes parameters with frequency. If only I variation is needed please use <link anchor="componentmodels:componentlist.setspectrum.function">setspectrum</link>

    The type argument defines what the sort of new spectrum to use. This
    can be either 'constant' or 'spectral index' or 'tabular'. The parsing of this
    string is case insensitive.

    If the spectrum type is 'constant' then the remaining arguments in
    this function are ignored. There are no other parameters needed to
    specify a constant spectrum.

    But if the spectrum is 'spectral index', the 'index' argument is
    needed. It is a 4 element vector. 
 
   The first element ($\alpha_0$) is the spectral index of stokes I ($ I(\nu)=I(\nu_0)({{\nu}\over{\nu_0}})^{\alpha_0} $)

    The second element ($\alpha_1$) is a spectral index for the fractional linear polarization ( $\sqrt{{{(Q(\nu)^2+U(\nu)^2)}\over{I(\nu)^2}}} =   \sqrt{{{(Q(\nu_0)^2+U(\nu_0)^2)}\over{I(\nu_0)^2}}}({{\nu}\over{\nu_0}})^{\alpha_1}$). $\alpha_1=0$ implies constant fractional linear polarization w.r.t frequency.
 
    The third element is a &quot;Rotation Measure&quot; factor, i.e angle of rotation $\theta= \alpha_2 (\lambda^2 - \lambda_0^2)$ of the linear polarization at frequency $\nu$ w.r.t  frequency $\nu_0$.   

    The fourth element  is a spectral index for the fractional spectral polarization ( $ {{V(\nu)}\over{I(\nu)}} =   {{V(\nu_0)}\over{I(\nu_0)}}({{\nu}\over{\nu_0}})^{\alpha_3}$

    If the spectrum is 'tabular', then {\tt index} is ignored but the six parameters 
    {\tt tabularfreqs, tabulari, tabularq, tabularu, tabularv and tabularframe} are considered. {\tt tabularfreqs} and {\tt tabulari, tabularq, tabularu, tabularv} have to be list of same lengths and larger than 2. You need at least 2 samples to interpolate the spectral value in between. 
    The Stokes parameters  of the source is interpolated from these values. Extrappolation outside the range given in {\tt tabularfreqs} is not done.
    {\tt tabularfreqs} should be float values in 'Hz'
    {\tt tabulari, tabularq, tabularu, tabularv} should be float values in 'Jy'


    You should ensure that the reference
    frequency is set to the value you desire, using the
    <link anchor="componentmodels:componentlist.setfreq.function">setfreq</link>
    function if you change to the spectral index shape.

  </description>
  <input>
    
     <param name="which" type="int">
     <description>The index specifying the component to modify.
     A value between 0 and one less than the list length, inclusively</description>
     </param>
    
     <param name="type" type="string">
     <description>The new spectrum type.
     A string that is either 'constant or 'spectral index' or 'tabular'</description>
     <value>spectral index</value>
     <allowed kind="enum">
       <value>spectral index</value>
       <value>constant</value>
       <value>tabular</value>
     </allowed>
     </param>
     
     <param name="index" type="doubleVec"> 
     <description>The spectral index.</description>
     A 4-element vector of real numbers 
     <value type="vector"><value>0.0</value></value>
     </param>

     <param name="tabularfreqs" type="doubleVec">
       <description>The frequencies of for the tabular values, in Hz</description>
       <value type="vector">
	 <value>1.0e11</value>
       </value>
     </param>

     <param name="tabulari" type="doubleVec">
       <description> tabular Stokes I  values, in Jy (same length as tabularfreqs)</description>
       <value type="vector">
	 <value>1.0</value>
       </value>
     </param>
     <param name="tabularq" type="doubleVec">
       <description> tabular Stokes Q values, in Jy (same length as tabularfreqs)</description>
       <value type="vector">
	 <value>0.0</value>
       </value>
     </param>
     <param name="tabularu" type="doubleVec">
       <description> tabular Stokes U values, in Jy (same length as tabularfreqs)</description>
       <value type="vector">
	 <value>0.0</value>
       </value>
     </param>
     <param name="tabularv" type="doubleVec">
       <description> tabular Stokes V values, in Jy (same length as tabularfreqs)</description>
       <value type="vector">
	 <value>0.0</value>
       </value>
     </param>
     
    <param name="reffreq" type="any">
     <description> The reference frequency  for spectral index
     </description>
     <value>1.4GHz</value>
     </param>

     <param name="frame" type="string">
       <description> The frame for which the frequencies given are in</description>
       <value>LSRK</value>
     </param>
  </input>
  <returns type="bool"/>
  <example>
    
      
     

      This example add a point source model and revises the model point source spectral variation  changing the spectral index  and setting the reference flux to be at 2GHz.
     I is assigned a spectral index of 1. fractional linear pol is assigned a spectral index of 0.4 and similarly for fraction circular pol and the linear pol angle is kept fixed with frequency.

    cl.addcomponent(shape='point', flux=[10.0, 0.4, -0.2, 0.1], dir='J2000 19h00m00 -20d00m00')
    cl.setstokesspectrum(which=0, type='spectral index', index=[1.0, 0.4, 0, 0.4], reffreq='2.0GHz')
    cl.rename('my19hcomp.cl')
    cl.done()

    

   In this example a componentlist  is created from scratch and 2 sources are added
   One whose spectral variation is defined by a spectral index and the other one as 
   tabular values. Both components have full Stokes parameters spectral variation 
   defined.

   cl.done()  ### effectively resets state of cl tool
   ###add first component
   cl.addcomponent(flux=[10, 0.5, -0.3, 0.2], dir='J2000 15h22m00 5d04m00')
   cl.setstokesspectrum(which=0, type='spectral index', index=[1.0, 0.4, 0, 0.4], reffreq='2.0GHz')
   ###adding second component; flux value is unimportant as the tabular values will 
   ###will set it
   cl.addcomponent(flux=[1.0, 0, 0, 0],dir='J2000 15h22m30 5d05m00')
   ##define the IQUV flux variation as tabular values at different frequencies.
   cl.setstokesspectrum(which=1, type='tabular', tabularfreqs=[1.0e9, 1.1e9, 1.2e9, 1.3e9, 1.4e9, 1.5e9, 1.6e9], tabulari=[10.0, 10.1, 10.2, 10.2, 10.25, 10.3, 1.4], tabularq=[0.2, 0.2, 0.22, 0.23, 0.22, 0.24, 0.25], tabularu=[-0.1, -0.12, -0.13, -0.13, -0.12, -0.14, -0.15], tabularv=[0.1, 0.2, 0.2, 0.2, 0.3, 0.1, 0.15])
   ###saving the componentlist to disk
   cl.rename('two_comp.cl')
   cl.done()  ###done is needed to sync to disk

   

  </example>
</method>


   <method name="setspectrum" type="function">
   <shortdescription>Change the spectrum of the component</shortdescription>
   
  <keyword>setspectrum</keyword>
  <description>
    The setspectrum function changes the spectrum of the specified components
    to the user specified spectrum.

    The type argument defines what the sort of new spectrum to use. This
    can be one of 'constant', 'tabular', 'plp', or 'spectral index'. Minimal
    match, case insensitive.

    If the spectrum type is 'constant' then the remaining arguments in
    this function are ignored. There are no other parameters needed to
    specify a constant spectrum. The reference frequency is set to be
    the same value as the component being replaced. Although this is
    unimportant for a constant spectrum, it may be important if
    the spectral model of the component in question is changed again
    later. See rules to how the reference frequencies of various spectral
    models are set in the description below.

    If the spectrum is 'spectral index', the 'index' argument is
    needed to fully specify the spectrum by using the index argument. The
    index parameter may be in the form of a single numerical value, or
    an array containing a numerical value. In the case of the array containing
    multiple values, the zeroth value is used as the value of index, while
    subsequent values are tacitly ignored. The functional form of this model
    is 

    R = x^(alpha)

    where R = I_nu/I_nu0 is the ratio of the intensities at observed frequency nu
    and the reference frequency nu_0, x = nu/nu_0, and alpha is the specified
    spectral index. The reference frequency is tacitly set to that of the component
    being replaced. and can be changed by a subsequent call to setfreq().
 
    If spectrum = 'plp', then the spectral model is set to a power log polynomial.
    The functional form of this model is

    R = x^(c_0 + c_1*(ln(x)) + c_2*(ln(x))^2 + c_3*(ln(x))^3 + ... + c_n*(ln(x))^n)

    where R = I_nu/I_nu0 is the ratio of the intensities at observed frequency nu
    and the reference frequency nu_0, x = nu/nu_0, ln is the natural logarithm, and
    c_0 ... c_n are the coefficients specified by index. In this case, index should
    be an array of numerical values, and the array length is unconstrained. The
    reference frequency is tacitly set to that of the component being replaced, and
    can be changed by a subsequent call to setfreq().

    If the spectrum is 'tabular', then 'index' is ignored but the
    three parameters 'tabularfreqs', 'tabularflux' and 'tabularframe'
    are considered. 'tabularfreqs' and 'tabularflux' have to be list
    of same lengths and larger than 2. You need at least 2 samples to
    interpolate the spectral value in between.  The flux of the source
    is interpolated from these values. Extrapolation outside the range
    given in 'tabularfreqs' is not done.
    'tabularfreqs' should be float values in 'Hz'
    'tabularflux' should be float values in 'Jy'
    The reference frequency is chosen to be the zeroth element of tabularfreqs.
    


    You should ensure that the reference
    frequency is set to the value you desire, using the
    <link anchor="componentmodels:componentlist.setfreq.function">setfreq</link>
    function if you change to the spectral index shape.

  </description>
  <input>
    
     <param name="which" type="int">
     <description>The index specifying the component to modify.
     A value between 0 and one less than the list length, inclusively</description>
     </param>
    
     <param name="type" type="string">
     <description>The new spectrum type.
     A string that is one of 'constant', 'spectral index' 'tabular', or 'plp' (caseless, minimum match)</description>
     <value>spectral index</value>
     <allowed kind="enum">
       <value>spectral index</value>
       <value>constant</value>
       <value>tabular</value>
       <value>plp</value>
     </allowed>
     </param>
     
     <!-- <param type="doubleArray" name="index"> -->
     <param type="any" name="index" limittypes="double, doubleArray">
     <description>The spectral index or coefficients for plp.</description>
     <!-- A 4-element vector or real numbers -->
     <!-- <value type="vector"><value>1.0</value></value> -->
     <value>0.0</value>
     </param>

     <param name="tabularfreqs" type="doubleVec">
       <description>The frequencies of for the tabular values, in Hz</description>
       <value type="vector">
	 <value>1.0e11</value>
       </value>
     </param>

     <param name="tabularflux" type="doubleVec">
       <description> tabular flux density values, in Jy (same length as tabularfreqs)</description>
       <value type="vector">
	 <value>1.0</value>
       </value>
     </param>
     <param type="string" name="tabularframe">
       <description> For tabular models, the frame of the provided frequencies.</description>
       <value>LSRK</value>
     </param>
  </input>
  <returns type="bool"/>
  <example>
    
      
      cl.open('centarusA.cl')
      cl.setspectrum(2, 'spectral index', -0.5)
      print cl.getcomponent(2)['spectrum']['index']
      cl.done()

      This example revises the model for Centaurus-A changing the
      spectral index of all the components in the left lobe. The
      output from the print statement is &quot;[-0.5 0 0 0]&quot;

      cl.addcomponent(shape='point', flux=[1.0, 0.0, 0.0, 0.0], dir='J2000 19h00m00 -20d00m00')
      cl.setspectrum(which=0, type='tabular', tabularfreqs=[1.0e9, 1.1e9, 1.4e9], tabularflux=[1.0, 0.9, 0.75])
      cl.rename('my19hcomp.cl')
      cl.done()
    
      In this example a component is created from scratch as a point
      source The spectrum is set to, say, measured values at 3
      frequencies (1GHz, 1.1GHz and 1.4GHz) to 1.0Jy, 0.9Jy, 0.75Jy
      respectively.  Any frequency in between the range 1 to 1.4 GHz
      the flux will be estimated by interpolation.

      cl.open('my.cl')
      cl.addcomponent(shape='point', flux=[1.0, 0.0, 0.0, 0.0], dir='J2000 19h00m00 -20d00m00')
      cl.setspectrum(which=0, type='plp', index=[1, 2, 3])
      
      In this example, the initial component's spectrum is modified to a power log polynomial
      with the specified indices.

  </example>
</method>

 
<method name="getfreq" type="function">
   <shortdescription>Get the reference frequency (Not implemented yet)</shortdescription>
   
  <keyword>getfreq</keyword>
  <description>

  </description>
  <input>
    
     <param name="which" type="int">
     <description>An index specifying which component.
     An integer between 0 and one less than the list length, inclusively</description>
     </param>
  </input>
  <returns type="record"><description>A frequency measure (a record)</description></returns>

</method>

 
<method name="getfreqvalue" type="function">
   <shortdescription>Get the reference frequency value (Not implemeted yet)</shortdescription>
   
  <keyword>getfreqvalue</keyword>
  <description>

  </description>
  <input>
    
    <param name="which" type="int">
     <description>An index specifying which component.
     An integer between 0 and one less than the list length, inclusively</description>
     </param>
  </input>
  <returns type="double"><description>A number containing the value of the reference frequency.</description></returns>

</method>

 
<method name="getfrequnit" type="function">
   <shortdescription>Get the reference frequency unit (Not implemeted yet)</shortdescription>
   
  <keyword>getfrequnit</keyword>
  <description>

  </description>
  <input>
    
     <param name="which" type="int">
     <description>An index specifying which component.
     An integer between 0 and one less than the list length, inclusively</description>
     </param>
  </input>
  <returns type="string"><description>A string containing the unit of the reference frequency.</description></returns>
  <example>
    See the example for the
    <link anchor="componentmodels:componentlist.getfreqvalue.function">getfreqvalue</link> function.
  </example>
</method>

 
<method name="getfreqframe" type="function">
   <shortdescription>Get the reference frequency frame (Not implemeted yet)</shortdescription>
   
  <keyword>getfreqframe</keyword>
  <description>


  </description>
  <input>
    
     <param name="which" type="int">
     <description>An index specifying which component.
     An integer between 0 and one less than the list length, inclusively</description>
     </param>
  </input>
  <returns type="string"><description>A string containing the reference frame
		  of the reference frequency.</description></returns>
  <example>
    See the example for the
    <link anchor="componentmodels:componentlist.getfreqvalue.function">getfreqvalue</link> function.
  </example>
</method>

 
<method name="setfreq" type="function">
   <shortdescription>Set the reference frequency</shortdescription>
   
  <keyword>setfreq</keyword>
  <description>

    The setfreq function sets the reference frequency of the specified
    components to a new value. The frequency is defined by separately
    specifying the value and its units. Use the
    <link anchor="componentmodels:componentlist.setfreqframe.function">setfreqframe</link>
    function to set the frequency reference frame

  </description>
  <input>
    
     <param name="which" type="int">
     <description>An index specifying the component to modify
     An integer between 0 and one less than the list length, inclusively</description>
     <choice>no default</choice>
     </param>
    
     <param name="value" type="double">
     <description>The new frequency value.
     A number</description>
     </param>
    
     <param name="unit" type="string">
     <description>The units of the frequency.
     Any string with the same dimensions as the 'Hz'</description>
     <value>GHz</value>
     </param>
    
     <param name="log" type="bool">
     <description>Send a message to the logger</description>
     <value>true</value>
     </param> 
  </input>
  <returns type="bool"/>
  <example>
    
      cl.open('centarusA.cl')
      cl.setfreq(1, 1.415, 'GHz')
    
  </example>
  <comments>
    This example sets the reference frequency of the first component
    to 1.415 GHz. If the spectral type is 'spectral index' and the
    indicies are non-zero then this will change the flux of the
    component at all frequencies.
  </comments>
</method>

 
<method name="setfreqframe" type="function">
   <shortdescription>Set the reference frame for the frequency</shortdescription>
   
  <keyword>setfreqframe</keyword>
  <description>

    The setfreqframe function sets the reference frame for the
    reference frequency of the specified components.

    Currently the reference frame does not include additional
    information like when are where the observation took place. Hence
    no conversion between reference frames is available. In the
    interim I recommend you always use the same frame.

  </description>
  <input>
    
     <param name="which" type="int">
     <description>An index specifying the component to modify.
     An integer between 0 and one less than the list length, inclusively</description>
     </param>
    
     <param name="frame" type="string">
     <description>The new reference frame,
     A string like 'LSRK', 'LSRD', 'GEO' or 'TOPO</description>
     <value>TOPO</value>
     <value>GEO</value>
     <value>LSRD</value>
     <value>LSRK</value>
     </param>
    
     <param name="log" type="bool">
     <description>Send a message to the logger</description>
     <value>true</value>
     </param> 
  </input>
  <returns type="bool"/>
  <example>
    
      cl.open('centarusA.cl')
      cl.setfreqframe(0, 'LSRK')
    
  </example>
  <comments>
    This example sets the reference frequency frame for the first
    component to LSR (local standard of rest). 
  </comments>
</method>

<method name="convertfrequnit" type="function">
  <shortdescription>Convert the reference frequency to a new unit</shortdescription>
   
  <keyword>convertfrequnit</keyword>
  <description>

    The convertfrequnit function changes the specified components to use
    a new unit for the reference frequency. Using this function will
    change the frequency value also so that the overall reference
    frequency is not changed. It will affect the values and units
    obtained with
    <link anchor="componentmodels:componentlist.setfreq.function">setfreqvalue</link>
    function.

    Any unit can be used that has the same dimensions as the 'Hz'.

  </description>
  <input>
    
     <param name="which" type="int">
     <description>An index specifying the component to modify.
     An integer between 0 and one less than the list length, inclusively</description>
     </param>
    
     <param name="unit" type="string">
     <description>The new frequency unit.
     Any string with the same dimensions as the 'Hz'</description>
     <value>GHz</value>
     </param>
  </input>
  <returns type="bool"/>
  <example>
    
      cl.open('centarusA.cl');
      cl.convertfrequnit(1, 'kHz');
      
    
  </example>
  <comments>
    This example prints, when used in conjunction with example from
    the <link anchor="componentmodels:componentlist.setfreq.function">setfreq</link> function
    the following:
      The reference frequency is  1.415e+06   kHz ( LSR )    
  </comments>
</method>

<method name="getcomponent" type="function">
   <shortdescription>Extract a component from the list.</shortdescription>
   
  <keyword>component</keyword>
  <description>

    The component function returns a record, showing the current state
    of the specified component in the list.

    Modifying the record that is returned by this function does not
    modify the component in the list. To do this you must remove the
    component from the list, using the
    <link anchor="componentmodels:componentlist.remove.function">remove</link> function,
    and add the modified component using the
    <link anchor="componentmodels:componentlist.add.function">add</link> function, or use
    the <link anchor="componentmodels:componentlist.replace.function">replace</link> object
    function.  This function will be removed in a future release of
    and you are urged to use the get functions to extract
    information about a component.

  </description>
  <input>
    
     <param name="which" type="int">
     <description>index of which component to extract.
     integers between 0 and one less than the length of the list, inclusively</description>
     </param>
    
     <param name="iknow" type="bool">
     <description>Suppress the warning message</description>
     <value>false</value>
     </param>
  </input>
  <returns type="record"><description>A record representing a component.</description></returns>
</method>

 
   <method name="add" type="function">
   <shortdescription>Add a component to the list.</shortdescription>
   
  <keyword>add</keyword>
  <description>
    The add function adds a component to the component
    list. You cannot add components to a list that has been opened
    read only. To use this function you need to know the details of
    the record format. however this has been deprecated and you are
    urged to use the set functions, in conjunction with the simulate
    function to add a component to the list.
    
  </description>
  <input>
    
     <param name="thecomponent" type="record">
     <description>A record that represents a component.
     any record that contains the required fields</description>
     </param>
    
     <param name="iknow" type="bool">
     <description>Suppress the warning message</description>
     <value>true</value>
     </param>
  </input>
  <returns type="bool"/>
</method>

 
   <method name="replace" type="function">
   <shortdescription>Replace components in the list. {\bf (Not implemented yet) }</shortdescription>
   
  <keyword>replace</keyword>
  <description>

    The replace function replaces the components from the list with
    the specified components from another list. The source list can be
    opened readonly and the length of the vectors in the first and
    third arguments must the the name.

    You cannot replace components in a list that has been opened read
    only.

  </description>
  <input>
    
     <param name="which" type="int">
     <description>A vector of indices specifying the components to replace.
     A vector with indices between 0 and one less than the list length, inclusively</description>
     </param>
    
     <param name="list" type="record">
     <description>The list containing the components to copy.
     A componentlist tool</description>
     </param>
    
     <param name="whichones" type="intVec">
     <description>A vector of indices specifying the components to copy
     A vector with indices between 1 and the length of the 
list in the second argument</description>
     <value><value>-1</value></value>
     </param>
  </input>
  <returns type="bool"/>
</method>

<method name="summarize" type="function">
   <shortdescription>Summarize the specified component to the logger</shortdescription>
   
  <keyword>summarize</keyword>

  <description>
     The summarize function summarizes the contents of the specified components to the logger.
  </description>
  <input>
    
     <param name="which" type="int">
     <description>An index specifying which component.
     Unset or an integer between 0 and one less than the list length, inclusive</description>
     <value>-1</value>
     </param>
  </input>
  <returns type="bool"/>
</method>


<method type="function" name="iscomponentlist">
   <shortdescription>Is the argument a componentlist tool? (Not implemented yet)</shortdescription>
   
  <keyword>is_componentlist</keyword>
  <description>
    This global function can be used to determine if the supplied
    argument is a componentlist tool. If so it returns True, otherwise 
    it returns False.
  </description>
  <input>
    
     <param name="tool" type="any">
     <description>The variable that you wish to test</description>
     </param>
  </input>

  <returns type="bool"><description>T or F, indicating if the argument is a componentlist tool or not.</description></returns>

</method>
</tool>


</casaxml>
