##################### generated by xml-casa (v2) from agentflagger.xml ##############
##################### 4b7be1d48b1bb20557804b5d31ee6f39 ##############################
from __future__ import absolute_import 
from .__casac__ import agentflagger as _agentflagger
from .platform import str_encode as _str_ec
from .platform import str_decode as _str_dc
from .platform import dict_encode as _dict_ec
from .platform import dict_decode as _dict_dc
from .platform import dict_encode as _quant_ec
from .platform import dict_decode as _quant_dc
from .platform import encode as _any_ec
from .platform import decode as _any_dc
from .typecheck import validator as _pc
from .coercetype import coerce as _coerce


class agentflagger:
    ### self
    def __init__(self, *args, **kwargs):
        """Create a {tt agentflagger} tool, and initialize some variables.
        """
        self._swigobj = kwargs.get('swig_object',None)
        if self._swigobj is None:
            self._swigobj = _agentflagger()

    def done(self):
        """
        """
        _done_result = self._swigobj.done()
        return _done_result

    def open(self, msname='', ntime=float(0.0)):
        """
        """
        schema = {'msname': {'type': 'cStr'}, 'ntime': {'type': 'cFloat', 'coerce': _coerce.to_float}}
        doc = {'msname': msname, 'ntime': ntime}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _open_result = self._swigobj.open(_str_ec(_pc.document['msname']), _pc.document['ntime'])
        return _open_result

    def selectdata(self, config={ }, field='', spw='', array='', feed='', scan='', antenna='', uvrange='', timerange='', correlation='', intent='', observation=''):
        """
        """
        schema = {'config': {'type': 'cDict'}, 'field': {'type': 'cStr'}, 'spw': {'type': 'cStr'}, 'array': {'type': 'cStr'}, 'feed': {'type': 'cStr'}, 'scan': {'type': 'cStr'}, 'antenna': {'type': 'cStr'}, 'uvrange': {'type': 'cStr'}, 'timerange': {'type': 'cStr'}, 'correlation': {'type': 'cStr'}, 'intent': {'type': 'cStr'}, 'observation': {'type': 'cStr'}}
        doc = {'config': config, 'field': field, 'spw': spw, 'array': array, 'feed': feed, 'scan': scan, 'antenna': antenna, 'uvrange': uvrange, 'timerange': timerange, 'correlation': correlation, 'intent': intent, 'observation': observation}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _selectdata_result = self._swigobj.selectdata(_dict_ec(_pc.document['config']), _str_ec(_pc.document['field']), _str_ec(_pc.document['spw']), _str_ec(_pc.document['array']), _str_ec(_pc.document['feed']), _str_ec(_pc.document['scan']), _str_ec(_pc.document['antenna']), _str_ec(_pc.document['uvrange']), _str_ec(_pc.document['timerange']), _str_ec(_pc.document['correlation']), _str_ec(_pc.document['intent']), _str_ec(_pc.document['observation']))
        return _selectdata_result

    def parseagentparameters(self, aparams):
        """The specific data selection parameters for the agent (flagging mode)
        are parsed. These parameters are the data selection and mode-specific parameters.
        See the example below:
        """
        schema = {'aparams': {'type': 'cDict'}}
        doc = {'aparams': aparams}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _parseagentparameters_result = self._swigobj.parseagentparameters(_dict_ec(_pc.document['aparams']))
        return _parseagentparameters_result

    def init(self):
        """This method will initialize the agents and create a list of agents
        with their specific parameters. It takes no parameters.
        """
        _init_result = self._swigobj.init()
        return _init_result

    def run(self, writeflags=True, sequential=True):
        """Execute a list of flagging agents and write or not to the MS/cal table. The parameter
        writeflags controls whether or not to write to the MS.
        """
        schema = {'writeflags': {'type': 'cBool'}, 'sequential': {'type': 'cBool'}}
        doc = {'writeflags': writeflags, 'sequential': sequential}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _run_result = _dict_dc(self._swigobj.run(_pc.document['writeflags'], _pc.document['sequential']))
        return _run_result

    def getflagversionlist(self, printflags=True):
        """Print out the list of flag versions in the MS, unless the parameter printflags=False. The list of names is returned.
        """
        schema = {'printflags': {'type': 'cBool'}}
        doc = {'printflags': printflags}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _getflagversionlist_result = [_str_dc(_x) for _x in self._swigobj.getflagversionlist(_pc.document['printflags'])]
        return _getflagversionlist_result

    def printflagselection(self):
        """Print out a list of current flag selections.
        """
        _printflagselection_result = self._swigobj.printflagselection()
        return _printflagselection_result

    def saveflagversion(self, versionname='', comment='', merge=''):
        """
        """
        schema = {'versionname': {'type': 'cStr'}, 'comment': {'type': 'cStr'}, 'merge': {'type': 'cStr'}}
        doc = {'versionname': versionname, 'comment': comment, 'merge': merge}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _saveflagversion_result = self._swigobj.saveflagversion(_str_ec(_pc.document['versionname']), _str_ec(_pc.document['comment']), _str_ec(_pc.document['merge']))
        return _saveflagversion_result

    def restoreflagversion(self, versionname=[  ], merge=''):
        """
        """
        schema = {'versionname': {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}, 'merge': {'type': 'cStr'}}
        doc = {'versionname': versionname, 'merge': merge}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _restoreflagversion_result = self._swigobj.restoreflagversion([_str_ec(_x) for _x in _pc.document['versionname']], _str_ec(_pc.document['merge']))
        return _restoreflagversion_result

    def deleteflagversion(self, versionname=[  ]):
        """
        """
        schema = {'versionname': {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}}
        doc = {'versionname': versionname}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _deleteflagversion_result = self._swigobj.deleteflagversion([_str_ec(_x) for _x in _pc.document['versionname']])
        return _deleteflagversion_result

    def parsemanualparameters(self, field='', spw='', array='', feed='', scan='', antenna='', uvrange='', time='', correlation='', intent='', observation='', autocorr=False, apply=True):
        """
        """
        schema = {'field': {'type': 'cStr'}, 'spw': {'type': 'cStr'}, 'array': {'type': 'cStr'}, 'feed': {'type': 'cStr'}, 'scan': {'type': 'cStr'}, 'antenna': {'type': 'cStr'}, 'uvrange': {'type': 'cStr'}, 'time': {'type': 'cStr'}, 'correlation': {'type': 'cStr'}, 'intent': {'type': 'cStr'}, 'observation': {'type': 'cStr'}, 'autocorr': {'type': 'cBool'}, 'apply': {'type': 'cBool'}}
        doc = {'field': field, 'spw': spw, 'array': array, 'feed': feed, 'scan': scan, 'antenna': antenna, 'uvrange': uvrange, 'time': time, 'correlation': correlation, 'intent': intent, 'observation': observation, 'autocorr': autocorr, 'apply': apply}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _parsemanualparameters_result = self._swigobj.parsemanualparameters(_str_ec(_pc.document['field']), _str_ec(_pc.document['spw']), _str_ec(_pc.document['array']), _str_ec(_pc.document['feed']), _str_ec(_pc.document['scan']), _str_ec(_pc.document['antenna']), _str_ec(_pc.document['uvrange']), _str_ec(_pc.document['time']), _str_ec(_pc.document['correlation']), _str_ec(_pc.document['intent']), _str_ec(_pc.document['observation']), _pc.document['autocorr'], _pc.document['apply'])
        return _parsemanualparameters_result

    def parseclipparameters(self, field='', spw='', array='', feed='', scan='', antenna='', uvrange='', time='', correlation='', intent='', observation='', datacolumn='DATA', clipminmax=[  ], clipoutside=True, channelavg=False, chanbin=int(1), timeavg=False, timebin='', clipzeros=False, apply=True):
        """
        """
        schema = {'field': {'type': 'cStr'}, 'spw': {'type': 'cStr'}, 'array': {'type': 'cStr'}, 'feed': {'type': 'cStr'}, 'scan': {'type': 'cStr'}, 'antenna': {'type': 'cStr'}, 'uvrange': {'type': 'cStr'}, 'time': {'type': 'cStr'}, 'correlation': {'type': 'cStr'}, 'intent': {'type': 'cStr'}, 'observation': {'type': 'cStr'}, 'datacolumn': {'type': 'cStr'}, 'clipminmax': {'type': 'cFloatVec', 'coerce': [_coerce.to_list,_coerce.to_floatvec]}, 'clipoutside': {'type': 'cBool'}, 'channelavg': {'type': 'cBool'}, 'chanbin': {'anyof': [{'type': 'cInt'}, {'type': 'cIntVec', 'coerce': [_coerce.to_list,_coerce.to_intvec]}]}, 'timeavg': {'type': 'cBool'}, 'timebin': {'type': 'cStr'}, 'clipzeros': {'type': 'cBool'}, 'apply': {'type': 'cBool'}}
        doc = {'field': field, 'spw': spw, 'array': array, 'feed': feed, 'scan': scan, 'antenna': antenna, 'uvrange': uvrange, 'time': time, 'correlation': correlation, 'intent': intent, 'observation': observation, 'datacolumn': datacolumn, 'clipminmax': clipminmax, 'clipoutside': clipoutside, 'channelavg': channelavg, 'chanbin': chanbin, 'timeavg': timeavg, 'timebin': timebin, 'clipzeros': clipzeros, 'apply': apply}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _parseclipparameters_result = self._swigobj.parseclipparameters(_str_ec(_pc.document['field']), _str_ec(_pc.document['spw']), _str_ec(_pc.document['array']), _str_ec(_pc.document['feed']), _str_ec(_pc.document['scan']), _str_ec(_pc.document['antenna']), _str_ec(_pc.document['uvrange']), _str_ec(_pc.document['time']), _str_ec(_pc.document['correlation']), _str_ec(_pc.document['intent']), _str_ec(_pc.document['observation']), _str_ec(_pc.document['datacolumn']), _pc.document['clipminmax'], _pc.document['clipoutside'], _pc.document['channelavg'], _any_ec(_pc.document['chanbin']), _pc.document['timeavg'], _str_ec(_pc.document['timebin']), _pc.document['clipzeros'], _pc.document['apply'])
        return _parseclipparameters_result

    def parsequackparameters(self, field='', spw='', array='', feed='', scan='', antenna='', uvrange='', time='', correlation='', intent='', observation='', quackmode='beg', quackinterval=float(0.0), quackincrement=False, apply=True):
        """
        """
        schema = {'field': {'type': 'cStr'}, 'spw': {'type': 'cStr'}, 'array': {'type': 'cStr'}, 'feed': {'type': 'cStr'}, 'scan': {'type': 'cStr'}, 'antenna': {'type': 'cStr'}, 'uvrange': {'type': 'cStr'}, 'time': {'type': 'cStr'}, 'correlation': {'type': 'cStr'}, 'intent': {'type': 'cStr'}, 'observation': {'type': 'cStr'}, 'quackmode': {'type': 'cStr'}, 'quackinterval': {'type': 'cFloat', 'coerce': _coerce.to_float}, 'quackincrement': {'type': 'cBool'}, 'apply': {'type': 'cBool'}}
        doc = {'field': field, 'spw': spw, 'array': array, 'feed': feed, 'scan': scan, 'antenna': antenna, 'uvrange': uvrange, 'time': time, 'correlation': correlation, 'intent': intent, 'observation': observation, 'quackmode': quackmode, 'quackinterval': quackinterval, 'quackincrement': quackincrement, 'apply': apply}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _parsequackparameters_result = self._swigobj.parsequackparameters(_str_ec(_pc.document['field']), _str_ec(_pc.document['spw']), _str_ec(_pc.document['array']), _str_ec(_pc.document['feed']), _str_ec(_pc.document['scan']), _str_ec(_pc.document['antenna']), _str_ec(_pc.document['uvrange']), _str_ec(_pc.document['time']), _str_ec(_pc.document['correlation']), _str_ec(_pc.document['intent']), _str_ec(_pc.document['observation']), _str_ec(_pc.document['quackmode']), _pc.document['quackinterval'], _pc.document['quackincrement'], _pc.document['apply'])
        return _parsequackparameters_result

    def parseelevationparameters(self, field='', spw='', array='', feed='', scan='', antenna='', uvrange='', time='', correlation='', intent='', observation='', lowerlimit=float(0.0), upperlimit=float(90.0), apply=True):
        """
        """
        schema = {'field': {'type': 'cStr'}, 'spw': {'type': 'cStr'}, 'array': {'type': 'cStr'}, 'feed': {'type': 'cStr'}, 'scan': {'type': 'cStr'}, 'antenna': {'type': 'cStr'}, 'uvrange': {'type': 'cStr'}, 'time': {'type': 'cStr'}, 'correlation': {'type': 'cStr'}, 'intent': {'type': 'cStr'}, 'observation': {'type': 'cStr'}, 'lowerlimit': {'type': 'cFloat', 'coerce': _coerce.to_float}, 'upperlimit': {'type': 'cFloat', 'coerce': _coerce.to_float}, 'apply': {'type': 'cBool'}}
        doc = {'field': field, 'spw': spw, 'array': array, 'feed': feed, 'scan': scan, 'antenna': antenna, 'uvrange': uvrange, 'time': time, 'correlation': correlation, 'intent': intent, 'observation': observation, 'lowerlimit': lowerlimit, 'upperlimit': upperlimit, 'apply': apply}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _parseelevationparameters_result = self._swigobj.parseelevationparameters(_str_ec(_pc.document['field']), _str_ec(_pc.document['spw']), _str_ec(_pc.document['array']), _str_ec(_pc.document['feed']), _str_ec(_pc.document['scan']), _str_ec(_pc.document['antenna']), _str_ec(_pc.document['uvrange']), _str_ec(_pc.document['time']), _str_ec(_pc.document['correlation']), _str_ec(_pc.document['intent']), _str_ec(_pc.document['observation']), _pc.document['lowerlimit'], _pc.document['upperlimit'], _pc.document['apply'])
        return _parseelevationparameters_result

    def parsetfcropparameters(self, field='', spw='', array='', feed='', scan='', antenna='', uvrange='', time='', correlation='', intent='', observation='', ntime=float(0.0), combinescans=False, datacolumn='DATA', timecutoff=float(4.0), freqcutoff=float(3.0), timefit='line', freqfit='poly', maxnpieces=int(7), flagdimension='freqtime', usewindowstats='none', halfwin=int(1), extendflags=True, apply=True, channelavg=False, chanbin=int(1), timeavg=False, timebin=''):
        """
        """
        schema = {'field': {'type': 'cStr'}, 'spw': {'type': 'cStr'}, 'array': {'type': 'cStr'}, 'feed': {'type': 'cStr'}, 'scan': {'type': 'cStr'}, 'antenna': {'type': 'cStr'}, 'uvrange': {'type': 'cStr'}, 'time': {'type': 'cStr'}, 'correlation': {'type': 'cStr'}, 'intent': {'type': 'cStr'}, 'observation': {'type': 'cStr'}, 'ntime': {'type': 'cFloat', 'coerce': _coerce.to_float}, 'combinescans': {'type': 'cBool'}, 'datacolumn': {'type': 'cStr'}, 'timecutoff': {'type': 'cFloat', 'coerce': _coerce.to_float}, 'freqcutoff': {'type': 'cFloat', 'coerce': _coerce.to_float}, 'timefit': {'type': 'cStr'}, 'freqfit': {'type': 'cStr'}, 'maxnpieces': {'type': 'cInt'}, 'flagdimension': {'type': 'cStr'}, 'usewindowstats': {'type': 'cStr'}, 'halfwin': {'type': 'cInt'}, 'extendflags': {'type': 'cBool'}, 'apply': {'type': 'cBool'}, 'channelavg': {'type': 'cBool'}, 'chanbin': {'anyof': [{'type': 'cInt'}, {'type': 'cIntVec', 'coerce': [_coerce.to_list,_coerce.to_intvec]}]}, 'timeavg': {'type': 'cBool'}, 'timebin': {'type': 'cStr'}}
        doc = {'field': field, 'spw': spw, 'array': array, 'feed': feed, 'scan': scan, 'antenna': antenna, 'uvrange': uvrange, 'time': time, 'correlation': correlation, 'intent': intent, 'observation': observation, 'ntime': ntime, 'combinescans': combinescans, 'datacolumn': datacolumn, 'timecutoff': timecutoff, 'freqcutoff': freqcutoff, 'timefit': timefit, 'freqfit': freqfit, 'maxnpieces': maxnpieces, 'flagdimension': flagdimension, 'usewindowstats': usewindowstats, 'halfwin': halfwin, 'extendflags': extendflags, 'apply': apply, 'channelavg': channelavg, 'chanbin': chanbin, 'timeavg': timeavg, 'timebin': timebin}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _parsetfcropparameters_result = self._swigobj.parsetfcropparameters(_str_ec(_pc.document['field']), _str_ec(_pc.document['spw']), _str_ec(_pc.document['array']), _str_ec(_pc.document['feed']), _str_ec(_pc.document['scan']), _str_ec(_pc.document['antenna']), _str_ec(_pc.document['uvrange']), _str_ec(_pc.document['time']), _str_ec(_pc.document['correlation']), _str_ec(_pc.document['intent']), _str_ec(_pc.document['observation']), _pc.document['ntime'], _pc.document['combinescans'], _str_ec(_pc.document['datacolumn']), _pc.document['timecutoff'], _pc.document['freqcutoff'], _str_ec(_pc.document['timefit']), _str_ec(_pc.document['freqfit']), _pc.document['maxnpieces'], _str_ec(_pc.document['flagdimension']), _str_ec(_pc.document['usewindowstats']), _pc.document['halfwin'], _pc.document['extendflags'], _pc.document['apply'], _pc.document['channelavg'], _any_ec(_pc.document['chanbin']), _pc.document['timeavg'], _str_ec(_pc.document['timebin']))
        return _parsetfcropparameters_result

    def parseantintparameters(self, field='', spw='', array='', feed='', scan='', antenna='', uvrange='', time='', correlation='', intent='', observation='', antint_ref_antenna='', minchanfrac=float(0.6), verbose=False, apply=True):
        """
        """
        schema = {'field': {'type': 'cStr'}, 'spw': {'type': 'cStr'}, 'array': {'type': 'cStr'}, 'feed': {'type': 'cStr'}, 'scan': {'type': 'cStr'}, 'antenna': {'type': 'cStr'}, 'uvrange': {'type': 'cStr'}, 'time': {'type': 'cStr'}, 'correlation': {'type': 'cStr'}, 'intent': {'type': 'cStr'}, 'observation': {'type': 'cStr'}, 'antint_ref_antenna': {'type': 'cStr'}, 'minchanfrac': {'type': 'cFloat', 'coerce': _coerce.to_float}, 'verbose': {'type': 'cBool'}, 'apply': {'type': 'cBool'}}
        doc = {'field': field, 'spw': spw, 'array': array, 'feed': feed, 'scan': scan, 'antenna': antenna, 'uvrange': uvrange, 'time': time, 'correlation': correlation, 'intent': intent, 'observation': observation, 'antint_ref_antenna': antint_ref_antenna, 'minchanfrac': minchanfrac, 'verbose': verbose, 'apply': apply}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _parseantintparameters_result = self._swigobj.parseantintparameters(_str_ec(_pc.document['field']), _str_ec(_pc.document['spw']), _str_ec(_pc.document['array']), _str_ec(_pc.document['feed']), _str_ec(_pc.document['scan']), _str_ec(_pc.document['antenna']), _str_ec(_pc.document['uvrange']), _str_ec(_pc.document['time']), _str_ec(_pc.document['correlation']), _str_ec(_pc.document['intent']), _str_ec(_pc.document['observation']), _str_ec(_pc.document['antint_ref_antenna']), _pc.document['minchanfrac'], _pc.document['verbose'], _pc.document['apply'])
        return _parseantintparameters_result

    def parseextendparameters(self, field='', spw='', array='', feed='', scan='', antenna='', uvrange='', time='', correlation='', intent='', observation='', ntime=float(0.0), combinescans=False, extendpols=True, growtime=float(50.0), growfreq=float(50.0), growaround=False, flagneartime=False, flagnearfreq=False, apply=True):
        """
        """
        schema = {'field': {'type': 'cStr'}, 'spw': {'type': 'cStr'}, 'array': {'type': 'cStr'}, 'feed': {'type': 'cStr'}, 'scan': {'type': 'cStr'}, 'antenna': {'type': 'cStr'}, 'uvrange': {'type': 'cStr'}, 'time': {'type': 'cStr'}, 'correlation': {'type': 'cStr'}, 'intent': {'type': 'cStr'}, 'observation': {'type': 'cStr'}, 'ntime': {'type': 'cFloat', 'coerce': _coerce.to_float}, 'combinescans': {'type': 'cBool'}, 'extendpols': {'type': 'cBool'}, 'growtime': {'type': 'cFloat', 'coerce': _coerce.to_float}, 'growfreq': {'type': 'cFloat', 'coerce': _coerce.to_float}, 'growaround': {'type': 'cBool'}, 'flagneartime': {'type': 'cBool'}, 'flagnearfreq': {'type': 'cBool'}, 'apply': {'type': 'cBool'}}
        doc = {'field': field, 'spw': spw, 'array': array, 'feed': feed, 'scan': scan, 'antenna': antenna, 'uvrange': uvrange, 'time': time, 'correlation': correlation, 'intent': intent, 'observation': observation, 'ntime': ntime, 'combinescans': combinescans, 'extendpols': extendpols, 'growtime': growtime, 'growfreq': growfreq, 'growaround': growaround, 'flagneartime': flagneartime, 'flagnearfreq': flagnearfreq, 'apply': apply}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _parseextendparameters_result = self._swigobj.parseextendparameters(_str_ec(_pc.document['field']), _str_ec(_pc.document['spw']), _str_ec(_pc.document['array']), _str_ec(_pc.document['feed']), _str_ec(_pc.document['scan']), _str_ec(_pc.document['antenna']), _str_ec(_pc.document['uvrange']), _str_ec(_pc.document['time']), _str_ec(_pc.document['correlation']), _str_ec(_pc.document['intent']), _str_ec(_pc.document['observation']), _pc.document['ntime'], _pc.document['combinescans'], _pc.document['extendpols'], _pc.document['growtime'], _pc.document['growfreq'], _pc.document['growaround'], _pc.document['flagneartime'], _pc.document['flagnearfreq'], _pc.document['apply'])
        return _parseextendparameters_result

    def parsesummaryparameters(self, field='', spw='', array='', feed='', scan='', antenna='', uvrange='', time='', correlation='', intent='', observation='', spwchan=False, spwcorr=False, basecnt=False, fieldcnt=False, name=''):
        """
        """
        schema = {'field': {'type': 'cStr'}, 'spw': {'type': 'cStr'}, 'array': {'type': 'cStr'}, 'feed': {'type': 'cStr'}, 'scan': {'type': 'cStr'}, 'antenna': {'type': 'cStr'}, 'uvrange': {'type': 'cStr'}, 'time': {'type': 'cStr'}, 'correlation': {'type': 'cStr'}, 'intent': {'type': 'cStr'}, 'observation': {'type': 'cStr'}, 'spwchan': {'type': 'cBool'}, 'spwcorr': {'type': 'cBool'}, 'basecnt': {'type': 'cBool'}, 'fieldcnt': {'type': 'cBool'}, 'name': {'type': 'cStr'}}
        doc = {'field': field, 'spw': spw, 'array': array, 'feed': feed, 'scan': scan, 'antenna': antenna, 'uvrange': uvrange, 'time': time, 'correlation': correlation, 'intent': intent, 'observation': observation, 'spwchan': spwchan, 'spwcorr': spwcorr, 'basecnt': basecnt, 'fieldcnt': fieldcnt, 'name': name}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _parsesummaryparameters_result = self._swigobj.parsesummaryparameters(_str_ec(_pc.document['field']), _str_ec(_pc.document['spw']), _str_ec(_pc.document['array']), _str_ec(_pc.document['feed']), _str_ec(_pc.document['scan']), _str_ec(_pc.document['antenna']), _str_ec(_pc.document['uvrange']), _str_ec(_pc.document['time']), _str_ec(_pc.document['correlation']), _str_ec(_pc.document['intent']), _str_ec(_pc.document['observation']), _pc.document['spwchan'], _pc.document['spwcorr'], _pc.document['basecnt'], _pc.document['fieldcnt'], _str_ec(_pc.document['name']))
        return _parsesummaryparameters_result

