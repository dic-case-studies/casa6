##################### generated by xml-casa (v2) from coordsys.xml ##################
##################### ba72f6b892d295fcf5df093fb446253b ##############################
from __future__ import absolute_import 
from .__casac__ import coordsys as _coordsys
from .platform import str_encode as _str_encode
from .platform import str_decode as _str_decode
from .typecheck import validator as _pc
from .coercetype import coerce as _coerce
_wrap_coordsys = lambda swig_object: coordsys(swig_object=swig_object)

class coordsys:
    ### self
    def __init__(self, *args, **kwargs):
        """
        """
        self._swigobj = kwargs.get('swig_object',None)
        if self._swigobj is None:
            self._swigobj = _coordsys()

    def newcoordsys(self, direction=False, spectral=False, stokes=[ 'I','Q','U','V','XX','YY','XY','YX','RR','LL','RL','LR','' ], linear=int(0), tabular=False):
        """By default, this constructor makes an empty Coordsys tool.  You can ask
        it to include various sorts of coordinates through the arguments.
        Except for Stokes, you don't have any control over the coordinate
        contents (e.g.  reference value etc.) it does make for you on request.
        But you can edit the Coordinate System after creation if you wish.
        
        If you wish to make a Stokes coordinate, then you assign
        {stfaf stokes} to a string (or a vector of strings) saying
        which Stokes you want.  casa allows rather
        a lot of potential Stokes types.
        
        Probably most useful is some combination of the
        basic I, Q, U, V, XX, YY, XY, YX, RR, LL, RL, and LR.
        
        However, a more esoteric choice is also possible:
        RX, RY, LX, LY, XR, XL, YR, YL (these are mixed
        linear and circular),  PP, PQ, QP, QQ (general quasi-orthogonal correlation products)
        RCircular, LCircular, Linear  (single dish polarization types).
        
        You can also specify some polarization `Stokes' types:
        Ptotal (Polarized intensity ($(Q^2+U^2+V^2)^{1/2}$),
        Plinear (Linearly Polarized intensity ($(Q^2+U^2)^{1/2}$),
        PFtotal (Polarization Fraction (Ptotal/I)),
        PFlinear  (Linear Polarization Fraction (Plinear/I)), and
        Pangle  (Linear Polarization Angle ($0.5~arctan(U/Q)$ in radians)).
        
        Probably you will find the more unusual types aren't fully
        supported throughout the system.
        
        You can make a LinearCoordinate with as many uncoupled axes as you like.
        Thus, {stfaf linear=2} makes one LinearCoordinate with 2 axes (think
        of it like a DirectionCoordinate which also has 2 axes [but coupled in
        this case], a longitude and a latitude).
        
        If you make a TabularCoordinate, it is linear to start with.
        You can change it to a non-linear one by providing
        a list of pixel and world values to function
        settabular.
        """
        schema = {'direction': {'type': 'cBool'}, 'spectral': {'type': 'cBool'}, 'stokes': {'type': 'cStrVec', 'coerce': _coerce.to_strvec}, 'linear': {'type': 'cInt'}, 'tabular': {'type': 'cBool'}}
        doc = {'direction': direction, 'spectral': spectral, 'stokes': stokes, 'linear': linear, 'tabular': tabular}
        assert _pc.validate(doc,schema), str(_pc.errors)
        return _wrap_coordsys(swig_object=self._swigobj.newcoordsys(_pc.document['direction'], _pc.document['spectral'], [_str_encode(_x) for _x in _pc.document['stokes']], _pc.document['linear'], _pc.document['tabular']))

    def addcoordinate(self, direction=False, spectral=False, stokes=[ 'I','Q','U','V','XX','YY','XY','YX','RR','LL','RL','LR','' ], linear=int(0), tabular=False):
        """Add default coordinates of the specified types.  This function allows
        multiple coordinates of the same type which are not well supported.
        Use only for assay tests.
        """
        schema = {'direction': {'type': 'cBool'}, 'spectral': {'type': 'cBool'}, 'stokes': {'type': 'cStrVec', 'coerce': _coerce.to_strvec}, 'linear': {'type': 'cInt'}, 'tabular': {'type': 'cBool'}}
        doc = {'direction': direction, 'spectral': spectral, 'stokes': stokes, 'linear': linear, 'tabular': tabular}
        assert _pc.validate(doc,schema), str(_pc.errors)
        return self._swigobj.addcoordinate(_pc.document['direction'], _pc.document['spectral'], [_str_encode(_x) for _x in _pc.document['stokes']], _pc.document['linear'], _pc.document['tabular'])

    def axesmap(self, toworld=True):
        """This function returns a vector describing the mapping from pixel to
        world or world to pixel axes.  It is not for general user use.
        
        See the htmlref{discussion}{COORDSYS:PWAXES} about pixel and world axis
        ordering.  Generally they will be in the same order.
        """
        schema = {'toworld': {'type': 'cBool'}}
        doc = {'toworld': toworld}
        assert _pc.validate(doc,schema), str(_pc.errors)
        return self._swigobj.axesmap(_pc.document['toworld'])

    def axiscoordinatetypes(self, world=True):
        """This function  returns a vector string
        giving the coordinate type for each axis (world or pixel)
        in the Coordinate System.
        
        See the htmlref{discussion}{COORDSYS:PWAXES} about pixel and world axis
        ordering.
        """
        schema = {'world': {'type': 'cBool'}}
        doc = {'world': world}
        assert _pc.validate(doc,schema), str(_pc.errors)
        return self._swigobj.axiscoordinatetypes(_pc.document['world'])

    def conversiontype(self, type='direction'):
        """Some coordinates contain a reference code.  Examples of reference codes
        are B1950 and J2000 for direction coordinates, or LSRK and BARY for
        spectral coordinates.  When you do conversions between pixel and world
        coordinate, the coordinates are in the reference frame corresponding to
        these codes.
        
        Function  setconversiontype
        allows you to specify a different reference frame
        which is used when converting between world and pixel coordinate.
        
        This function allows you to recover those conversion types.  If no extra
        conversion layer has been set, you get back the native reference types.
        """
        schema = {'type': {'type': 'cStr'}}
        doc = {'type': type}
        assert _pc.validate(doc,schema), str(_pc.errors)
        return self._swigobj.conversiontype(_str_encode(_pc.document['type']))

    def convert(self, coordin, absin=[ False ], dopplerin='radio', unitsin=[ 'Native' ], absout=[ False ], dopplerout='radio', unitsout=[ 'Native' ], shape=[ int(-1) ]):
        """This function converts between mixed pixel/world/abs/rel numeric
        coordinates.  The input and output coordinates are specified via a
        numeric vector giving coordinate values, a string vector giving units, a
        boolean vector specifying whether the coordinate is absolute or relative
        (to the reference pixel) and doppler strings specifying the doppler
        convention for velocities.
        
        The units string may include {cf pix} for pixel coordinates and
        velocity units (i.e. any unit consistent with {cf m/s}).
        
        The allowed doppler strings and definition are described
        in function summary.
        
        The {stfaf shape} argument is optional.  If your Coordinate
        System is from an image, then assign the image shape to this
        argument.  It is used only when making mixed (pixel/world) conversions
        for Direction Coordinates to resolve ambiguity.
        
        The example clarifies the use of this function.
        """
        schema = {'coordin': {'type': 'cFloatVec', 'coerce': _coerce.to_floatvec}, 'absin': {'type': 'cBoolVec'}, 'dopplerin': {'type': 'cStr'}, 'unitsin': {'type': 'cStrVec', 'coerce': _coerce.to_strvec}, 'absout': {'type': 'cBoolVec'}, 'dopplerout': {'type': 'cStr'}, 'unitsout': {'type': 'cStrVec', 'coerce': _coerce.to_strvec}, 'shape': {'type': 'cIntVec', 'coerce': _coerce.to_intvec}}
        doc = {'coordin': coordin, 'absin': absin, 'dopplerin': dopplerin, 'unitsin': unitsin, 'absout': absout, 'dopplerout': dopplerout, 'unitsout': unitsout, 'shape': shape}
        assert _pc.validate(doc,schema), str(_pc.errors)
        return self._swigobj.convert(_pc.document['coordin'], _pc.document['absin'], _str_encode(_pc.document['dopplerin']), [_str_encode(_x) for _x in _pc.document['unitsin']], _pc.document['absout'], _str_encode(_pc.document['dopplerout']), [_str_encode(_x) for _x in _pc.document['unitsout']], _pc.document['shape'])

    def convertdirection(self, frame):
        """Convert the direction coordinate in the coordinate system to the specified frame by
        rotating about the reference pixel so that the resulting coordinate axes are parallel
        to the cardinal directions. The resulting coordinate will not have a conversion layer,
        even if the input direction coordinate does. A conversion layer can be set after by
        running cs.setconversiontype(). Be aware that if you attach the resulting coordinate
        system to an image whose pixels have not been rotated around the reference pixel in
        the same manner, you will likely get an image for which the pixels do not match
        up to world coordinate values. This method should only be used by experienced users who
        know what they are doing. It was written originally to facilitate rotating the
        direction coordinate since the implementation of imregrid requires this in certain
        circumstances. The conversion is done in place; a new coordinate system tool is not
        created. The returned record represents an angular quantity through which the old
        direction coordinate was rotated to create the new coordinate.
        
        """
        schema = {'frame': {'type': 'cStr'}}
        doc = {'frame': frame}
        assert _pc.validate(doc,schema), str(_pc.errors)
        return self._swigobj.convertdirection(_str_encode(_pc.document['frame']))

    def convertmany(self, coordin=[ ], absin=[ False ], dopplerin='radio', unitsin=[ 'Native' ], absout=[ False ], dopplerout='radio', unitsout=[ 'Native' ], shape=[ int(-1) ]):
        """This function converts between many mixed pixel/world/abs/rel numeric
        coordinates.   See function convert
        for more information.
        
        The only diffference with that function is that you
        provide a matrix holding many coordinates to convert
        and a matrix of many converted coordinates is returned.
        """
        schema = {'coordin': {'type': 'cVariant'}, 'absin': {'type': 'cBoolVec'}, 'dopplerin': {'type': 'cStr'}, 'unitsin': {'type': 'cStrVec', 'coerce': _coerce.to_strvec}, 'absout': {'type': 'cBoolVec'}, 'dopplerout': {'type': 'cStr'}, 'unitsout': {'type': 'cStrVec', 'coerce': _coerce.to_strvec}, 'shape': {'type': 'cIntVec', 'coerce': _coerce.to_intvec}}
        doc = {'coordin': coordin, 'absin': absin, 'dopplerin': dopplerin, 'unitsin': unitsin, 'absout': absout, 'dopplerout': dopplerout, 'unitsout': unitsout, 'shape': shape}
        assert _pc.validate(doc,schema), str(_pc.errors)
        return self._swigobj.convertmany(_pc.document['coordin'], _pc.document['absin'], _str_encode(_pc.document['dopplerin']), [_str_encode(_x) for _x in _pc.document['unitsin']], _pc.document['absout'], _str_encode(_pc.document['dopplerout']), [_str_encode(_x) for _x in _pc.document['unitsout']], _pc.document['shape'])

    def coordinatetype(self, which=int(-1)):
        """This function  returns a string describing
        the type of the specified coordinate.  If {stfaf which=unset} the types
        for all coordinates are returned.
        
        Possible output values are 'Direction', 'Spectral', 'Stokes', 'Linear', and
        'Tabular'
        """
        schema = {'which': {'type': 'cInt'}}
        doc = {'which': which}
        assert _pc.validate(doc,schema), str(_pc.errors)
        return self._swigobj.coordinatetype(_pc.document['which'])

    def copy(self):
        """This function returns a copy, not a reference, of the Coordsys tool.
        It is your responsibility to call the {stff done} function
        on the new tool.
        """
        return _wrap_coordsys(swig_object=self._swigobj.copy())

    def done(self):
        """If you no longer need to use a Coordsys tool calling this function
        will free up its resources and restore the default coordsys tool.
        """
        return self._swigobj.done()

    def epoch(self):
        """This function  returns the epoch of the observation as a
        Measure.
        """
        return self._swigobj.epoch()

    def findaxis(self, world=True, axis=int(0)):
        """This function  finds the specified axis in
        the Coordinate System. If the axis does not exist, it throws an exception.
        """
        schema = {'world': {'type': 'cBool'}, 'axis': {'type': 'cInt'}}
        doc = {'world': world, 'axis': axis}
        assert _pc.validate(doc,schema), str(_pc.errors)
        return self._swigobj.findaxis(_pc.document['world'], _pc.document['axis'])

    def findaxisbyname(self, axisname='', allowfriendlyname=True):
        """Find the world axis based on its name. Matching is not case sensitive and minimal match is supported, eg "dec" will match "Declination".
        In addition, if allowfriendlyname is True, other common terms will match the expected axis. Currently supported are:
        "spectral" matches frequency type axes, eg "Frequency" or "Velocity",
        "ra" matches "Right Ascension". These names must be spelled out completely; eg "spectral" rather than simply "spec".
        The first matching axis (zero-based) number is returned. If no axis can be matched, an exception is thrown.
        
        """
        schema = {'axisname': {'type': 'cStr'}, 'allowfriendlyname': {'type': 'cBool'}}
        doc = {'axisname': axisname, 'allowfriendlyname': allowfriendlyname}
        assert _pc.validate(doc,schema), str(_pc.errors)
        return self._swigobj.findaxisbyname(_str_encode(_pc.document['axisname']), _pc.document['allowfriendlyname'])

    def findcoordinate(self, type='direction', which=int(0)):
        """This function finds the axes in the
        Coordinate System for the specified coordinate (minimum match is active
        for argument {stfaf type}).  By default it finds the first coordinate,
        but if there is more than one (can happen for linear coordinates), you
        can specify which.  It returns a dictionary with 'return', 'pixel', and
        'world' as keys. The associated value of 'return' is a boolean indicating if
        the specified coordinate was found. The values of 'pixel' and 'world' are
        arrays indicating the indices of the associated pixel and world axes, respectively,
        of the specified coordinate. If the coordinate does not exist, these arrays
        will be empty.
        
        See also the function axesmap
        which returns the mapping between pixel and world axes.
        """
        schema = {'type': {'type': 'cStr'}, 'which': {'type': 'cInt'}}
        doc = {'type': type, 'which': which}
        assert _pc.validate(doc,schema), str(_pc.errors)
        return self._swigobj.findcoordinate(_str_encode(_pc.document['type']), _pc.document['which'])

    def frequencytofrequency(self, value, frequnit='', velocity=[ ]):
        """This function converts frequencies to frequencies by applying a
        relativistic Doppler shift:
        fout = fin * sqrt((1.-v/c)/(1.+v/c)) .
        
        The input frequencies are specified via a vector of numeric values and
        a specified unit ({stfaf frequnit}).  If you don't give a frequency
        unit, it is assumed that the units are those given by function coordsys units() for
        the spectral coordinate.
        
        This function does not make any frame conversions (e.g.  LSR to BARY).
        
        This function fails if there is no spectral coordinate
        in the Coordinate System. See also function
        frequencytovelocity.
        """
        schema = {'value': {'type': 'cFloatVec', 'coerce': _coerce.to_floatvec}, 'frequnit': {'type': 'cStr'}, 'velocity': {'type': 'cVariant'}}
        doc = {'value': value, 'frequnit': frequnit, 'velocity': velocity}
        assert _pc.validate(doc,schema), str(_pc.errors)
        return self._swigobj.frequencytofrequency(_pc.document['value'], _str_encode(_pc.document['frequnit']), _pc.document['velocity'])

    def frequencytovelocity(self, value, frequnit='', doppler='radio', velunit='km/s'):
        """This function  converts frequencies to
        velocities.
        
        The input frequencies are specified via a vector of numeric values and
        a specified unit ({stfaf frequnit}).  If you don't give a frequency
        unit, it is assumed that the units are those given by function coordsys units() for
        the spectral coordinate.
        
        This function does not make any frame conversions (e.g. LSR to BARY)
        but you can specifiy the velocity doppler definition via the {stfaf
        doppler} argument (see image summary() for
        possible values).
        
        The velocities are returned in a vector for which you specify the
        units ({stfaf velunit} - default is km/s).
        
        This function will return a fail if there is no spectral coordinate
        in the Coordinate System. See also function
        velocitytofrequency.
        """
        schema = {'value': {'type': 'cFloatVec', 'coerce': _coerce.to_floatvec}, 'frequnit': {'type': 'cStr'}, 'doppler': {'type': 'cStr'}, 'velunit': {'type': 'cStr'}}
        doc = {'value': value, 'frequnit': frequnit, 'doppler': doppler, 'velunit': velunit}
        assert _pc.validate(doc,schema), str(_pc.errors)
        return self._swigobj.frequencytovelocity(_pc.document['value'], _str_encode(_pc.document['frequnit']), _str_encode(_pc.document['doppler']), _str_encode(_pc.document['velunit']))

    def fromrecord(self, record):
        """You can convert a Coordinate System to a record
        (torecord).  This function
        (fromrecord) allows you to set the contents of an existing Coordinate
        System from such a record.   In doing so, you overwrite its current
        contents.
        """
        schema = {'record': {'type': 'cDict'}}
        doc = {'record': record}
        assert _pc.validate(doc,schema), str(_pc.errors)
        return self._swigobj.fromrecord(_pc.document['record'])

    def increment(self, format='n', type=''):
        """Each axis associated with the Coordinate System has a reference value,
        reference pixel and an increment (per pixel).  These are used in the
        mapping from pixel to world coordinate.
        
        This function  returns the increment (in
        world axis order). You can recover  the increments either for all
        coordinates (leave {stfaf type} unset) or for a specific coordinate
        type (mimumum match of the allowed types will do).  If you ask for a
        non-existent coordinate an exception is generated.
        
        See the htmlref{discussion}{COORDSYS:FORMATTING} regarding the
        formatting possibilities available via argument {stfaf format}.
        
        You can set the increment with function
        setincrement.
        """
        schema = {'format': {'type': 'cStr'}, 'type': {'type': 'cStr'}}
        doc = {'format': format, 'type': type}
        assert _pc.validate(doc,schema), str(_pc.errors)
        return self._swigobj.increment(_str_encode(_pc.document['format']), _str_encode(_pc.document['type']))

    def lineartransform(self, type):
        """Recover the linear transform component for the specified coordinate type.
        
        You can set the linear transform with function
        setlineartransform.
        """
        schema = {'type': {'type': 'cStr'}}
        doc = {'type': type}
        assert _pc.validate(doc,schema), str(_pc.errors)
        return self._swigobj.lineartransform(_str_encode(_pc.document['type']))

    def names(self, type=''):
        """Each axis associated with the Coordinate System has a name (they don't
        mean anything fundamental).  This function returns those names in
        world axis order.
        
        You can recover the names either for all coordinates (leave {stfaf
        type} unset) or for a specific coordinate type (mimumum match of the
        allowed types will do).  If you ask for a non-existent coordinate an
        exception is generated.
        
        You can set the names with function
        setnames.
        """
        schema = {'type': {'type': 'cStr'}}
        doc = {'type': type}
        assert _pc.validate(doc,schema), str(_pc.errors)
        return self._swigobj.names(_str_encode(_pc.document['type']))

    def naxes(self, world=True):
        """Find the number of axes  in the Coordinate System.
        
        You may find the number of world or pixel axes; these are generally the
        same and general users can ignore the distinction.  See the
        htmlref{discussion}{COORDSYS:PWAXES} about pixel and world axis
        ordering.
        """
        schema = {'world': {'type': 'cBool'}}
        doc = {'world': world}
        assert _pc.validate(doc,schema), str(_pc.errors)
        return self._swigobj.naxes(_pc.document['world'])

    def ncoordinates(self):
        """This function  recovers the number of
        coordinates in the Coordinate System.
        """
        return self._swigobj.ncoordinates()

    def observer(self):
        """This function returns the name of the observer.
        You can set it with the function setobserver.
        """
        return self._swigobj.observer()

    def projection(self, type=''):
        """If the Coordinate System contains a direction coordinate, this function
        can be used to recover information about the
        projection.  For discussion about celestial coordinate systems,
        including projections, see the papers by Mark Calabretta and Eric
        Greisen. The initial draft  from 1996 (implemented in
        casa.  Background information can be
        found
        htmladdnormallink{here}{http://www.atnf.csiro.au/people/mark.calabretta/WCS}.
        
        What this function returns depends upon the value
        you assign to {stfaf type}.
        
        begin{itemize}
        
        item {stfaf type=unset}.  In this case (the default), the actual
        projection type and projection parameters are returned in a
        record with fields {cf type} and {cf parameters}, respectively.
        
        item {stfaf type='all'}.  In this case, a vector of strings
        containing all of the possible projection codes is returned.
        
        item {stfaf type=code}.  If you specify a valid
        projection type code (see list by setting {stfaf type='all'})
        then what is returned is the number of parameters required
        to describe that projection (useful in function
        setprojection).
        
        end{itemize}
        
        You can change the projection with
        setprojection.
        
        If the Coordinate System does not contain a direction coordinate,
        an exception is generated.
        """
        schema = {'type': {'type': 'cStr'}}
        doc = {'type': type}
        assert _pc.validate(doc,schema), str(_pc.errors)
        return self._swigobj.projection(_str_encode(_pc.document['type']))

    def referencecode(self, type='', list=False):
        """This function  returns the reference code
        for all, or the specified coordinate type.    Examples of the reference
        code are B1950 and J2000 for direction coordinates, or LSRK and BARY for
        spectral coordinates.
        
        If {stfaf type} is left unset, then a vector of strings is returned,
        one code for each coordinate type in the Coordinate System.
        
        If you specify {stfaf type} then select from
        'direction', 'spectral', 'stokes', and 'linear'
        (the first two letters will do).  However, only the first two
        coordinate types will return a non-empty string.
        If the Coordinate System does not contain a coordinate of
        the type you specify, an exception is generated.
        
        The argument {stfaf list} is ignored unless you specify a specific {stfaf type}.
        If {stfaf list=T}, then this function returns the list of all possible
        reference  codes for the specified coordinate type.  Otherwise, it just
        returns the actual code current set in the Coordinate System.
        
        The list of all possible types is returned as a record  (it is
        actually generated by the
        listcodes function in the
        measures system). This record has two
        fields.  These are called 'normal'
        (containing all normal codes) and 'extra' (maybe empty, with all extra
        codes like planets).
        
        You can set the reference code with
        setreferencecode.
        """
        schema = {'type': {'type': 'cStr'}, 'list': {'type': 'cBool'}}
        doc = {'type': type, 'list': list}
        assert _pc.validate(doc,schema), str(_pc.errors)
        return self._swigobj.referencecode(_str_encode(_pc.document['type']), _pc.document['list'])

    def referencepixel(self, type=''):
        """Each axis associated with the Coordinate System has a reference value,
        reference pixel and an increment (per pixel).  These are used in the
        mapping from pixel to world coordinate.
        
        This function  returns the reference pixel
        (in pixel axis order). You can recover  the reference pixel either for
        all coordinates (leave {stfaf type} unset) or for a specific coordinate
        type (mimumum match of the allowed types will do).  If you ask for a
        non-existent coordinate an exception is generated.
        
        You can set the reference pixel with function
        setreferencepixel.
        """
        schema = {'type': {'type': 'cStr'}}
        doc = {'type': type}
        assert _pc.validate(doc,schema), str(_pc.errors)
        return self._swigobj.referencepixel(_str_encode(_pc.document['type']))

    def referencevalue(self, format='n', type=''):
        """Each axis associated with the Coordinate System has a reference value,
        reference pixel and an increment (per pixel).  These are used in the
        mapping from pixel to world coordinate.
        
        This function  returns the reference value
        (in world axis order). You can recover  the reference value either for all
        coordinates (leave {stfaf type} unset) or for a specific coordinate
        type (mimumum match of the allowed types will do).  If you ask for a
        non-existent coordinate an exception is generated.
        
        See the htmlref{discussion}{COORDSYS:FORMATTING} regarding the
        formatting possibilities available via argument {stfaf format}.
        
        You can set the reference value with function
        setreferencevalue.
        """
        schema = {'format': {'type': 'cStr'}, 'type': {'type': 'cStr'}}
        doc = {'format': format, 'type': type}
        assert _pc.validate(doc,schema), str(_pc.errors)
        return self._swigobj.referencevalue(_str_encode(_pc.document['format']), _str_encode(_pc.document['type']))

    def reorder(self, order):
        """This function reorders the coordinates in the Coordinate System.
        You specify the new order of the coordinates in terms of their old
        order.
        """
        schema = {'order': {'type': 'cIntVec', 'coerce': _coerce.to_intvec}}
        doc = {'order': order}
        assert _pc.validate(doc,schema), str(_pc.errors)
        return self._swigobj.reorder(_pc.document['order'])

    def transpose(self, order):
        """This method transposes the axes (both world and pixel) in the coordinate system.
        You specify the new order of the axes in terms of their old
        order, so eg order=[1,0,3,2] means reorder the axes so that the zeroth
        axis becomes the first axis, the first axis becomes the zeroth axis,
        the second axis becomes the third axis, and the third axis becomes the
        second axis.
        """
        schema = {'order': {'type': 'cIntVec', 'coerce': _coerce.to_intvec}}
        doc = {'order': order}
        assert _pc.validate(doc,schema), str(_pc.errors)
        return self._swigobj.transpose(_pc.document['order'])

    def replace(self, csys, whichin, whichout):
        """This function replaces one coordinate in the current Coordinate System by
        one coordinate in the given Coordinate System.  The specified
        coordinates must have the same number of axes.
        """
        schema = {'csys': {'type': 'cDict'}, 'whichin': {'type': 'cInt'}, 'whichout': {'type': 'cInt'}}
        doc = {'csys': csys, 'whichin': whichin, 'whichout': whichout}
        assert _pc.validate(doc,schema), str(_pc.errors)
        return self._swigobj.replace(_pc.document['csys'], _pc.document['whichin'], _pc.document['whichout'])

    def restfrequency(self):
        """If the Coordinate System contains a spectral coordinate, then
        it has a rest frequency.  In fact, the spectral coordinate
        can hold several rest frequencies (to handle for example,
        an observation where the band covers many lines), although
        only one is active (for velocity conversions) at a time.
        
        This function  recovers the rest frequencies
        as a quantity vector.   The first frequency is the active one.
        
        You can change the rest frequencies with
        setrestfrequency.
        
        If the Coordinate System does not contain a frequency coordinate,
        an exception is generated.
        """
        return self._swigobj.restfrequency()

    def setconversiontype(self, direction='', spectral=''):
        """Some coordinates contain a reference code.  Examples of reference codes
        are B1950 and J2000 for direction coordinates, or LSRK and BARY for
        spectral coordinates.  When you do conversions between pixel and world
        coordinate, the coordinates are in the reference frame corresponding to
        these codes.
        
        This function allows you to specify a different reference frame which
        is used when converting between world and pixel coordinate (see
        function conversiontype
        to recover the conversion types).  If it returns F, it means that
        although the conversion machines were successfully created, a trial
        conversion failed.  This usually means the REST frame was involved
        which requires a radial velocity (not yet implemented).  If this
        happens, the conversion type will be left as it was. The function
        fails if more blatant things are wrong like a missing coordinate, or
        an incorrect reference code.
        
        The list of possible reference codes can be obtained via function
        referencecode.
        
        With this function, you specify the desired reference code.  Then,
        when a conversion between pixel and world is requested, an extra
        conversion is done to ({stff toWorld}) or from ({stff toPixel}) the
        specified reference frame.
        
        The summary
        function shows the extra conversion reference system to the right of
        the native reference system (if it is different) and in parentheses.
        
        Note that to convert between different spectral reference frames, you
        need a position, epoch and direction.  The position (telescope) and
        epoch (date of observation), if not in your coordinate system can be set
        with functions settelescope and
        setepoch.  The direction is the
        reference direction of the {it required} direction coordinate in the
        coordinate system.
        
        bigskipgoodbreak
        As an example, let us say you are working with a spectral coordinate
        which was constructed with the LSRK reference frame.  You want to convert
        some pixel coordinates to barycentric velocities (reference code BARY).
        
        begin{verbatim}
        
        #
        print "t----t setconversiontype Ex 1 t----"
        csys = cs.newcoordsys(direction=True, spectral=True); # Create coordinate system
        rtn=csys.findcoordinate('spectral')             # Find spectral coordinate
        wa=rtn['world']
        pa=rtn['pixel']
        u = csys.units()[wa]                            # Spectral unit
        print csys.referencecode(type='spectral')       # Which is  in LSRK reference frame
        #LSRK
        p = [10,20,30]
        w = csys.toworld(p, format='n')           # Convert a pixel to LSRK world
        print 'pixel, world = ', p, w['numeric']
        #pixel, world =  [10, 20, 30] [21589.999816660376, 20.000112822985134, 1415030000.0]
        p2 = csys.topixel(w)                      # and back to pixel
        print 'world, pixel = ', w['numeric'], p2
        #world, pixel =  [21589.999816660376, 20.000112822985134, 1415030000.0]
        # [10.00000000000248, 19.999999999999801, 30.0]
        # Convert LSRK frequency to LSRK velocity
        v = csys.frequencytovelocity(value=w['numeric'][wa], frequnit=u,
        doppler='RADIO', velunit='m/s');
        print 'pixel, frequency, velocity = ', p[pa], w['numeric'][wa], v
        #pixel, frequency, velocity =  30 1415030000.0 1134612.30321
        csys.setconversiontype(spectral='BARY')   # Specify BARY reference code
        w = csys.toworld(p, format='n')           # Convert a pixel to BARY world
        print 'pixel, world = ', p, w['numeric']
        #pixel, world =  [10, 20, 30] [21589.999816660376, 20.000112822985134, 1415031369.0081882]
        p2 = csys.topixel(w)                      # and back to pixel
        print 'world, pixel = ', w['numeric'], p2
        #world, pixel =  [21589.999816660376, 20.000112822985134, 1415031369.0081882]
        # [10.00000000000248, 19.999999999999801, 30.0]
        # Convert BARY frequency to BARY velocity
        v = csys.frequencytovelocity(value=w['numeric'][wa], frequnit=u,
        doppler='RADIO', velunit='m/s');
        print 'pixel, frequency, velocity = ', p[pa], w['numeric'][wa], v
        #pixel, frequency, velocity =  30 1415031369.01 1134323.35878
        #
        
        end{verbatim}
        
        
        You must also be aware of when this extra layer is active and when it is
        not.  It's a bit nasty.
        
        begin{itemize}
        
        item - Whenever you use {stff toWorld}, {stff toPixel}
        {stff toWorldMany}, or {stff toPixelMany} the layer is active.
        
        item - Whenever you use {stff convert} or {stff convertMany}
        the layer {it may} be active.   Here are the rules !
        
        It is only relevant to spectral and direction coordinates.
        
        For the direction coordinate part of your conversion, if you request a
        pure world or pixel conversion it is active.  Any pixel/world mix will
        not invoke it (because it is ill defined).
        
        For the spectral coordinate part it is always active (only one axis
        so must be pixel or world).
        
        item - This layer is irrelevant to all functions converting between
        frequency and velocity, and absolute and relative.  The values are in
        whatever frame you are working with.
        
        end{itemize}
        
        The summary function
        lists the reference frame for direction and spectral coordinates.  If
        you have also set a conversion reference code it also lists that (to
        the right in parentheses).
        """
        schema = {'direction': {'type': 'cStr'}, 'spectral': {'type': 'cStr'}}
        doc = {'direction': direction, 'spectral': spectral}
        assert _pc.validate(doc,schema), str(_pc.errors)
        return self._swigobj.setconversiontype(_str_encode(_pc.document['direction']), _str_encode(_pc.document['spectral']))

    def getconversiontype(self, type='', showconversion=True):
        """See conversiontype for more complete description.
        """
        schema = {'type': {'type': 'cStr'}, 'showconversion': {'type': 'cBool'}}
        doc = {'type': type, 'showconversion': showconversion}
        assert _pc.validate(doc,schema), str(_pc.errors)
        return self._swigobj.getconversiontype(_str_encode(_pc.document['type']), _pc.document['showconversion'])

    def setdirection(self, refcode='', proj='', projpar=[ float(-1) ], refpix=[ float(-1) ], refval=[ ], incr=[ ], xform=[ ], poles=[ ]):
        """When you construct a Coordsys tool, if you include a Direction
        Coordinate, it  will have some default parameters.
        This function simply allows you to
        replace the values of the Direction Coordinate.
        
        You can also change almost all of those parameters (such as projection, reference value
        etc.) via the individual functions
        setreferencecode,
        setprojection,
        setreferencepixel,
        setreferencevalue,
        setincrement, and
        setlineartransform
        provided by the Coordsys tool.    See those functions for more details
        about the formatting of the above function arguments.
        
        Bear in mind, that if your Coordinate System came from a real image, then
        the reference pixel is special and you should not change it.
        """
        schema = {'refcode': {'type': 'cStr'}, 'proj': {'type': 'cStr'}, 'projpar': {'type': 'cFloatVec', 'coerce': _coerce.to_floatvec}, 'refpix': {'type': 'cFloatVec', 'coerce': _coerce.to_floatvec}, 'refval': {'type': 'cVariant'}, 'incr': {'type': 'cVariant'}, 'xform': {'type': 'cVariant'}, 'poles': {'type': 'cVariant'}}
        doc = {'refcode': refcode, 'proj': proj, 'projpar': projpar, 'refpix': refpix, 'refval': refval, 'incr': incr, 'xform': xform, 'poles': poles}
        assert _pc.validate(doc,schema), str(_pc.errors)
        return self._swigobj.setdirection(_str_encode(_pc.document['refcode']), _str_encode(_pc.document['proj']), _pc.document['projpar'], _pc.document['refpix'], _pc.document['refval'], _pc.document['incr'], _pc.document['xform'], _pc.document['poles'])

    def setepoch(self, value):
        """This function  sets a new epoch (supplied as an
        epoch measure) of the observation. You
        can get the current epoch with function
        epoch.
        """
        schema = {'value': {'type': 'cDict'}}
        doc = {'value': value}
        assert _pc.validate(doc,schema), str(_pc.errors)
        return self._swigobj.setepoch(_pc.document['value'])

    def setincrement(self, value=[ ], type=''):
        """Each axis associated with the Coordinate System has a reference value,
        reference pixel and an increment (per pixel).  These are used in the
        mapping from pixel to world coordinate.
        
        This function  allows you to set a new
        increment.   You should not do this on "stokes" axes unless you are an
        adept or a big risk taker.
        
        You can set the increments either for all axes ({stfaf
        type=unset}) or for just the axes associated with a particular
        coordinate type.
        
        You may supply the increments in all of the formats described in
        the htmlref{formatting}{COORDSYS:FORMATTING} discussion.
        
        In addition, you can also supply the increments as  a quantity of vector
        of doubles.  For example {stfaf qa.quantity([-1,2],'arcsec')}.
        
        You can recover the current increments with function
        increment.
        """
        schema = {'value': {'type': 'cVariant'}, 'type': {'type': 'cStr'}}
        doc = {'value': value, 'type': type}
        assert _pc.validate(doc,schema), str(_pc.errors)
        return self._swigobj.setincrement(_pc.document['value'], _str_encode(_pc.document['type']))

    def setlineartransform(self, type='', value=[ ]):
        """This function set the linear transform component.  For Stokes Coordinates
        this function will return T but do nothing.
        
        You can recover the current linear transform with function
        lineartransform.
        """
        schema = {'type': {'type': 'cStr'}, 'value': {'type': 'cVariant'}}
        doc = {'type': type, 'value': value}
        assert _pc.validate(doc,schema), str(_pc.errors)
        return self._swigobj.setlineartransform(_str_encode(_pc.document['type']), _pc.document['value'])

    def setnames(self, value, type=''):
        """Each axis associated with the Coordinate System has a name.
        It isn't used in any fundamental way.
        
        This function  allows you to set
        new axis names.
        
        You can set the names either for all axes ({stfaf
        type=unset}) or for just the axes associated with a particular
        coordinate type.
        
        You can recover the current axis names with function
        names.
        """
        schema = {'value': {'type': 'cStrVec', 'coerce': _coerce.to_strvec}, 'type': {'type': 'cStr'}}
        doc = {'value': value, 'type': type}
        assert _pc.validate(doc,schema), str(_pc.errors)
        return self._swigobj.setnames([_str_encode(_x) for _x in _pc.document['value']], _str_encode(_pc.document['type']))

    def setobserver(self, value):
        """If you want to grab all the glory, or transfer the blame, this function
        sets a new observer of the
        observation. You can get the current observer with function observer.  The
        observer's name is not fundamental to the Coordinate System !
        """
        schema = {'value': {'type': 'cStr'}}
        doc = {'value': value}
        assert _pc.validate(doc,schema), str(_pc.errors)
        return self._swigobj.setobserver(_str_encode(_pc.document['value']))

    def setprojection(self, type, parameters=[ float(-1) ]):
        """If the Coordinate System contains a direction coordinate, this
        function  can be used to set the
        projection.  For discussion about celestial coordinate systems,
        including projections, see the papers by Mark Calabretta and Eric
        Greisen. The initial draft from 1996 (implemented in casa) can be
        found
        htmladdnormallink{here}{http://www.atnf.csiro.au/people/mark.calabretta/WCS}.
        
        You can use the function projection
        to find out all the possible types of projection.  You can also use it
        to find out how many parameters you need to describe a particular
        projection.  See Calabretta and Greisen for details about those
        parameters (see section 4 of their paper); in FITS terms these
        parameters are what are labelled as PROJP.
        
        Some brief help here on the more common projections in astronomy.
        
        begin{itemize}
        
        item SIN has either 0 parameters or 2.  For coplanar arrays like
        East-West arrays, one can use what is widely termed the NCP projection.
        This is actually a SIN projection where the parameters are 0 and
        $1/tan(delta_0)$ where $delta_0$ is the reference declination.  Images
        made from the ATNF's Compact Array with casa will have such a
        projection.  Otherwise, the SIN projection requires no parameters (but
        you can give it two each of which is zero if you wish).
        
        item TAN is used widely in optical astronomy.  It requires 0
        parameters.
        
        item ZEA (zenithal equal area) is used widely in survey work.
        It requires 0 parameters.
        
        end{itemize}
        
        If the Coordinate System does not contain a direction coordinate,
        an exception is generated.
        """
        schema = {'type': {'type': 'cStr'}, 'parameters': {'type': 'cFloatVec', 'coerce': _coerce.to_floatvec}}
        doc = {'type': type, 'parameters': parameters}
        assert _pc.validate(doc,schema), str(_pc.errors)
        return self._swigobj.setprojection(_str_encode(_pc.document['type']), _pc.document['parameters'])

    def setreferencecode(self, value, type='direction', adjust=True):
        """This function  sets the reference
        code for the specified coordinate type.  Examples of reference codes
        are B1950 and J2000 for direction coordinates, or LSRK and BARY for
        spectral coordinates.
        
        You must specify {stfaf type}, selecting from 'direction',  or
        'spectral' (the first two letters will do).   If the Coordinate System
        does not contain a coordinate of the type you specify, an exception is
        generated.
        
        Specify the new code with argument {stfaf value}.  To see the list of
        possible codes, use the function referencecode
        (see example).
        
        If {stfaf adjust} is T, then the reference value is recomputed.
        This is invariably the correct thing to do.  If {stfaf adjust} is F,
        then the reference code is simply overwritten; do this very carefully.
        """
        schema = {'value': {'type': 'cStr'}, 'type': {'type': 'cStr'}, 'adjust': {'type': 'cBool'}}
        doc = {'value': value, 'type': type, 'adjust': adjust}
        assert _pc.validate(doc,schema), str(_pc.errors)
        return self._swigobj.setreferencecode(_str_encode(_pc.document['value']), _str_encode(_pc.document['type']), _pc.document['adjust'])

    def setreferencelocation(self, pixel=[ int(-1) ], world=[ ], mask=[ False ]):
        """This function sets the reference pixel and
        reference value to the specified values.  The world coordinate can be
        specified in any of the formats that the output world coordinate is
        returned in by the toworld function.
        
        You can specify a mask (argument {stfaf mask}) indicating which pixel
        axes are set (T) and which are left unchanged (F).  This function will
        refuse to change the reference location of a Stokes axis (gets you into
        trouble otherwise).
        
        This function can be rather useful when regridding
        images.  It allows you to keep easily a particular feature centered in the
        regridded image.
        """
        schema = {'pixel': {'type': 'cIntVec', 'coerce': _coerce.to_intvec}, 'world': {'type': 'cVariant'}, 'mask': {'type': 'cBoolVec'}}
        doc = {'pixel': pixel, 'world': world, 'mask': mask}
        assert _pc.validate(doc,schema), str(_pc.errors)
        return self._swigobj.setreferencelocation(_pc.document['pixel'], _pc.document['world'], _pc.document['mask'])

    def setreferencepixel(self, value, type=''):
        """Each axis associated with the Coordinate System has a reference value,
        reference pixel and an increment (per pixel).  These are used in the
        mapping from pixel to world coordinate.
        
        This function allows you to set a new reference pixel.   You should not
        do this on "stokes" axes unless you are an adept or a big risk taker.
        
        You can set the reference pixel either for all axes ({stfaf
        type=unset}) or for just the axes associated with a particular
        coordinate type.
        
        Bear in mind, that if your Coordinate System came from a real image,
        then the reference pixel is special and you should not change it for
        Direction Coordinates.
        
        You can recover the current reference pixel with function
        referencepixel.
        """
        schema = {'value': {'type': 'cFloatVec', 'coerce': _coerce.to_floatvec}, 'type': {'type': 'cStr'}}
        doc = {'value': value, 'type': type}
        assert _pc.validate(doc,schema), str(_pc.errors)
        return self._swigobj.setreferencepixel(_pc.document['value'], _str_encode(_pc.document['type']))

    def setreferencevalue(self, value=[ ], type=''):
        """Each axis associated with the Coordinate System has a reference value,
        reference pixel and an increment (per pixel).  These are used in the
        mapping from pixel to world coordinate.
        
        This function allows you to set a new
        reference value.  You should not do this on "stokes" axes unless you
        are an adept or a big risk taker.
        
        You may supply the reference value in all of the formats described in
        the htmlref{formatting}{COORDSYS:FORMATTING} discussion.
        
        You can recover the current reference value with function
        referencevalue.
        
        Note that the value argument should be one of the specified
        possibilitioes. Especially a {stff measure} will be accepted, but
        will have a null effect, due to the interpretation as a generic
        record.
        """
        schema = {'value': {'type': 'cVariant'}, 'type': {'type': 'cStr'}}
        doc = {'value': value, 'type': type}
        assert _pc.validate(doc,schema), str(_pc.errors)
        return self._swigobj.setreferencevalue(_pc.document['value'], _str_encode(_pc.document['type']))

    def setrestfrequency(self, value=[ ], which=int(0), append=False):
        """If the Coordinate System contains a spectral coordinate, then
        it has a rest frequency.  In fact, the spectral coordinate
        can hold several rest frequencies (to handle for example,
        an observation where the band covers many lines), although
        only one is active (for velocity conversions) at a time.
        
        This function allows you to set new rest
        frequencies.  You can provide the rest frequency as a quantity, or as
        a quantity string, or a double (units of current rest frequency assumed).
        
        You specify whether the list of frequencies will be appended
        to the current list or whether it will replace that list.
        You must select which of the frequencies will become the active
        one.  By default its the first in the list.  The index refers
        to the final list (either appended or replaced).
        
        You can recover the current rest frequencies with
        restfrequency.
        
        If the Coordinate System does not contain a frequency coordinate,
        an exception is generated.
        """
        schema = {'value': {'type': 'cVariant'}, 'which': {'type': 'cInt'}, 'append': {'type': 'cBool'}}
        doc = {'value': value, 'which': which, 'append': append}
        assert _pc.validate(doc,schema), str(_pc.errors)
        return self._swigobj.setrestfrequency(_pc.document['value'], _pc.document['which'], _pc.document['append'])

    def setspectral(self, refcode='', restfreq=[ ], frequencies=[ ], doppler='', velocities=[ ]):
        """When you construct a Coordsys tool, if you include a Spectral Coordinate, it
        will be linear in frequency.  This function allows you to replace the
        Spectral Coordinate by a finite table of values.  Coordinate
        conversions between pixel and world are then done by interpolation.
        
        You may specify either a vector of frequencies or velocities.  If you specify
        frequencies, you can optionally specify a (new) reference code (see
        function setreferencecode
        for more details) and rest frequency (else the existing ones will be used).
        
        If you specify velocities, you can optionally specify a (new) reference code
        and rest frequency (else the existing ones will be used).  You must also give
        the doppler type (see
        function summary for more
        details).  The velocities are then converted to frequency for creation of the
        Spectral Coordinate (which is fundamentally described by frequency).
        
        You may specify the rest frequency as a Quantum or a double (native units
        of Spectral Coordinate used).
        """
        schema = {'refcode': {'type': 'cStr'}, 'restfreq': {'type': 'cVariant'}, 'frequencies': {'type': 'cVariant'}, 'doppler': {'type': 'cStr'}, 'velocities': {'type': 'cVariant'}}
        doc = {'refcode': refcode, 'restfreq': restfreq, 'frequencies': frequencies, 'doppler': doppler, 'velocities': velocities}
        assert _pc.validate(doc,schema), str(_pc.errors)
        return self._swigobj.setspectral(_str_encode(_pc.document['refcode']), _pc.document['restfreq'], _pc.document['frequencies'], _str_encode(_pc.document['doppler']), _pc.document['velocities'])

    def setstokes(self, stokes):
        """If the Coordinate System contains a Stokes Coordinate, this function allows
        you to change the Stokes types defining it.  If there is no Stokes
        Coordinate, an exception is generated.
        
        See the coordsys constructor
        to see the possible Stokes types you can set.
        
        You can set the Stokes types with function
        setstokes.
        """
        schema = {'stokes': {'type': 'cStrVec', 'coerce': _coerce.to_strvec}}
        doc = {'stokes': stokes}
        assert _pc.validate(doc,schema), str(_pc.errors)
        return self._swigobj.setstokes([_str_encode(_x) for _x in _pc.document['stokes']])

    def settabular(self, pixel=[ float(-1) ], world=[ float(-1) ], which=int(0)):
        """When you construct a Coordsys tool, if you include a Tabular
        Coordinate, it will be linear.  This function allows you to replace the
        Tabular Coordinate by a finite table of values.  Coordinate conversions
        between pixel and world are then done by interpolation (or extrapolation
        beyond the end).  The table of values must be at least of length 2
        or an exception will occur.
        
        You may specify a vector of pixel and world values (in the current units
        of the Tabular Coordinate).  These vectors must be the same length.  If
        you leave one of them unset, then the old values are used, but again,
        ultimately, the pixel and world vectors must be the same length.
        
        The new reference pixel will be the first pixel value.
        The new reference value will be the first world value.
        
        Presently, there is no way for you to recover the lookup table
        once you have set it.
        
        If you have more than one Tabular Coordinate, use argument
        {stfaf which} to specify which one you want to modify.
        """
        schema = {'pixel': {'type': 'cFloatVec', 'coerce': _coerce.to_floatvec}, 'world': {'type': 'cFloatVec', 'coerce': _coerce.to_floatvec}, 'which': {'type': 'cInt'}}
        doc = {'pixel': pixel, 'world': world, 'which': which}
        assert _pc.validate(doc,schema), str(_pc.errors)
        return self._swigobj.settabular(_pc.document['pixel'], _pc.document['world'], _pc.document['which'])

    def settelescope(self, value):
        """This function sets a new telescope of the observation.   The telescope
        position may be needed for reference code conversions; this is why it is
        maintained in the Coordinate System.    So it is fundamental
        to the Coordinate System and should be correct.
        
        You can find a list of the observatory names know to casa with the
        Measures obslist function.
        
        You can  get the current telescope with function
        telescope.
        """
        schema = {'value': {'type': 'cStr'}}
        doc = {'value': value}
        assert _pc.validate(doc,schema), str(_pc.errors)
        return self._swigobj.settelescope(_str_encode(_pc.document['value']))

    def setunits(self, value, type='', overwrite=False, which=int(-10)):
        """Each axis associated with the Coordinate System has a unit. This
        function allows you to set new axis units.
        
        You can set the units either for all axes ({stfaf
        type=unset}) or for just the axes associated with a particular
        coordinate type.
        
        In general, the units must be consistent with the old units. When you
        change the units, the increment and reference value will be adjusted
        appropriately.  However, for a linear or tabular coordinate, and only
        when you specify {stfaf type='linear'} or {stfaf type='tabular'}
        (i.e. you supply units only for the specified linear of tabular
        coordinate), and if you set {stfaf overwrite=T}, you can just overwrite
        the units with no further adjustments.   Otherwise, the {stfaf
        overwrite} argument will be silently ignored.  Use argument
        {stfaf which} to specify which coordinate if you have more
        than one of the specified type.
        
        You can recover the current axis units with function
        units.
        """
        schema = {'value': {'type': 'cStrVec', 'coerce': _coerce.to_strvec}, 'type': {'type': 'cStr'}, 'overwrite': {'type': 'cBool'}, 'which': {'type': 'cInt'}}
        doc = {'value': value, 'type': type, 'overwrite': overwrite, 'which': which}
        assert _pc.validate(doc,schema), str(_pc.errors)
        return self._swigobj.setunits([_str_encode(_x) for _x in _pc.document['value']], _str_encode(_pc.document['type']), _pc.document['overwrite'], _pc.document['which'])

    def stokes(self):
        """If the Coordinate System contains a Stokes Coordinate, this function recovers the
        Stokes types defining it.  If there is no Stokes
        Coordinate, an exception is generated.
        
        You can set the Stokes types with function
        setstokes.
        """
        return self._swigobj.stokes()

    def summary(self, doppler='RADIO', list=True):
        """This function summarizes the information
        contained in the Coordinate System.
        
        For spectral coordinates, the information is listed as a velocity as well as a
        frequency.  The argument {stfaf doppler} allows you to specify what
        doppler convention it is listed in.  You can choose from {stfaf radio,
        optical} and {stfaf beta}.  Alternative names are {stfaf z} for
        {stfaf optical}, and {stfaf relativistic} for {stfaf
        beta}.  The default is {stfaf radio}.  The definitions are
        
        begin{itemize}
        item radio: $1 - F$
        item optical: $-1 + 1/F$
        item beta: $(1 - F^2)/(1 + F^2)$
        end{itemize}
        where $F = nu/nu_0$ and $nu_0$ is the rest frequency.  If the rest
        frequency has not been set in your image, you can set it with
        the function setrestfrequency.
        
        These velocity definitions are provided by the measures
        system via the Doppler measure (see example).
        
        If you  set {stfaf list=F}, then the summary will not be written
        to the global logger.     However, the return value will be a vector of strings
        holding the summary information, one string per line of the summary.
        
        For direction and spectral coordinates, the reference frame (e.g.  J2000
        or LSRK) is also listed.  Along side this, in parentheses, will be the
        conversion reference frame as well (if it is different from the native
        reference frame).  See function
        setconversion to see what this
        means.
        """
        schema = {'doppler': {'type': 'cStr'}, 'list': {'type': 'cBool'}}
        doc = {'doppler': doppler, 'list': list}
        assert _pc.validate(doc,schema), str(_pc.errors)
        return self._swigobj.summary(_str_encode(_pc.document['doppler']), _pc.document['list'])

    def telescope(self):
        """This function returns the telescope
        contained in the Coordinate System  as a
        simple string.
        
        The telescope position may be needed for reference code conversions; this is
        why it is maintained in the Coordinate System.
        
        The conversion from string to position is done with
        Measures observatory.
        The example shows how.
        """
        return self._swigobj.telescope()

    def toabs(self, value=[ ], isworld=int(-1)):
        """This function converts a relative coordinate to an absolute coordinate.
        The coordinate may be a pixel coordinate or a world coordinate.
        
        If the coordinate is a pixel coordinate, it is supplied as a numeric
        vector. If the coordinate is a world coordinate,  you may give it in all
        of the formats described in the
        htmlref{formatting}{COORDSYS:FORMATTING} discussion.
        
        If the coordinate value is supplied by a Coordsys tool function (e.g.
        toworld) then the coordinate 'knows'
        whether it is world or pixel (and absolute or relative). However, you
        might supply the value from some other source as a numeric vector (which
        could be world or pixel) in which case you must specify whether it is a
        world or pixel coordinate via the {stfaf isworld} argument.
        """
        schema = {'value': {'type': 'cVariant'}, 'isworld': {'type': 'cInt'}}
        doc = {'value': value, 'isworld': isworld}
        assert _pc.validate(doc,schema), str(_pc.errors)
        return self._swigobj.toabs(_pc.document['value'], _pc.document['isworld'])

    def toabsmany(self, value=[ ], isworld=int(-1)):
        """This function converts many relative coordinates to absolute. It exists
        so you can efficiently make many conversions (which would be rather slow
        if you did them all with toabs). Because
        speed is the object, the interface is purely in terms of numeric
        matrices, rather than being able to accept strings and quanta etc. like
        toabs can.
        
        When dealing with world coordinates, the units of the numeric
        values must be the native units, given by function
        units.
        """
        schema = {'value': {'type': 'cVariant'}, 'isworld': {'type': 'cInt'}}
        doc = {'value': value, 'isworld': isworld}
        assert _pc.validate(doc,schema), str(_pc.errors)
        return self._swigobj.toabsmany(_pc.document['value'], _pc.document['isworld'])

    def topixel(self, value=[ ]):
        """This function converts between world (physical) coordinate and absolute pixel
        coordinate (0-rel).
        
        The world coordinate can be provided in one of four formats via the
        argument {stfaf world}.  These match the output formats of function
        toworld.
        
        If you supply fewer world values than there are axes in the  Coordinate
        System, your coordinate vector will be padded out with the reference
        value for the missing axes. Excess values will be silently ignored.
        
        You may supply the world coordinate in all of the formats described in
        the htmlref{formatting}{COORDSYS:FORMATTING} discussion.
        """
        schema = {'value': {'type': 'cVariant'}}
        doc = {'value': value}
        assert _pc.validate(doc,schema), str(_pc.errors)
        return self._swigobj.topixel(_pc.document['value'])

    def topixelmany(self, value=[ ]):
        """This function converts many absolute world coordinates to pixel coordinates. It exists
        so you can efficiently make many conversions (which would be rather slow
        if you did them all with topixel). Because
        speed is the object, the interface is purely in terms of numeric
        matrices, rather than being able to accept strings and quanta etc. like
        topixel can.
        
        The units of the numeric values must be the native units, given by
        function units.
        """
        schema = {'value': {'type': 'cVariant'}}
        doc = {'value': value}
        assert _pc.validate(doc,schema), str(_pc.errors)
        return self._swigobj.topixelmany(_pc.document['value'])

    def torecord(self):
        """You can convert a Coordinate System to a record with this function.
        There is also fromrecord
        to set a Coordinate System from a record.
        
        These functions  allow
        Coordsys tools to be used as parameters in the methods of other tools.
        """
        return self._swigobj.torecord()

    def subimage(self, originshft=[ ], newshape=[  ]):
        """You can convert a Coordinate System to another coordinatesystem applicable to a
        subImage. The newshape does not matter as this is the coordinatesystem not the
        image except for Stokes axis; therefore you can ignore {tt newshape} except
        when your sub-image you are considering has only a section of your original Stokes
        axis.
        """
        schema = {'originshft': {'type': 'cVariant'}, 'newshape': {'type': 'cIntVec', 'coerce': _coerce.to_intvec}}
        doc = {'originshft': originshft, 'newshape': newshape}
        assert _pc.validate(doc,schema), str(_pc.errors)
        return self._swigobj.subimage(_pc.document['originshft'], _pc.document['newshape'])

    def torel(self, value=[ ], isworld=int(-1)):
        """This function converts an absolute coordinate to a relative coordinate.
        The coordinate may be a pixel coordinate or a world coordinate.
        
        Relative coordinates are relative to the reference pixel (pixel coordinates)
        or the reference value (world coordinates) in the sense
        $relative = absolute - reference$.
        
        If the coordinate is a pixel coordinate, it is supplied as a numeric
        vector. If the coordinate is a world coordinate,  you may give it in all
        of the formats described in the
        htmlref{formatting}{COORDSYS:FORMATTING} discussion.
        
        If the coordinate value is supplied by a Coordsys tool function (e.g.
        toworld) then the coordinate 'knows'
        whether it is world or pixel (and absolute or relative). However, you
        might supply the value from some other source as a numeric vector (which
        could be world or pixel) in which case you must specify whether it is a
        world or pixel coordinate via the {stfaf isworld} argument.
        """
        schema = {'value': {'type': 'cVariant'}, 'isworld': {'type': 'cInt'}}
        doc = {'value': value, 'isworld': isworld}
        assert _pc.validate(doc,schema), str(_pc.errors)
        return self._swigobj.torel(_pc.document['value'], _pc.document['isworld'])

    def torelmany(self, value=[ ], isworld=int(-1)):
        """This function converts many absolute coordinates to relative. It exists
        so you can efficiently make many conversions (which would be rather slow
        if you did them all with torel). Because
        speed is the object, the interface is purely in terms of numeric
        matrices, rather than being able to accept strings and quanta etc. like
        torel can.
        
        When dealing with world coordinates, the units of the numeric
        values must be the native units, given by function
        units.
        """
        schema = {'value': {'type': 'cVariant'}, 'isworld': {'type': 'cInt'}}
        doc = {'value': value, 'isworld': isworld}
        assert _pc.validate(doc,schema), str(_pc.errors)
        return self._swigobj.torelmany(_pc.document['value'], _pc.document['isworld'])

    def toworld(self, value=[ ], format='n'):
        """This function converts between absolute pixel coordinate (0-rel)
        and absolute world (physical coordinate).
        
        If you supply fewer pixel values than there are axes in the  Coordinate
        System, your coordinate vector will be padded out with the reference
        pixel for the missing axes. Excess values will be silently ignored.
        
        You may ask for the world coordinate in all of the formats described in
        the htmlref{discussion}{COORDSYS:FORMATTING} regarding the
        formatting possibilities available via argument {stfaf format}.
        """
        schema = {'value': {'type': 'cVariant'}, 'format': {'type': 'cStr'}}
        doc = {'value': value, 'format': format}
        assert _pc.validate(doc,schema), str(_pc.errors)
        return self._swigobj.toworld(_pc.document['value'], _str_encode(_pc.document['format']))

    def toworldmany(self, value=[ ]):
        """This function converts many absolute pixel coordinates to world coordinates. It exists
        so you can efficiently make many conversions (which would be rather slow
        if you did them all with toworld). Because
        speed is the object, the interface is purely in terms of numeric
        matrices, rather than being able to produce strings and quanta etc. like
        toworld can.
        
        The units of the output world values are the native units given by
        function units.
        """
        schema = {'value': {'type': 'cVariant'}}
        doc = {'value': value}
        assert _pc.validate(doc,schema), str(_pc.errors)
        return self._swigobj.toworldmany(_pc.document['value'])

    def type(self):
        """This function returns the string `coordsys'.
        """
        return self._swigobj.type()

    def units(self, type=''):
        """Each axis associated with the Coordinate System has a unit.
        This function returns those units
        (in world axis order).
        
        You can recover the units either for all coordinates (leave {stfaf
        type} unset) or for a specific coordinate type (mimumum match of the
        allowed types will do).  If you ask for a non-existent coordinate an
        exception is generated.
        
        You can set the units with function
        setunits.
        """
        schema = {'type': {'type': 'cStr'}}
        doc = {'type': type}
        assert _pc.validate(doc,schema), str(_pc.errors)
        return self._swigobj.units(_str_encode(_pc.document['type']))

    def velocitytofrequency(self, value, frequnit='', doppler='radio', velunit='km/s'):
        """This function converts velocities
        to frequencies.
        
        The input velocities are specified via a vector of numeric values, a
        specified unit ({stfaf velunit}), and a  velocity doppler definition ({stfaf
        doppler}).
        
        The frequencies are returned in a vector for which you specify the
        units ({stfaf frequnit}).  If you don't give the unit, it is assumed that
        the units are those given by function units
        for the spectral coordinate.
        
        This function will return a fail if there is no spectral coordinate
        in the Coordinate System. See also the function
        frequencytovelocity.
        """
        schema = {'value': {'type': 'cFloatVec', 'coerce': _coerce.to_floatvec}, 'frequnit': {'type': 'cStr'}, 'doppler': {'type': 'cStr'}, 'velunit': {'type': 'cStr'}}
        doc = {'value': value, 'frequnit': frequnit, 'doppler': doppler, 'velunit': velunit}
        assert _pc.validate(doc,schema), str(_pc.errors)
        return self._swigobj.velocitytofrequency(_pc.document['value'], _str_encode(_pc.document['frequnit']), _str_encode(_pc.document['doppler']), _str_encode(_pc.document['velunit']))

    def parentname(self):
        """This function returns the parent image name for `coordsys'.
        """
        return self._swigobj.parentname()

    def setparentname(self, imagename):
        """
        """
        schema = {'imagename': {'type': 'cStr'}}
        doc = {'imagename': imagename}
        assert _pc.validate(doc,schema), str(_pc.errors)
        return self._swigobj.setparentname(_str_encode(_pc.document['imagename']))

