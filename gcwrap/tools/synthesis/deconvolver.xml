<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" ?>
<casaxml xmlns="http://casa.nrao.edu/schema/psetTypes.html"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://casa.nrao.edu/schema/casa.xsd
file:///opt/casa/code/tools/xml/casa.xsd">


  
  <tool name="deconvolver" module="deconvolver">
    <shortdescription>deconvolver tool</shortdescription>
       
    <code>
      <include>tools/synthesis/deconvolver_forward.h</include>
      <private>
	<include>tools/synthesis/deconvolver_private.h</include>
      </private>
    </code>
 
<description>
deconvolver is a tool that deconvolves a known point spread function
from an image.  A {\tt deconvolver} must be constructed for each dirty
image and point spread function for which one wishes to do processing.
Multicple copies of {\tt deconvolver} may be made at any time (provide
they are given different names).
</description>


   <method type="constructor" name="deconvolver">
   <shortdescription>Construct a deconvolver tool</shortdescription>
   
<description>
This is used to construct {\tt deconvolver} tools associated
with a dirty image and point spread function. 
The {\tt deconvolver} tool may then be
used to generate various types of images. Note that
a new executable is started every time the constructor
is called. 

example
mydecon=casac.deconvolver()
mydecon.open('dirty.image', 'psf.image')

</description>
<input>
<!--
     <param type="string" name="dirtyname">
     <description>Dirty image to be processed. Table name.</description>
     <value>dirtyname</value>
     </param>

     <param type="string" name="psfname">
     <description>point spread function to be processed. Table name</description>
     <value></value>
     </param>
-->
</input>
<returns type="casadeconvolver">deconvolver tool</returns>
<example>

deco=casac.deconvolver()
deco.open('3C273XC1.dirty', '3C273XC1.psf')      
deco.clean(model='3C273XC1.clean', niter=10000, gain=0.2)
deco.close()

</example>
</method>

 

 
   <method type="function" name="open">
   <shortdescription>Open a new dirty image and PSF</shortdescription>
   
<description>
Close the current images and open a new dirty image and PSF
instead. The current state of {\tt deconvolver} is retained, except for
the data selection.
</description>
<input>

     <param type="string" name="dirty">
     <description>Dirty image to be processed</description>
     <value></value>
     </param>

     <param type="string" name="psf">
     <description>point spread function to be processed</description>
     <value></value>
     </param>

     <param type="bool" name="warn">
     <description>Produce warning messages if psf is not provided</description>
     <value>true</value>
     </param>
</input>
<returns type="bool"/>
</method>

 
   <method type="function" name="reopen">
   <shortdescription>Reopen the dirty image and PSF</shortdescription>
   
<description>
Close and reopen the current dirty and PSF images, and make
new convolvers and cleaners.  The main benefit of this method
is to flush the residual image and replace it with the dirty image.
</description>
<input>
</input>
<returns type="bool"/>
</method>

 
   <method type="function" name="close">
   <shortdescription>Close the deconvolver tool</shortdescription>
   
<description>
This is used to close {\tt deconvolver} tools. Note that the
data is written to disk. The {\tt deconvolver} process keeps running
until a <link anchor="deconvolver:deconvolver.done.function">done</link> tool function call is performed.
</description>
<returns type="bool"/>
<example>

dc.open('3C273XC1.dirty', '3C273XC1.psf')      
dc.clean(model='3C273XC1.clean');
dc.close()

</example>
</method>

 
   <method type="function" name="done">
   <shortdescription>Terminate the deconvolver process</shortdescription>
   
<description>
This is used to totally stop the {\tt deconvolver} process. It is a good idea
to conserve memory use on your machine by stopping the process once
you no longer need it.
</description>
<returns type="bool"/>
<example>

dc.open('3C273XC1.dirty', '3C273XC1.psf')      
dc.clean(model='3C273XC1.clean');
dc.close()
dc.done()

</example>
</method>

 
   <method type="function" name="summary">
   <shortdescription>Summarize the current state</shortdescription>
   
<description>
Writes a summary of the properties of the deconvolver to the
default logger. This includes:
\begin{itemize}
\item The names of the dirty image and PSF (set in construction or via the
<link anchor="deconvolver:deconvolver.open.function">open</link> function.
\item The current beam fit
\end{itemize}
</description>
<returns type="bool"/>
<example>

dc.open('3C273XC1.dirty', '3C273XC1.psf')      
dc.summary()

</example>
</method>

 
   <method type="function" name="boxmask">
   <shortdescription>Construct a mask from blc, trc</shortdescription>
   
<description>
A mask image is an image with the same shape as the other images but
with values between 0.0 and 1.0 as a pixel value. Mask images are used in
deconvolver to control the region selected in a deconvolution. 

In the Clark CLEAN, the mask image can usefully have any value between
0.0 and 1.0. Intermediate value discourage but do not rule out
selection of clean components in that region. This is accomplished by
multiplying the residual image by the mask prior to entering the minor
cycle. Note that if you do use a mask for the Clark or Hogbom Clean,
it must cover only a quarter of the image. boxmask does not enforce
this requirement.

</description>
<input>

     <param type="string" name="mask">
     <description>name of mask image</description>
     <value></value>
     </param>

     <param type="intArray" name="blc">
     <description>Bottom left corner</description>
     <value>-1</value>
     </param>

     <param type="intArray" name="trc">
     <description>Top right corner</description>
     <value>-1</value>
     </param>

     <param type="any" name="fillvalue">
     <any type="variant"/>
     <description>Value to fill in</description>
     <value>1.0Jy</value>
     </param>

     <param type="any" name="outsidevalue">
     <any type="variant"/>
     <description>outside value</description>
     <value>0.0Jy</value>
     </param>
</input>
<returns type="bool"/>
<example>

dc.boxmask(mask='bigmask', blc=[56,45,1,1], trc=[87,93,4,1])
dc.clean(mask='bigmask', model='3C273XC1.clean.masked', niter=1000)

</example>

Makes the image bigmask, and then sets it to unity for all points in
the region bounded by the blc and trc.  Then cleans using it as the
mask.

</method>

 <method type="function" name="regionmask">
   <shortdescription>Construct a mask image from a region</shortdescription>
   
<description>
A mask image is an image with the same shape as the other images but
with values between 0.0 and 1.0 as a pixel value. Mask images are used in
imager to control the region selected in a deconvolution. 

In  Clark CLEAN, the mask image can usefully have any value between
0.0 and 1.0. Intermediate value is discouraged but do not rule out
selection of clean components in that region. This is accomplished by
multiplying the residual image by the mask prior to entering the minor
cycle. Note that if you do use a mask for the Clark or Hogbom Clean,
it must cover only a quarter of the image. {\tt regionmask} does not enforce
this requirement. 

The function regionmask also allows multiple regions to be used. A record of the regions can be made as in the example below. 

Regions can be made in many different ways using the
<link anchor="images:regionmanager">regionmanager</link> functions. An example
using <link anchor="images:regionmanager.wbox.function">wbox</link> function is given
below. The default regionmanager tool 'rg' can be used for cases the user want to have flexibility in manipulating regions. The {\tt region} parameter takes a record that comes from the regionmanager output.
The parameter boxes allow the user to sent in a list of 4 elements numbers representing blc's and trc's 

If both the parameters, {\tt regions} and {\tt boxes} are used the a union is done with the two sets of region thus defined.



 

</description>
<input>

     <param type="string" name="mask">
     <description>name of mask image</description>
     <value></value>
     </param>

     <param type="record" name="region">
     <description>Region record usually from regionmanager</description>
     <value></value>
     <choice>unset</choice>
     </param>

     <param type="any" name="boxes">
     <description>list of 4 elements lists e.g [[xblc1, yblc1, xtrc1, ytrc1], [[xblc2, yblc2, xtrc2, ytrc2]]  </description>
     <any type="variant"/>
     <value></value>
     </param>
    

     <param type="double" name="value">
     <description>Value to set the mask to</description>
     <value>1.0</value>
     </param>
</input>
<returns type="bool"/>
<example>


Makes a mask  then cleans using it.

dc.open(dirty.image', 'psf.image')
a=[100.0, 100.0, 200, 200.0]
b=[50, 50, 80, 80]
dc.regionmask(mask='bigmask', boxes[a,b])
dc.clean(algorithm='hogbom', mask='bigmask', model='model.clean.masked', niter=1000)

Another example using rg.wbox function: 
ia.open('dirty')
cs:=ia.coordsys()
rg.setcoordinates(cs.record())
r1:=dg.wbox(blc=['173pix', '347pix'], trc=['183pix', '370pix'])
c.regionmask(mask='bigmask',region=r1)

Or using a dict of regions:

r2=rg.wbox(blc=['180pix', '344pix'], trc=['191pix', '369pix'])
r3=rg.wbox(blc=['189pix', '341pix'], trc=['204pix', '364pix'])
regs={"reg1"':r1, "reg2":r2, "reg3":r3}
rec=rg.makeunion(regs)
dc.regionmask(mask='bigmask',region=rec)

If quantities are to be used to define regions the following is a an example

dc.regionmask(mask='joetest',boxes=['15:23:32.902','+05.19.32.089','15:22:28.631','+05.28.52.474'])




</example>
</method>

 
   <method type="function" name="clipimage">
   <shortdescription>Zero all pixels where Stokes I is below
a threshold</shortdescription>
   
<description>
All pixels in the image with Stokes I less than some threshold
are set to zero. This is useful prior to self-calibration where one 
oftens wishes to remove negative pixels from the model. Note that
if the image has polarization information, then the polarized
part of a pixel is also set to zero if Stokes I is less than the
threshold.
</description>
<input>

     <param type="string" name="clippedimage">
     <description>name of clipped image</description>
     <value></value>
     </param>

     <param type="string" name="inputimage">
     <description>name of input image</description>
     <value></value>
     </param>

     <param type="any" name="threshold">
     <any type="variant"/>
     <description>Threshold</description>
     <value>0.0Jy</value>
     </param>
</input>
<returns type="bool"/>
<example>

dc.clipimage(image='clean', threshold='50mJy')
###the ft that model into an MS and do gaincal for e.g

</example>
</method>


 
   <method type="function" name="clarkclean">
   <shortdescription>Make a clean image using the Clark Clean
a threshold</shortdescription>
   
<description>

In the Clark Clean algorithm, the cleaning is split into minor and major
cycles. In the minor cycles only the brightest points are cleaned,
using a subset of the point spread function.  In the major cycle, the
points thus found are subtracted correctly by using an FFT-based
convolution.
</description>
<input>

     <param type="int" name="niter">
     <description>Number of iterations</description>
     <value>1000</value>
     </param>

     <param type="double" name="gain">
     <description>Loop Gain for CLEANing</description>
     <value>0.1</value>
     </param>

     <param type="any" name="threshold">
     <any type="variant"/>
     <description>Flux level at which to stop CLEANing</description>
     <value>0Jy</value>
     </param>

     <param type="bool" name="displayprogress">
     <description>Display the progress of the cleaning?</description>
     <value>false</value>
     </param>

     <param type="string" name="model">
     <description>Name of images</description>
     <value></value>
     </param>

     <param type="string" name="mask">
     <description>Name of mask images used for CLEANing</description>
     <value></value>
     </param>

     <param type="int" name="histbins">
     <description>Number of bins in the pixel-flux histogram</description>
     <value>500</value>
     </param>

     <param type="intArray" name="psfpatchsize">
     <description>Size of PSF for minor cycle</description>
     <value type="vector">
     <value>51</value>
     <value>51</value></value>
     </param>

     <param type="double" name="maxextpsf">
     <description>maximum external sidelobe, used to set depth of minor cycle clean</description>
     <value>0.2</value>
     </param>

     <param type="double" name="speedup">
     <description>Cleaning speedup exponent</description>
     <value>0.0</value>
     </param>

     <param type="int" name="maxnumpix">
     <description>Maximum number of pixels used in each minor cycle</description>
     <value>10000</value>
     </param>

     <param type="int" name="maxnummajcycles">
     <description>Max number of major cycles; -1 = no restrictions</description>
     <value>-1</value>
     </param>

     <param type="int" name="maxnumminoriter">
     <description>Max number of minor iterations; -1 = no restrictions</description>
     <value>-1</value>
     </param>
</input>
<returns type="bool"/>
</method>

  <method type="function" name="fullclarkclean">
   <shortdescription>Make a clean image using the Clark Clean
a threshold</shortdescription>
   
<description>

This is similar to clarkclean except that it accepts casa standard images. I.e it has to have 4 axes with the canonical order of
(direction1, direction2, stokes, spectral). 
This function further will clean more than the quarter of the image if the mask coverage is larger than a quarter of the image size.
It is useful for CLI level parallelization, i.e use imager to make a dirty image and psf and use this function to deconvolve. 
If in doubt use 
<link anchor="deconvolver:deconvolver.clarkclean.function">clarkclean</link>
 
</description>
<input>

     <param type="int" name="niter">
     <description>Number of iterations</description>
     <value>1000</value>
     </param>

     <param type="double" name="gain">
     <description>Loop Gain for CLEANing</description>
     <value>0.1</value>
     </param>

     <param type="any" name="threshold">
     <any type="variant"/>
     <description>Flux level at which to stop CLEANing</description>
     <value>0Jy</value>
     </param>

     <param type="string" name="model">
     <description>Name of model image that will contain the clean components</description>
     <value></value>
     </param>

     <param type="string" name="mask">
     <description>Name of mask image used for CLEANing</description>
     <value></value>
     </param>


     <param type="double" name="cyclefactor">
     <description>Factor to determine how deep to go in a Clark minor cycle</description>
     <value>1.5</value>
     </param>

 
</input>
<returns type="record"/>
</method>
 
   <method type="function" name="dirtyname">
   <shortdescription>Return the name of the dirty-image table</shortdescription>
<returns type="string"/>
   
</method>

 
   <method type="function" name="psfname">
   <shortdescription>Return the name of the PSF-image table</shortdescription>

<returns type="string"/>
   
</method>

 
   <method type="function" name="make">
   <shortdescription>Make an empty image</shortdescription>
   
<description>
Make an empty image with the properties (co-ordinate system etc.)
borrowed from the dirty image.
</description>
<input>

     <param type="string" name="image">
     <description>Name of the new image on the disk</description>
     <value></value>
     </param>

</input>
<returns type="bool"/>
</method>

 
   <method type="function" name="convolve">
   <shortdescription>Convolves an image with the PSF</shortdescription>
   
<description>
Convolves an image (e.g., the model image) with the PSF
</description>
<input>

     <param type="string" name="convolvemodel">
     <description>Name of the output image on the disk to hold the
result of the convolution</description>
     <value></value>
     </param>

     <param type="string" name="model">
     <description>The input image to be convolved with the PSF</description>
     <value></value>
     </param>
</input>
<returns type="bool"/>
</method>

 
   <method type="function" name="makegaussian">
   <shortdescription>Make an image with a single gaussian
component</shortdescription>
   
<description>
Make a model image with the a single gaussian.  The
properties of the output image (e.g. the co-ordinate system, etc.) are
borrowed from the dirty image.

The image is made as follows:

   I(x,y)= Delta function of unit amplitude at (0,0)

   Temp(x,y) = Gaussian(x,y,Amplitude, Center, Sigma, PA)

   I(x,y) = Convovlution of Temp(x,y) with I(x,y).

If {\tt normalize=T} I(x,y) = I(x,y)/(area under the gaussian).

</description>
<input>

     <param type="string" name="gaussianimage">
     <description>Name of the output image on the disk</description>
     <value></value>
     </param>

     <param type="any" name="bmaj">
     <any type="variant"/>
     <description>The major axis of the gaussian</description>
     <value>0rad</value>
     </param>

     <param type="any" name="bmin">
     <any type="variant"/>
     <description>The minor axis of the gaussian</description>
     <value>0rad</value>
     </param>

     <param type="any" name="bpa">
     <any type="variant"/>
     <description>The Position Angle of the gaussian</description>
     <value>0deg</value>
     </param>

     <param type="bool" name="normalize">
     <description>Normalize the area under the gaussian to 1.0?</description>
     <value>true</value>
     </param>

</input>
<returns type="bool"/>
</method>
 
 <method type="function" name="state">
   <shortdescription>Return the ``state'' of the tool</shortdescription>
   
<description>
Prints the name of the Dirty Image and the PSF and the parameters of
the gaussian fitted to the main lobe of the PSF (the ``Clean Beam'').
</description>
<returns type="bool"/>
</method>

 
   <method type="function" name="updatestate">
   <shortdescription>[A GUI builders related function]Update the GUI to reflect the currect state</shortdescription>
   
<description>
Updates the GUI to reflect the currect state of the tool.  This
function is used by toolmanager.  See documentation of the toolmanager
for details about ``methods'' used to update the GUI.
</description>
<input>

     <param type="string" name="f">
     <description>Glish variable for the GUI to be updated</description>
     <value></value>
     </param>

     <param type="string" name="method">
     <description>The method to be used for updating</description>
     <value>DONE</value>
     <value>close</value>
     <value>INIT</value>
     </param>
</input>
<returns type="bool"/>
</method>
 
<method type="function" name="clean">
  <shortdescription>Make a clean image with Hogbom or MultiScale Clean</shortdescription>
  
  <description>
    
    Makes a clean image using either the Hogbom or MultiScale
    algorithms. The MultiScale algorithm is the default. The clean is
    performed on the residual image calculated from the dirty image minus
    the point spread function convolved with the model currently selected.
    Thus if you want to restart a clean, simply set the model to the model
    that was previously produced by clean.
    
    Rather than explicit CLEAN boxes, mask images are used to constrain
    the region that is to be deconvolved. To make mask images,
    use either <link anchor="deconvolver:deconvolver.boxmask.function">boxmask</link> (to define a mask
    via the corner locations blc and trc) or 
    <link anchor="deconvolver:deconvolver.mask.function">mask</link> (to define a mask via
    thresholding an existing image). The default mask is the inner quarter
    of the image.
    
    The CLEAN deconvolution is joint in whatever Stokes parameters are
    present. Thus it searchs for peaks in either $I$ or $I+|V|$ or
    $I+\sqrt{Q^2+U^2+V^2}$, the rationale for the latter two forms being
    to be biased towards finding strongly polarized pixels first (these
    forms are also the maximum eigenvalue of the coherency matrix).  The
    PSF is constrained to be the same in all polarizations (a feature of
    this implementation, not of the Hamaker-Bregman-Sault formalism).
    
    The clean algorithms possible are:
    \begin{description}
    \item[Hogbom] The classic algorithm: delta function units of emission
    are found iteratively by searching for the peak. Each point is
    subtracted from the full residual image using the shifted and scaled
    point spread function.
    
    \item[Multi-Scale] As the Multi-Scale Clean algorithm is quite new,
    we provide entensive information on its use.
    
    In the Multi-scale Clean, the image is cleaned simultaneously with
    several different beams given by the point spread function convolved
    with components of various shapes and sizes.  The components we use in
    this implementation are upside-down paraboloids multiplied by first
    order spheroidal functions (ie, the same functions used in gridding
    Fourier plane data).  The paraboloids are truncated at zero, and the
    multiplication by the spheroidal function results in a smooth shape
    with minimal power at long baselines.  This shape is scaled to the
    component sizes specified in
    <link anchor="deconvolver:deconvolver.setscales.function">setscales</link>.  As these
    functions have finite extent (unlike a Gaussian), they can easily be
    used with mask images.
    
    For each iteration, the scale size which is able to subtract the most
    flux is chosen (but with a caveat, see below).  The model is then
    built up out of the spheroidal functions of the various scale
    sizes. The scale sizes are set by the
    <link anchor="deconvolver:deconvolver.setscales.function">setscales</link> function, which
    will permit the user to specify the scale sizes explicitly, or will
    optionally take the number of scale sizes to clean for and calculate
    the scale sizes themselves from a power law.
    
    Most images deconvolved with Multi-scale Clean will be dominated by
    extended structure, and the largest scale size will initially remove
    the most flux from the dirty image.  As the algorithm reduces the
    residuals on the largest scale, the residuals on the smaller scales
    will also be reduced, even without cleaning on those size scales (a
    falling sea sinks all boats).  However, at some point, the residual
    image will be dominated by features on smaller size scales.  These
    smaller features will be both positive and negative (ie, to correct
    for the largest size scale being the wrong shape for the true emission
    features).  Later in the algorithm, the magnitude of the residuals on
    all scales will be approximately equal.  At this stage, most of the
    deconvolvable flux has been assimilated into the largest scale size
    components and detailed corrections to the large scale components must
    be made.  At this point, the user may consider switching to a faster
    algorithm such as the Clark Clean.
    
    Masking is fully available with Multi-scale Clean.  No component is
    permitted to place any of its wings outside of the user-supplied
    mask.  If the masking were based upon the different scale components'
    center positions, then the large scale components could place their
    wings outside the mask, but the smaller scale components would
    not be able to make fine scale corrections.  Hence, the
    Multi-scale Clean uses a different mask for each different size
    scale internally.  If the mask is too restrictive or the scales
    are too large, the algorithm may not be able to fit the large
    scales into the mask at all, and the user is warned of this
    condition.
    
    Traditional Clean algorithms use a small loop gain such as 0.1 to
    avoid confusing emission and sidelobes when extended emission is
    present.  However, as MultiScale Clean can image large extended
    structure in a single spheroidal component, a loop gain in the range
    0.5 to 1.0 can be used.  If the largest residual oscillates between
    positive and negative with iteration number, as it can for some
    brightness distributions which include point sources, a lower loop
    gain will improve the imaging and the convergence.
    
    A mild bias favoring cleaning small scale emission has been built into
    the Multi-scale algorithm.  To illustrate the requirement of this bias,
    consider the case of a bright point source with very faint extended
    emission.  Each scale may find its optimal component to subtract at
    the position of the bright point source, but each successively larger
    component will integrate more extended flux.  Hence, the largeest
    scale component will be removed from the residuals.  If most of the
    flux were in the point source, then several smaller negative
    components must be subtracted from the largest component, and finally
    the point component itself may be removed after the extended emission
    has been taken care of.  To prevent this situation from occurring,
    we bias the selection of small-sized components.
    
    \end{description}
    
    Note that for all of these functions except fullmsclean, only a
    quarter of the image may be cleaned. If no mask is set, then the
    cleaned region defaults to the inner quarter. If a mask larger than a
    quarter of the image is set, then only the quarter starting at the
    bottom left corner is used. Algorithm fullmsclean will deconvolve the
    entire field. This is useful when performing a limited accuracy 
    deconvolution (as needed for example in wide-field imaging) but will
    diverge if pushed too deep.
    
    The clean threshold may be either absolute ('0.5Jy') or relative
    ('1\%').
    
  </description>
  <input>
    
    <param type="string" name="algorithm">
      <description>Algorithm to use</description>
      <value>fullmsclean</value>
      <value>msclean</value>
      <value>hogbom</value>
    </param>
    
    <param type="int" name="niter">
      <description>Number of Iterations, set to zero for no CLEANing</description>
      <value>1000</value>
    </param>
    
    <param type="double" name="gain">
      <description>Loop Gain for CLEANing, try 0.7 for msclean or fullmsclean</description>
      <value>0.1</value>
    </param>
    
    <param type="any" name="threshold">
      <any type="variant"/>
      <description>Flux level at which to stop CLEANing</description>
      <value>0Jy</value>
    </param>
    
    <param type="bool" name="displayprogress">
      <description>Display progress</description>
      <value>false</value>
    </param>
    
    <param type="string" name="model">
      <description>Name of images</description>
      <value></value>
    </param>
    
    <param type="string" name="mask">
      <description>Name of mask images used for CLEANing</description>
      <value></value>
    </param>
    
  </input>
  
  <returns type="record"/>
  <example>
    
    dc.clean(image='3C273XC1.clean.image', model='3C273XC1.clean.model',
    mask='3C283XC1.mask', niter=1000, gain=0.25, threshold=0.03)

  </example>
</method>

<method type="function" name="naclean">
  <shortdescription>Make a clean image with Hogbom with self masking</shortdescription> 

<description>
  The clean is
  performed on the residual image calculated from the dirty image minus
  the point spread function convolved with the model currently selected.
  Thus if you want to restart a clean, simply set the model to the model
  that was previously produced by clean.
</description>
  <input>
    
    
    <param type="int" name="niter">
      <description>Number of Iterations, set to zero for no CLEANing</description>
      <value>1000</value>
    </param>
    
    <param type="double" name="gain">
      <description>Loop Gain for CLEANing, try 0.7 for msclean or fullmsclean</description>
      <value>0.1</value>
    </param>
    
    <param type="any" name="threshold">
      <any type="variant"/>
      <description>Flux level at which to stop CLEANing</description>
      <value>0Jy</value>
    </param>

    <param type="string" name="model">
      <description>Name of images</description>
      <value></value>
    </param>
    
    <param type="string" name="mask">
      <description>Name of mask images to return region cleaned</description>
      <value></value>
    </param>
    
    <param type="int" name="masksupp">
      <description>Number of pixels on each side of peak to set the memory mask</description>
      <value>3</value>
    </param>
    <param type="string" name="memory">
      <description>this define memory function to use (none, weak, medium, strong)</description>
      <value>medium</value>
      <allowed kind="enum">
       <value>none</value>
       <value>weak</value>
       <value>medium</value>
       <value>strong</value>
     </allowed>
    </param>
    <param type="double" name="numsigma">
      <description>remember positions of peak above this number of sigmas</description>
      <value>5.0</value>
    </param>
  </input>
  

  
  <returns type="record"/>
  <example>
    
    dc.naclean(image='3C273XC1.clean.image', model='3C273XC1.clean.model',
    mask='3C283XC1.mask', niter=1000, gain=0.25, threshold=0.03)

  </example>
</method>


 
   <method type="function" name="setscales">
   <shortdescription>Set the scale sizes for MultiScale Clean</shortdescription>
   
<description>
Set the scale sizes, all required PSF's and Dirty Images for
MultiScale Clean will be calculated.
You can either give the number of scales, in which case the the scale
sizes are set via a power law, or give a vector of scale sizes in pixels.
</description>
<input>

     <param type="string" name="scalemethod">
     <description>Method by which scales are set</description>
     <value>uservector</value>
     <value>nscales</value>
     </param>

     <param type="int" name="nscales">
     <description>Number of scales</description>
     <value>5</value>
     </param>

     <param type="doubleArray" name="uservector">
     <description>Vector of scale sizes to use</description>
     <value type="vector">
     <value>0.0</value>
     <value>3.0</value>
     <value>10.0</value></value>
     </param>
</input>

<returns type="bool"/>
<example>

dc.setscales(6);

</example>
</method>


 
   <method type="function" name="ft">
   <shortdescription>Fourier transform the specified model</shortdescription>
   
<description>
Fourier transform the specified model to an image.
</description>
<input>

     <param type="string" name="model">
     <description>Name of image</description>
     <value></value>
     </param>

     <param type="string" name="transform">
     <description>Name of transform image</description>
     <value></value>
     </param>

</input>

<returns type="bool"/>
<example>

deco.ft(model='3C273XC1.nnls.model', transform='3C273XC1.nnls.model.ft')

</example>
<comments>
Fourier transforms the model in the image 3C273XC1.nnls.model
</comments>
</method>

 
   <method type="function" name="restore">
   <shortdescription>Restore the residuals</shortdescription>
   
<description>
Restore the residuals to a smoothed version of the model. The model
images are convolved with the specified Gaussian beam and then the
residual images are added.  If the beam is not supplied, one will
be fit to the PSF.
</description>
<input>

     <param type="string" name="model">
     <description>Name of input model</description>
     <value></value>
     </param>

     <param type="string" name="image">
     <description>Name of output restored image</description>
     <value></value>
     </param>

     <param type="any" name="bmaj">
     <any type="variant"/>
     <description>Major axis of beam</description>
     <value>0rad</value>
     </param>

     <param type="any" name="bmin">
     <any type="variant"/>
     <description>Minor axis of beam</description>
     <value>0rad</value>
     </param>

     <param type="any" name="bpa">
     <any type="variant"/>
     <value>0deg</value>
     <description>Position angle of beam</description>
     </param>

</input>
<returns type="bool"/>
<example>

deco.restore(model='3C273XC1.clean', image='3C273XC1.clean.restored',
bmaj='2.0arcsec', bmin='2.0arcsec')

</example>
</method>

 
   <method type="function" name="residual">
   <shortdescription>Find the residuals</shortdescription>
   
<description>
Calculate the residuals corresponding to the model.
componentlist. 
</description>
<input>

     <param type="string" name="model">
     <description>Names of input models</description>
     <value></value>
     </param>

     <param type="string" name="image">
     <description>Names of output residual images</description>
     <value></value>
     </param>

</input>
<returns type="bool"/>
<example>

deco.residual(model='3C273XC1.clean', complist='3C273XC1.cl',
image='3C273XC1.clean.residual')

</example>
</method>

 
   <method type="function" name="smooth">
   <shortdescription>smooth the image</shortdescription>
   
<description>
The model image is convolved with the specified Gaussian beam.  By
default (normalize=T), the beam volume is normalized to unity so that
the smoothing is flux preserving. The smoothing used in restoration is
not normalized.
</description>
<input>

     <param type="string" name="model">
     <description>Name of input model</description>
     <value></value>
     </param>

     <param type="string" name="image">
     <description>Name of output smoothed image</description>
     <value></value>
     </param>

     <param type="any" name="bmaj">
     <any type="variant"/>
     <description>Major axis of beam</description>
     <value>0rad</value>
     </param>

     <param type="any" name="bmin">
     <any type="variant"/>
     <description>Minor axis of beam</description>
     <value>0rad</value>
     </param>

     <param type="any" name="bpa">
     <any type="variant"/>
     <description>Position angle of beam</description>
     <value>0deg</value>
     </param>

     <param type="bool" name="normalize">
     <description>Normalize volume of psf to unity</description>
     <value>true</value>
     </param>

</input>
<returns type="bool"/>
<example>

- deco.smooth(model='3C273XC1.clean', image='3C273XC1.clean.restored',
bmaj='2.0arcsec', bmin='2.0arcsec')

</example>
</method>

 
   <method type="function" name="mem">
   <shortdescription>Make the mem image</shortdescription>
   
<description>
Makes a mem image using the Cornwell-Evans algroithm, using either
maximum entropy (entropy) or maxmimum emptiness (emptiness).  The
maximum entropy algorithm is the default.  You can restart a MEM
deconvolution on an existing model image, but the alpha and beta
parameters are not yet saved.

Mask images can be used to restrict where the algorithm puts flux.  A
prior, or bias, image can provide a priori information to the
algorithm and effectively limit the support as well as a mask.  The
prior image can be constructed by smoothing an existing estimate for
the brightness distribution and clipping.  Any pixel values below 1e-6
will be clipped to this level, so zero or negative pixels will not
cause problems.

Currently, only one Stokes parameter may be deconvolved at a time.
Stokes $I$ images can be deconvolved with either maximum entropy 
or maxmimum emptiness.  Stokes $Q$, $U$, or $V$ should be deconvolved
with maxmimum emptiness, which permits negative pixel values.
Joint polarization MEM deconvolution is planned for the future.

The mem entropies possible are:
\begin{description}
\item[entropy]  The smoothness of the image, relative to some
prior (also called default or bias) image is maximized.  
The functional form of the entropy is $H = \sum I ln (I/M)$,
where $I$ is the mem image brightness and $M$ is the prior image.
As the prior image is positive definite, the entropy constrains the mem 
image pixels to be positive, hence only stokes $I$ can be imaged.
\item[emptiness] The number of pixels with absolute value of the flux
greater than the noise level is minimized.  This treats positive
and negative pixel values equally, so it is appropriate for any
Stokes image.
\end{description}

This MEM algorithm works in the image plane (ie, is ignorant of
visibility data), but performs the convolution by multiplication in
the Fourier plane.  Not to be confused with this usage of the term
"image plane", some problems are "image plane" problems, such as a
single dish performing On-The-Fly mapping.  Independent noise is added
at each integration as the beam sweeps over the object (ie, in the
image plane).  This can lead to a noise signal at non-physically large
spatial frequencies.  This non-physical signal can be removed by
convolving the residual image with the PSF.  Also key to this problem
is that the PSF is of finite extent, permitting the deconvolution of
nearly the entire dirty image rather than just the inner quarter.
These options are accessed by setting {\tt imageplane} to T.

</description>
<input>

     <param type="string" name="entropy">
     <description>entropy to use</description>
     <value>emptiness</value>
     <value>entropy</value>
     </param>

     <param type="int" name="niter">
     <description>Number of Iterations, set to zero for no MEMing</description>
     <value>20</value>
     </param>

     <param type="any" name="sigma">
     <any type="variant"/>
     <description>Noise level to try to achieve</description>
     <value>0.001Jy</value>
     </param>

     <param type="any" name="targetflux">
     <any type="variant"/>
     <description>Total image flux to try to achieve</description>
     <value>1.0Jy</value>
     </param>

     <param type="bool" name="constrainflux">
     <description>Use targetflux as a constraint? (or starting flux)</description>
     <value>false</value>
     </param>

     <param type="bool" name="displayprogress">
     <description>Display progress</description>
     <value>false</value>
     </param>

     <param type="string" name="model">
     <description>Name of input/output model image</description>
     <value></value>
     </param>

     <param type="string" name="prior">
     <description>Name of prior (default) image used for mem</description>
     <value></value>
     </param>

     <param type="string" name="mask">
     <description>Mask image restricting emission (all pixels 0 or 1)</description>
     <value></value>
     </param>

     <param type="bool" name="imageplane">
     <description>Is this an image plane problem (like single dish)?</description>
     <value>false</value>
     </param>

</input>

<returns type="bool"/>
<example>

deco.mem(entropy='entropy', niter=30, sigma=0.01, targetflux=10.0,
model='3C273XC1.mem.image', prior='3C283XC1.prior')

</example>
</method>



 
   <method type="function" name="makeprior">
   <shortdescription>Make the mem's prior image, or make a mask</shortdescription>
   
<description>
Makes a prior image for the mem function.  A general way to make a
prior image is to start with a low resolution image, obtained
from a smaller array configuration or a lower frequency observation,
from another image which has been smoothed, or from a single dish
image.  The low resolution image can then be doctored via clipping
and regioning to make it acceptable for the mem function.

Currently, only one Stokes parameter may be used at a time.

</description>
<input>

     <param type="string" name="prior">
     <description>output prior image</description>
     <value></value>
     </param>

     <param type="string" name="templateimage">
     <description>starting point for prior image</description>
     <value></value>
     </param>

     <param type="any" name="lowclipfrom">
     <any type="variant"/>
     <description>Clip any pixel below this level</description>
     <value>0.0Jy</value>
     </param>

     <param type="any" name="lowclipto">
     <any type="variant"/>
     <description>Any clipped pixel will be given this value</description>
     <value>0.0Jy</value>
     </param>

     <param type="any" name="highclipfrom">
     <any type="variant"/>
     <description>Clip any pixel above this level</description>
     <value>9e20Jy</value>
     </param>

     <param type="any" name="highclipto">
     <any type="variant"/>
     <description>Any clipped pixel will be given this value</description>
     <value>9e20Jy</value>
     </param>

     <param type="intArray" name="blc">
     <description>Bottom left hand corner for box; outside box is clipped</description>
     <value>-1</value>
     </param>

     <param type="intArray" name="trc">
     <description>Top right hand corner for box; outside box is clipped</description>
     <value>-1</value>
     </param>

</input>

<returns type="bool"/>
<example>

deco.makeprior(prior='3C283XC1.prior', templateimage='3C283XC1.mem.smooth',
clipfrom='0.01Jy', clipto='0.0001Jy', blc=[100,100], trc=[150,150])

</example>
</method>


<method type="function" name="mtopen">
  <shortdescription>Init : Make a series of images using a Multi-Term Clean algorithm</shortdescription>
  
  <description>
    
    Makes a series of images.

    For N terms in the polynomial, supply a list of 2N-1 Hessian elements (psfs), and the
    scale sizes.
    
  </description>
  <input>

    <param type="int" name="ntaylor">
      <description>Number of terms in the taylor polynomial</description>
      <value>2</value>
    </param>
    
     <param type="doubleArray" name="scalevector">
     <description>Vector of scale sizes to use</description>
     <value type="vector">
     <value>0.0</value>
     <value>3.0</value>
     <value>10.0</value></value>
     </param>

     <param type="stringArray" name="psfs">
     <description>Intpu : List of names of 2N-1 psfs. 
       This is valid only for a Taylor-polynomial model.
     </description>
     <value></value>
     </param>

  </input>
  
  <returns type="bool"/>
  <example>

 xxx    

  </example>
</method>



<method type="function" name="mtclean">
  <shortdescription>Make a series of images using a Multi-Term Clean algorithm</shortdescription>
  
  <description>
    
    Makes a series of images.

    Supply a list of N residual images and a corresponding list of 2N-1 Hessian elements (psfs).
    
    This way, for each field or partial-run, one can choose how many terms to operate with, 
    changing this number depending on the signal-to-noise level. 
 
  </description>
  <input>

     <param type="stringArray" name="residuals">
     <description>Input : List of names of N residual images</description>
     <value></value>
     </param>

     <param type="stringArray" name="models">
     <description>Output : List of names of N model images</description>
     <value></value>
     </param>

    
    <param type="int" name="niter">
      <description>Number of Iterations, set to zero for no CLEANing</description>
      <value>1000</value>
    </param>
    
    <param type="double" name="gain">
      <description>Loop Gain for CLEANing, try 0.7 for msclean or fullmsclean</description>
      <value>0.1</value>
    </param>
    
    <param type="any" name="threshold">
      <any type="variant"/>
      <description>Flux level at which to stop CLEANing</description>
      <value>0Jy</value>
    </param>
    
    <param type="bool" name="displayprogress">
      <description>Display progress</description>
      <value>false</value>
    </param>
    
    <param type="string" name="mask">
      <description>Name of mask images used for CLEANing</description>
      <value></value>
    </param>
    
  </input>
  
  <returns type="record"/>
  <example>

 xxx    

  </example>
</method>



   <method type="function" name="mtrestore">
   <shortdescription>Restore the Multi-Term residuals</shortdescription>
   
<description>

The model images are smoothed by the specified Gaussian beam.
The principal solution is computed from the residuals.
The smoothed models are added to these new residuals. 

This ensures that any undeconvolved source flux has been transformed
into the Taylor-coefficient basis, before being added into the smoothed
Taylor-coefficient model images.

( If the beam is not supplied, one will be fit to the PSF ). 
</description>
<input>

     <param type="stringArray" name="models">
     <description>Input : Name of input model</description>
     <value></value>
     </param>

     <param type="stringArray" name="residuals">
     <description>Input : Name of residual image</description>
     <value></value>
     </param>

     <param type="stringArray" name="images">
     <description>Output : Name of output restored image</description>
     <value></value>
     </param>

     <param type="any" name="bmaj">
     <any type="variant"/>
     <description>Major axis of beam</description>
     <value>0rad</value>
     </param>

     <param type="any" name="bmin">
     <any type="variant"/>
     <description>Minor axis of beam</description>
     <value>0rad</value>
     </param>

     <param type="any" name="bpa">
     <any type="variant"/>
     <value>0deg</value>
     <description>Position angle of beam</description>
     </param>

</input>
<returns type="bool"/>
<example>

deco.restore(model='3C273XC1.clean', image='3C273XC1.clean.restored',
bmaj='2.0arcsec', bmin='2.0arcsec')

</example>
</method>

   <method type="function" name="mtcalcpowerlaw">
   <shortdescription>Interpret Taylor coefficients as a power law, and compute spectral index</shortdescription>
   
<description>

Take ratios of restored images to compute alpha and beta

</description>
<input>

     <param type="stringArray" name="images">
     <description>Input : Names of input restored images</description>
     <value></value>
     </param>

     <param type="stringArray" name="residuals">
     <description>Input : Names of input residuals images ( for error calcs )</description>
     <value></value>
     </param>

     <param type="string" name="alphaname">
     <description>Output : Name of output spectral-index image</description>
     <value></value>
     </param>

     <param type="string" name="betaname">
     <description>Output : Name of output spectral-curvature image</description>
     <value></value>
     </param>

     <param type="any" name="threshold">
     <any type="variant"/>
     <description>Threshold</description>
     <value>0.0Jy</value>
     </param>

     <param type="bool" name="calcerror">
     <description>Calculate an error image for spectral index</description>
     <value>false</value>
     </param>

</input>
<returns type="bool"/>
<example>

deco.restore(model='3C273XC1.clean', image='3C273XC1.clean.restored',
bmaj='2.0arcsec', bmin='2.0arcsec')

</example>
</method>




</tool>



</casaxml>
