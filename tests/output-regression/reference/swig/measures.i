/******************** generated by xml-casa (v2) from measures.xml ******************
********************* c6df19b0ab10f5240b76f86ae90e951a *****************************/
%module measures
%include <casa_typemaps.i>
%feature("kwargs");
%feature("autodoc", "0");

%feature("docstring", "

Summary:
      Show direction measure as a string. 

Description:


dirshow will convert a direction measure to a string

Input Parameters:
    v                         a direction measure value to be converted to string 

Example:

print 't----t dirshow Ex 1 t----'
print me.dirshow(me.direction('venus'))
#[0, 90] deg  VENUS

--------------------------------------------------------------------------------
") dirshow;

%feature("docstring", "

Summary:
    Show a measure as a string 

Description:


show will convert a measure to a string.

All measures are catered for (at this moment {em direction, position, epoch,
radialvelocity, frequency, doppler, baseline, uvw, earthmagnetic} ).

Input Parameters:
    v                         measure value to be converted to string
    refcode                   add the reference code to output

Example:

print 't----t show Ex 1 t----'
print me.show(me.frequency('lsrk', qa.constants('HI')))
#1.42041e+09 Hz LSRK
print me.show(me.frequency('lsrk', qa.constants('HI')), refcode=false)
#1.42041e+09 Hz

--------------------------------------------------------------------------------
") show;

%feature("docstring", "

Summary:
    define an epoch measure

Description:


epoch defines an epoch measure from the CLI. It has to specify a
reference code, an epoch quantity value (see introduction for the
action on a scalar quantity with either a vector or scalar value),

and optionally it can specify an offset, which in itself has to be an
epoch. Allowable reference codes are:
{em UTC TAI LAST LMST GMST1 GAST UT1 UT2 TDT TCG TDB TCB}.
Note that additional ones may become available. Check in casa with:

begin{verbatim}
print 't----t epoch Ex 1 t----'
print me.listcodes(me.epoch())
#{'normal': ['LAST', 'LMST', 'GMST1', 'GAST', 'UT1', 'UT2', 'UTC', 'TAI',
# 'TDT', 'TCG', 'TDB', 'TCB', 'IAT', 'GMST', 'TT', 'ET', 'UT'], 'extra': []}
#
end{verbatim}

See quantity for possible time formats.

Input Parameters:
    rf                        reference code
    v0                        epoch value
    off                       optional offset epoch measure

Example:

print 't----t epoch Ex 2 t----'
print me.epoch('utc','today')
#{'m0': {'value': 54048.861237743055, 'unit': 'd'},
# 'refer': 'UTC',
# 'type': 'epoch'}

--------------------------------------------------------------------------------
") epoch;

%feature("docstring", "

Summary:
    define a direction measure

Description:


direction defines a direction measure from the CLI. It has to specify a
reference code, direction quantity values (see introduction for the action on a
scalar quantity with either a vector or scalar value),

and optionally it can specify an
offset, which in itself has to be a direction. Allowable reference codes are:
{em J2000 JMEAN JTRUE APP B1950 BMEAN BTRUE GALACTIC HADEC AZEL
SUPERGAL ECLIPTIC MECLIPTIC TECLIPTIC MERCURY
VENUS MARS JUPITER SATURN URANUS NEPTUNE PLUTO MOON SUN COMET}.
Note that additional ones may become available. Check in casa with:

begin{verbatim}
print 't----t direction Ex 1 t----'
print me.listcodes(me.direction())
#{'normal': ['J2000', 'JMEAN', 'JTRUE', 'APP', 'B1950', 'BMEAN',
#'BTRUE', 'GALACTIC', 'HADEC', 'AZEL', 'AZELSW', 'AZELNE', 'AZELGEO',
#'AZELSWGEO', 'AZELNEGEO', 'JNAT', 'ECLIPTIC', 'MECLIPTIC',
#'TECLIPTIC', 'SUPERGAL', 'ITRF', 'TOPO', 'ICRS'], 'extra': ['MERCURY',
#'VENUS', 'MARS', 'JUPITER', 'SATURN', 'URANUS', 'NEPTUNE', 'PLUTO',
#'SUN', 'MOON', 'COMET']}
end{verbatim}

The direction quantity values should be longitude(angle) and
latitude(angle) (none needed for planets: the frame epoch defines coordinates).
See quantity for possible angle formats.

Input Parameters:
    rf                        reference code
    v0                        longitude
    v1                        latitude
    off                       optional offset direction measure

Example:

print 't----t direction Ex 2 t----'
print me.direction('j2000','30deg','40deg')
#{'m0': {'value': 0.52359877559829882, 'unit': 'rad'},
# 'm1': {'value': 0.69813170079773168, 'unit': 'rad'},
# 'refer': 'J2000',
# 'type': 'direction'}
#
print me.direction('mars')
#{'m0': {'value': 0.0, 'unit': 'rad'},
# 'm1': {'value': 1.5707963267948966, 'unit': 'rad'},
# 'refer': 'MARS',
# 'type': 'direction'}

--------------------------------------------------------------------------------
") direction;

%feature("docstring", "

Summary:
    get the value of a measure

Description:


getvalue gets the actual implementation value of the measure.

Input Parameters:
    v                         measure (array of measures)

Example:

print 't----t getvalue Ex 1 t----'
b=me.direction('j2000','0deg','80deg')
print me.getvalue(b)
#{'m0': {'value': 0.0, 'unit': 'rad'},
# 'm1': {'value': 1.3962634015954634, 'unit': 'rad'}}

--------------------------------------------------------------------------------
") getvalue;

%feature("docstring", "

Summary:
    get the type of a measure

Description:


gettype gets the actual type of the measure.

Input Parameters:
    v                         measure (array of measures)

Example:

print 't----t gettype Ex 1 t----'
b=me.direction('j2000','0deg','80deg')
print me.getvalue(b)
#{'m0': {'value': 0.0, 'unit': 'rad'},
# 'm1': {'value': 1.3962634015954634, 'unit': 'rad'}}
print me.gettype(b)
#'Direction'

--------------------------------------------------------------------------------
") gettype;

%feature("docstring", "

Summary:
    get the reference code of a measure

Description:


gettype gets the actual reference code of the measure.

Input Parameters:
    v                         measure (array of measures)

Example:

print 't----t getref Ex 1 t----'
b=me.direction('j2000','0deg','80deg')
print me.getvalue(b)
#{'m0': {'value': 0.0, 'unit': 'rad'},
# 'm1': {'value': 1.3962634015954634, 'unit': 'rad'}}
print me.gettype(b)
#'Direction'
print me.getref(b)
#'J2000'

--------------------------------------------------------------------------------
") getref;

%feature("docstring", "

Summary:
    get the offset of a measure

Description:


getoff gets the actual offset of the measure (as a measure) or F if no offset
given.

Input Parameters:
    v                         measure (array of measures)

Example:

print 't----t getoffset Ex 1 t----'
b=me.direction('j2000','0deg','80deg')
print me.getvalue(b)
#{'m0': {'value': 0.0, 'unit': 'rad'},
# 'm1': {'value': 1.3962634015954634, 'unit': 'rad'}}
print me.gettype(b)
#'Direction'
print me.getref(b)
#'J2000'
print me.getoffset(b)
#{}

--------------------------------------------------------------------------------
") getoffset;

%feature("docstring", "

Summary:
    get the current comet name

Description:


cometname gets the name of the current comet (if any).

Example:

print 't----t cometname Ex 1 t----'
print me.cometname()
#Thu Nov 9 21:27:25 2006      WARN :
#Method cometname fails! No Comet table present
#''

--------------------------------------------------------------------------------
") cometname;

%feature("docstring", "

Summary:
    get the current comet table type

Description:


comettype gets the comet table type (apparent or topocentric)

Example:

print 't----t comettype Ex 1 t----'
print me.comettype()
# 'none'

--------------------------------------------------------------------------------
") comettype;

%feature("docstring", "

Summary:
    get the distance of the current comet in the current frame

Description:


cometdist returns the distance in AU of the current comet in the current frame,
as a quantity.  It will return -1 AU on failure!


Example:

print 't----t cometdist Ex 1 t----'
# Directory with several Solar System ephemerides for setjy.
cometdir = os.getenv('CASAPATH').split()[0] + '/data/ephemerides/JPL-Horizons/'
me.framecomet(cometdir + 'Ganymede_55438-56292dUTC.tab')
#  Out[5]: True
me.doframe(me.epoch('utc', '2011/01/03/17:00:00'))
me.doframe(me.observatory('ALMA'))
gandist = me.cometdist()
print gandist
# {'value': 5.1241088343892631, 'unit': 'AU'}

--------------------------------------------------------------------------------
") cometdist;

%feature("docstring", "

Summary:
    get the angular diameter of the current comet in the current frame

Description:


cometdist returns the angular diameter (as seen from Earth) in AU of the current
comet in the current frame, as a quantity.  It will return -1 radians on failure!


Example:

print 't----t cometangdiam Ex 1 t----'
# Directory with several Solar System ephemerides for setjy.
cometdir = os.getenv('CASAPATH').split()[0] + '/data/ephemerides/JPL-Horizons/'
me.framecomet(cometdir + 'Ganymede_55438-56292dUTC.tab')
#  Out[5]: True
me.doframe(me.epoch('utc', '2011/01/03/17:00:00'))
me.doframe(me.observatory('ALMA'))
gad = me.cometangdiam()
print gad
# {'unit': 'rad', 'value': 6.8679673431729014e-06}

--------------------------------------------------------------------------------
") cometangdiam;

%feature("docstring", "

Summary:
    get the current comet table coordinates

Description:


comettopo gets the comet table's topographic coordinates used.

Example:

print 't----t comettopo Ex 1 t----'
print me.comettopo()
#Thu Nov 9 21:45:40 2006      WARN :
#Method comettopo fails!  No Topocentric Comet table present
#{'value': [0.0], 'unit': ''}

--------------------------------------------------------------------------------
") comettopo;

%feature("docstring", "

Summary:
    set the current comet table

Description:


framecomet will put the specified comet table in the frame.

Input Parameters:
    v                         name of a table

Example:

print 't----t framecomet Ex 1 t----'
print me.framecomet('VGEO')
#True
print me.showframe()
#'Frame: VENUS comet between MJD 50802.7 and 50803.1'
print me.cometname()
#'VENUS'
print me.comettype()
#'APP'
print me.doframe(me.epoch('et',qa.quantity('1997/12/20/17:30:0')))
#True
print me.measure(me.direction('comet'),'app')
#{'m0': {'value': -0.94936485919663083, 'unit': 'rad'},
# 'm1': {'value': -0.34710256485894436, 'unit': 'rad'},
# 'refer': 'APP',
# 'type': 'direction'}

--------------------------------------------------------------------------------
") framecomet;

%feature("docstring", "

Summary:
    define a position measure

Description:


position defines a position measure from the CLI. It has to specify a
reference code, position quantity values (see introduction for the action on a
scalar quantity with either a vector or scalar value),

and optionally it can specify an
offset, which in itself has to be a position. Allowable reference codes are:
{em WGS84 ITRF} (World Geodetic System and International Terrestrial
Reference Frame).
Note that additional ones may become available. Check in casa with:

begin{verbatim}
print 't----t position Ex 1 t----'
print me.listcodes(me.position())
#{'normal': ['ITRF', 'WGS84'], 'extra': []}
end{verbatim}

The position quantity values should be either longitude
(angle), latitude(angle) and height(length); or x,y,z (length).
See quantity for possible angle formats.

Input Parameters:
    rf                        reference code
    v0                        longitude or x
    v1                        latitude or y
    v2                        height or z
    off                       optional offset position measure

Example:

print 't----t position Ex 2 t----'
print me.position('wgs84','30deg','40deg','10m')
#{'m0': {'value': 0.52359877559829882, 'unit': 'rad'},
# 'm1': {'value': 0.6981317007977319, 'unit': 'rad'},
# 'm2': {'value': 9.9999999999999982, 'unit': 'm'},
# 'refer': 'WGS84',
# 'type': 'position'}
print me.observatory('ATCA')
#{'m0': {'value': 2.6101423190348916, 'unit': 'rad'},
# 'm1': {'value': -0.5261379196128062, 'unit': 'rad'},
# 'm2': {'value': 6372960.2577234386, 'unit': 'm'},
# 'refer': 'ITRF',
# 'type': 'position'}

###One can use a quantity-vectors  especially when dealing with multiple antenna positions  for e.g for 3 positions

ants=me.position('itrf',qa.quantity([3828763.11,3828746.55, 3828727.43],'m'), qa.quantity([442449.106,442592.14, 442580.12],'m'),
qa.quantity([5064923.01, 5064923.01, 5064923.51],'m'))

print ants

#{'m0': {'unit': 'rad',
#        'value': array([ 0.11504897,  0.11508633,  0.1150838 ])},
# 'm1': {'unit': 'rad',
#        'value': array([ 0.92031276,  0.92031276,  0.92031535])},
# 'm2': {'unit': 'm',
#        'value': array([ 6364639.28758924,  6364639.27051283,  6364627.33064587])},
# 'refer': 'ITRF',
# 'type': 'position'}

--------------------------------------------------------------------------------
") position;

%feature("docstring", "

Summary:
    get position of an observatory

Description:


observatory will give you the position of an observatory as given in the
system. At the time of writing the following observatories are recognised
(but check e.g. the position GUI for currently known ones, or the
me.obslist() tool function):
{em'ALMA' 'ARECIBO' 'ATCA' 'BIMA' 'CLRO' 'DRAO' 'DWL' 'GB' 'GBT' 'GMRT'
'IRAM PDB' 'IRAM_PDB' 'JCMT' 'MOPRA' 'MOST' 'NRAO12M' 'NRAO_GBT' 'PKS'
'SAO SMA' 'SMA' 'VLA' 'VLBA' 'WSRT' 'ATF' 'ATA' 'CARMA' 'ACA' 'OSF'
'OVRO_MMA' 'EVLA' 'ASKAP' 'APEX' 'SMT' 'NRO' 'ASTE' 'LOFAR' 'MeerKAT'
'KAT-7' 'EVN' 'LWA1' 'PAPER_SA' 'PAPER_GB' 'e-MERLIN' 'MERLIN2'
'Effelsberg' 'MWA32T' }.

Input Parameters:
    name                      observatory name - case insensitive

Example:

print 't----t observatory Ex 1 t----'
print me.observatory('ATCA')
#{'m0': {'value': 2.6101423190348916, 'unit': 'rad'},
# 'm1': {'value': -0.5261379196128062, 'unit': 'rad'},
# 'm2': {'value': 6372960.2577234386, 'unit': 'm'},
# 'refer': 'ITRF',
# 'type': 'position'}

--------------------------------------------------------------------------------
") observatory;

%feature("docstring", "

Summary:
    get a list of known observatories

Description:


obslist will give you an array of strings of the
observatories known in the Observatories table.

Example:

print 't----t obslist Ex 1 t----'
print me.obslist()

#['ALMA' 'ARECIBO' 'ATCA' 'BIMA' 'CLRO' 'DRAO' 'DWL' 'GB' 'GBT' 'GMRT'
#'IRAM PDB' 'IRAM_PDB' 'JCMT' 'MOPRA' 'MOST' 'NRAO12M' 'NRAO_GBT' 'PKS'
#'SAO SMA' 'SMA' 'VLA' 'VLBA' 'WSRT' 'ATF' 'ATA' 'CARMA' 'ACA' 'OSF'
#'OVRO_MMA' 'EVLA' 'ASKAP' 'APEX' 'SMT' 'NRO' 'ASTE' 'LOFAR' 'MeerKAT'
#'KAT-7' 'EVN' 'LWA1' 'PAPER_SA' 'PAPER_GB' 'e-MERLIN' 'MERLIN2'
#'Effelsberg' 'MWA32T']

--------------------------------------------------------------------------------
") obslist;

%feature("docstring", "

Summary:
    get a list of known spectral lines

Description:


linelist will give you a string with a space separated list of spectral lines
known in the Lines table.

A number of lines are available now, but tables with many lines are
already online, and will be interfaced once a nomenclature can be defined for
the tens of thousands of lines.

Example:

print 't----t linelist Ex 1 t----'
print me.linelist()
#'C109A CI CII166A DI H107A H110A H138B H166A H240A H272A
# H2CO HE110A HE138B HI OH1612 OH1665 OH1667 OH1720'

--------------------------------------------------------------------------------
") linelist;

%feature("docstring", "

Summary:
    get frequency of a spectral line

Description:


spectralline will give you the frequency of a spectral line. The known list
can be obtained by me.linelist().

Input Parameters:
    name                      name

Example:

print 't----t spectralline Ex 1 t----'
print me.spectralline('HI')
#{'m0': {'value': 1420405751.786, 'unit': 'Hz'},
# 'refer': 'REST',
# 'type': 'frequency'}

--------------------------------------------------------------------------------
") spectralline;

%feature("docstring", "

Summary:
    get a list of known sources

Description:


sourcelist will give you a string with the space separated list of sources
known in the Sources table.

Example:

print 't----t sourcelist Ex 1 t----'
print me.sourcelist()[0:62]
#'0002-478 0003+380 0003-066 0007+106 0007+171 0008-264 0008-421'
#......

--------------------------------------------------------------------------------
") sourcelist;

%feature("docstring", "

Summary:
    get direction of a source

Description:


source will give you the direction of a source. The known list
can be obtained by me.sourcelist().

Input Parameters:
    name                      name

Example:

print 't----t source Ex 1 t----'
print me.source()
print me.source('1934-638')
#  Out[19]:
#{'m0': {'value': -1.1370073467795063, 'unit': 'rad'},
# 'm1': {'value': -1.1119959323803881, 'unit': 'rad'},
# 'refer': 'ICRS',
# 'type': 'direction'}

--------------------------------------------------------------------------------
") source;

%feature("docstring", "

Summary:
    define a frequency measure

Description:


frequency defines a frequency measure from the CLI. It has to specify a
reference code, frequency quantity value (see introduction for the action on a
scalar quantity with either a vector or scalar value),

and optionally it can specify an
offset, which in itself has to be a frequency. Allowable reference codes are:
{em REST LSRK LSRD BARY GEO TOPO GALACTO LGROUP CMB}.
Note that additional ones may become available. Check in casa with:
begin{verbatim}
print 't----t frequency Ex 1 t----'
print me.listcodes(me.frequency())
#{'normal': ['REST', 'LSRK', 'LSRD', 'BARY', 'GEO', 'TOPO',
# 'GALACTO', 'LGROUP', 'CMB'], 'extra': []}
end{verbatim}

The frequency quantity values should be in one of the recognised units
(examples all give same frequency):
begin{itemize}
item value with time units: a period (0.5s)
item value as frequency: 2Hz
item value in angular frequency: 720deg/s
item value as length: 149896km
item value as wave number: 4.19169e-8m-1
item value as energy (h.nu): 8.27134e-9ueV
item value as momentum: 4.42044e-42kg.m
end{itemize}

Input Parameters:
    rf                        reference code
    v0                        frequency/wavelength/ldots
    off                       optional offset frequency measure

Example:

print 't----t frequency Ex 2 t----'
print me.frequency('lsrk','5GHz')
#{'m0': {'value': 5000000000.0, 'unit': 'Hz'},
# 'refer': 'LSRK',
# 'type': 'frequency'}
print me.frequency('lsrk','21cm')
#{'m0': {'value': 1427583133.3333333, 'unit': 'Hz'},
# 'refer': 'LSRK',
# 'type': 'frequency'}

--------------------------------------------------------------------------------
") frequency;

%feature("docstring", "

Summary:
    define a doppler measure

Description:


doppler defines a doppler measure from the CLI. It has to specify a
reference code, doppler quantity value (see introduction for the action on a
scalar quantity with either a vector or scalar value),

and optionally it can specify an offset,
which in itself has to be a doppler. Allowable reference codes are:
{em RADIO Z RATIO BETA GAMMA OPTICAL TRUE RELATIVISTIC}.
Note that additional ones may become available. Check in casa with:

begin{verbatim}
print 't----t doppler Ex 1 t----'
print me.listcodes(me.doppler())
#{'normal': ['RADIO', 'Z', 'RATIO', 'BETA', 'GAMMA', 'OPTICAL',
# 'TRUE', 'RELATIVISTIC'], 'extra': []}
end{verbatim}

The doppler quantity values should be either non-dimensioned to specify a
ratio of the light velocity, or in velocity.

Input Parameters:
    rf                        reference code
    v0                        doppler ratio/velocity
    off                       optional offset doppler measure

Example:

Examples both give same doppler:

print 't----t doppler Ex 2 t----'
print me.doppler('radio','0.4')
#{'m0': {'value': 119916983.2, 'unit': 'm/s'},
# 'refer': 'RADIO',
# 'type': 'doppler'}
print me.doppler('radio',qa.mul(qa.quantity('0.4'),qa.constants('c')))
#{'m0': {'value': 119916983.2, 'unit': 'm/s'},
# 'refer': 'RADIO',
# 'type': 'doppler'}

--------------------------------------------------------------------------------
") doppler;

%feature("docstring", "

Summary:
    define a radialvelocity measure

Description:


radialvelocity defines a radialvelocity measure from the CLI. It has to
specify a reference code, radialvelocity quantity value (see introduction for
the action on a
scalar quantity with either a vector or scalar value),

and optionally it
can specify an offset, which in itself has to be a radialvelocity.
Allowable reference codes are:
{em LSRK LSRD BARY GEO TOPO GALACTO LGROUP CMB}.
Note that additional ones may become available. Check in casa with:

begin{verbatim}
print 't----t radialvelocity Ex 1 t----'
print me.listcodes(me.radialvelocity())
#  Out[17]:
#{'extra': [],
# 'normal': ['LSRK', 'LSRD', 'BARY', 'GEO', 'TOPO', 'GALACTO',
# 'LGROUP', 'CMB']}
end{verbatim}
The radialvelocity quantity values should be given as velocity.

Input Parameters:
    rf                        reference code
    v0                        radial velocity
    off                       optional offset radialvelocity measure

Example:

print 't----t radialvelocity Ex 2 t----'
print me.radialvelocity('lsrk','20km/s')
#  Out[18]:
#{'m0': {'value': 20000.0, 'unit': 'm/s'},
# 'refer': 'LSRK',
# 'type': 'radialvelocity'}

--------------------------------------------------------------------------------
") radialvelocity;

%feature("docstring", "

Summary:
    Shift a direction measure by an offset angle at a position angle.

Description:


This method calculates the direction measure located at the specified offset angular amount along the specified
position angle from the specified direction measure.


Input Parameters:
    v                         The direction measure to shift, represented as a record.
    offset                    The angular offset, represented as a quantity record or string.
    pa                        Position angle of the offset, measured from the positive latitude axis through the positive longitude axis.

Example:

v = me.direction('J2000', '13:22:44', '-50.20.20')
# shift along 4 arcminues at a pa of 30 degrees.
offset = me.shift(v, offset='4arcmin', pa='30deg')

--------------------------------------------------------------------------------
") shift;

%feature("docstring", "

Summary:
    define a uvw measure

Description:


uvw defines a uvw measure from the CLI. It has to specify a
reference code, uvw quantity values (see introduction for the action on a
scalar quantity with either a vector or scalar value),  and optionally it can specify an
offset, which in itself has to be a uvw. Allowable reference codes are
ITRF and the direction ones.
Note that additional ones may become available. Check in casa with:
print 't----t uvw Ex 1 t----'
print me.listcodes(me.uvw())
# {'normal': array(['J2000', 'JMEAN', 'JTRUE', 'APP', 'B1950', 'B1950_VLA', 'BMEAN',
'BTRUE', 'GALACTIC', 'HADEC', 'AZEL', 'AZELSW', 'AZELNE', 'AZELGEO',
'AZELSWGEO', 'AZELNEGEO', 'JNAT', 'ECLIPTIC', 'MECLIPTIC',
'TECLIPTIC', 'SUPERGAL', 'ITRF', 'TOPO', 'ICRS'],
dtype='|S10'), 'extra': array([],
dtype='|S1')}

The uvw quantity values should be either longitude
(angle), latitude(angle) and height(length); or x,y,z (length).
See quantity for possible angle formats.

Input Parameters:
    rf                        reference code
    v0                        longitude or x
    v1                        latitude or y
    v2                        height or z
    off                       optional offset uvw measure

Example:

print 't----t uvw Ex 2 t----'
print me.uvw('itrf','30deg','40deg','10m')
#{'m0': {'value': 0.52359877559829882, 'unit': 'rad'},
# 'm1': {'value': 0.6981317007977319, 'unit': 'rad'},
# 'm2': {'value': 9.9999999999999982, 'unit': 'm'},
# 'refer': 'ITRF',
# 'type': 'uvw'}
print me.doframe(me.epoch('utc','today'))
#True
print me.doframe(me.observatory('ALMA'))
#True
print me.doframe(me.direction('mars'))
#True
print me.measure(me.uvw('itrf','30deg','40deg','10m'), 'j2000')
#{'m0': {'value': 0.52321924738347259, 'unit': 'rad'},
# 'm1': {'value': 0.69813169995801672, 'unit': 'rad'},
# 'm2': {'value': 10.0, 'unit': 'm'},
# 'refer': 'J2000',
# 'type': 'uvw'}

--------------------------------------------------------------------------------
") uvw;

%apply record* &OUTARGREC {record* &_dot}
%apply record* &OUTARGREC {record* &_xyz}
%feature("docstring", "

Summary:
    calculate a uvw measure from a baseline

Description:


touvw calculates a uvw measure from a baseline.   Note that the
baseline does not have to be a proper {em baseline}, but can be a
series of positions (to call positions baselines see
asbaseline ) for speed reasons:
operations are linear and can be done on positions, which are
converted to baseline values at the end (with
expand ).

Whatever the reference code of the baseline, the returned {em uvw} will be
given in J2000. If the {em dot} argument is given, that variable
will be filled with a quantity array consisting of the time
derivative of the uvw (note that only the sidereal rate is taken
into account; not precession, earth tides and similar variations,
which are much smaller). If the {em xyz} variable is given, it will
be filled with the quantity values of the uvw measure.

The values of the input baselines can be given as a quantity
vector per x, y or z value.

uvw coordinates are calculated for a certain direction in the sky;
hence the frame has to contain the direction for the calculation to
work. Since the baseline and the sky rotate with respect of each
other, the time should be specified as well.

Input Parameters:
    v                         baseline measure

Output Parameters:
    dot                       uvw-dot (quantity array)
    xyz                       uvw (quantity array)

Example:

print 't----t touvw Ex 1 t----'
print me.doframe(me.observatory('atca'))
#True
print me.doframe(me.source('1934-638'))
#True
print me.doframe(me.epoch('utc',qa.unit('today')))
#True
b=me.baseline('itrf','10m','20m','30m')
print me.touvw(b)
#{'dot': {'unit': 'm/s',
#         'value': [-0.0011912452908351659,
#                   -0.00098731747136827593,
#                   -0.00048769097314181744]},
# 'return': {'m0': {'value': -0.094777304811312649, 'unit': 'rad'},
#            'm1': {'value': -1.1509286139398101, 'unit': 'rad'},
#            'm2': {'value': 37.416573867739416, 'unit': 'm'},
#            'refer': 'J2000',
#            'type': 'uvw'},
# 'xyz': {'unit': 'm',
#         'value': [15.184026188402472,
#                   -1.4434256399579168,
#                   -34.166677788919138]}}
print me.getvalue(me.touvw(b))
#{'m0': {'value': -0.094777304811312649, 'unit': 'rad'},
# 'm1': {'value': -1.1509286139398101, 'unit': 'rad'},
# 'm2': {'value': 37.416573867739416, 'unit': 'm'}}
print me.getvalue(me.touvw(b))['m0']
#{'value': -0.094777304811312649, 'unit': 'rad'}

###Or when you are dealing with multiple antennas
####set the frame..i,e where, direction and when.
me.doframe(me.observatory('VLA'))
me.doframe(me.direction('J2000', '19h20m00', '20d10m00'))
me.doframe(me.epoch('utc', '2007/07/08/20:30:00'))
####antenna positions
ants=me.position('itrf',qa.quantity([3828763.11,3828746.55, 3828727.43],'m'), qa.quantity([442449.106,442592.14, 442580.12],'m'), qa.quantity([5064923.01, 5064923.01, 5064923.51],'m'))
###convert to baseline measures
bl=me.asbaseline(ants)
###convert to uvw
me.touvw(bl)

#{'dot': {'unit': 'm/s',
#         'value': array([ 181.25190155,  -73.29924893,  199.57974846,  181.25985238,
#        -73.29691498,  199.57339353,  181.2583565 ,  -73.29668498,
#        199.57276731])},
# 'return': {'m0': {'unit': 'rad',
#                   'value': array([ 2.21611194,  2.21610131,  2.21609887])},
#            'm1': {'unit': 'rad',
#                   'value': array([ 0.6984441 ,  0.69846521,  0.69846285])},
#            'm2': {'unit': 'm',
#                   'value': array([ 6364639.28758924,  6364639.27051283,  6364627.33064587])},
#            'refer': 'J2000',
#            'type': 'uvw'},
# 'xyz': {'unit': 'm',
#         'value': array([-2931661.69632123,  3894141.52172208,  4092634.20894752,
#       -2931568.34776551,  3894103.64373003,  4092737.08879791,
#       -2931559.14911939,  3894111.22249941,  4092717.89890567])}}


####print the (n-1)n/2 baselines(u,v,w)
me.expand(me.touvw(bl)['return'])['xyz']
#{'unit': 'm',
# 'value': array([  93.34855573,  -37.87799205,  102.8798504 ,  102.54720184,
#        -30.29922267,   83.68995815,    9.19864612,    7.57876938,
#        -19.18989224])}

--------------------------------------------------------------------------------
") touvw;

%apply record* &OUTARGREC {record* &_xyz}
%feature("docstring", "

Summary:
    expand n positions to n*(n-1)/2 baselines

Description:


expand calculates the differences between a series of given measure
values: it calculates baseline values from position values. The
returned value is a measure, but the value of the optional output
variable {em xyz} will be set to an array of values.

Input Parameters:
    v                         measure (baseline, position or uvw measure)

Output Parameters:
    xyz                       uvw (quantity array)

Example:

print 't----t expand Ex 1 t----'
b=me.baseline('itrf', qa.quantity([10, 20, 30], 'm'), qa.quantity([10, 20, 30], 'm'), qa.quantity([0, 0, 0], 'm'))
print me.expand(b)
me.expand(b)

#{'return': {'m0': {'unit': 'rad',
#                   'value': array([ 0.78539816,  0.78539816,  0.78539816])},
#            'm1': {'unit': 'rad', 'value': array([ 0.,  0.,  0.])},
#            'm2': {'unit': 'm',
#                   'value': array([ 14.14213562,  28.28427125,  14.14213562])},
#            'refer': 'ITRF',
#            'type': 'baseline'},
# 'xyz': {'unit': 'm',
#         'value': array([ 10.,  10.,   0.,  20.,  20.,   0.,  10.,  10.,   0.])}}

print me.expand(b)['xyz']['value']

#[ 10.  10.   0.  20.  20.   0.  10.  10.   0.]

--------------------------------------------------------------------------------
") expand;

%feature("docstring", "

Summary:
    define an earthmagnetic measure

Description:


earthmagnetic defines an earthmagnetic measure from the CLI. It needs
a reference code, earthmagnetic quantity values
(see introduction for the action on a
scalar quantity with either a vector or scalar value)  if the reference code is not
for a model, and optionally it
can specify an offset, which in itself has to be a earthmagnetic. In general
you specify a model (IGRF is the default and the only one known) and convert
it to an explicit field.  (See

http://fdd.gsfc.nasa.gov/IGRF.html

for information on the International Geomagnetic Reference Field). The
earthmagnetic quantity values should be either longitude (angle),
latitude(angle) and length(field strength); or x,y,z (field).
See quantity for possible angle formats.

Input Parameters:
    rf                        reference code
    v0                        Field strength
    v1                        longitude
    v2                        latitude
    off                       optional offset earthmagnetic measure

Example:

print 't----t earthmagnetic Ex 1 t----'
print me.earthmagnetic('igrf')
#{'type': 'earthmagnetic', 'refer': 'IGRF', 'm1': {'value': 0.0, 'unit': 'nT'},
# 'm0': {'value': 6.1230317691118855e-23, 'unit': 'nT'},
# 'm2': {'value': 9.9999999999999995e-07, 'unit': 'nT'}}
print me.doframe(me.observatory('atca'))
print me.doframe(me.source('1934-638'))
print me.doframe(me.epoch('utc',qa.unit('today')))
print me.measure(me.earthmagnetic('igrf'), 'j2000')
#{'type': 'earthmagnetic', 'refer': 'J2000',
# 'm1': {'value': -8664.8767628222304, 'unit': 'nT'},
# 'm0': {'value': 50544.054410564473, 'unit': 'nT'},
# 'm2': {'value': 1799.5131920958615, 'unit': 'nT'}}

--------------------------------------------------------------------------------
") earthmagnetic;

%feature("docstring", "

Summary:
    define a baseline measure

Description:


baseline defines a baseline measure from the CLI. It has to specify a
reference code, baseline quantity values (see introduction for the action on a
scalar quantity with either a vector or scalar value, and when a vector of
quantities is given), and optionally it can specify an
offset, which in itself has to be a baseline. Allowable reference codes are
ITRF and the direction ones.
Note that additional ones may become available. Check in casa with:

print 't----t baseline Ex 1 t----'
print me.listcodes(me.baseline())
# {'normal': array(['J2000', 'JMEAN', 'JTRUE', 'APP', 'B1950', 'B1950_VLA', 'BMEAN',
#       'BTRUE', 'GALACTIC', 'HADEC', 'AZEL', 'AZELSW', 'AZELNE', 'AZELGEO',
#       'AZELSWGEO', 'AZELNEGEO', 'JNAT', 'ECLIPTIC', 'MECLIPTIC',
#       'TECLIPTIC', 'SUPERGAL', 'ITRF', 'TOPO', 'ICRS'],
#      dtype='|S10'), 'extra': array([],
#      dtype='|S1')}

The baseline quantity values should be either longitude
(angle), latitude(angle) and height(length); or x,y,z (length).
See quantity for possible angle formats.

Input Parameters:
    rf                        reference code
    v0                        longitude or x
    v1                        latitude or y
    v2                        height or z
    off                       optional offset baseline measure

Example:

print 't----t Ex 2 t----'
print me.baseline('itrf','30deg','40deg','10m')
#{'m0': {'value': 0.52359877559829882, 'unit': 'rad'},
# 'm1': {'value': 0.6981317007977319, 'unit': 'rad'},
# 'm2': {'value': 9.9999999999999982, 'unit': 'm'},
# 'refer': 'ITRF',
# 'type': 'baseline'}
print me.doframe(me.observatory('atca'))
print me.doframe(me.source('1934-638'))
print me.doframe(me.epoch('utc',qa.unit('today')))
print me.measure(me.baseline('itrf','30deg','40deg','10m'), 'J2000')
#{'m0': {'value': 0.58375325605991979, 'unit': 'rad'},
# 'm1': {'value': 0.69758519780286155, 'unit': 'rad'},
# 'm2': {'value': 9.9999999999999964, 'unit': 'm'},
# 'refer': 'J2000',
# 'type': 'baseline'}

--------------------------------------------------------------------------------
") baseline;

%feature("docstring", "

Summary:
    define a baseline from a position measure

Description:


asbaseline converts a position measure into a baseline measure. No
actual baseline is calculated, since operations can be done on
positions, with subtractions to obtain baselines at a later stage.

Input Parameters:
    pos                       position measure

Example:

print 't----t asbaseline Ex 1 t----'

####An example of getting baselines with 3 antenna positions
#### Define the frame ; where, which-direction and when
me.doframe(me.observatory('VLA'))
me.doframe(me.direction('J2000', '19h20m00', '20d10m00'))
me.doframe(me.epoch('utc', '2007/07/08/20:30:00'))

##antenna position
ants=me.position('itrf',qa.quantity([3828763.11,3828746.55, 3828727.43],'m'), qa.quantity([442449.106,442592.14, 442580.12],'m'), qa.quantity([5064923.01, 5064923.01, 5064923.51],'m'))
print ants
#{'type': 'position', 'refer': 'ITRF', 'm1': {'value': array([ 0.92031276,  0.92031276,  0.92031535]), 'unit': 'rad'},
#'m0': {'value': array([ 0.11504897,  0.11508633,  0.1150838 ]), 'unit': 'rad'},
#'m2': {'value': array([ 6364639.28758924,  6364639.27051283,  6364627.33064587]), 'unit': 'm'}}

bl=me.asbaseline(ants)
print bl
#{'type': 'baseline', 'refer': 'J2000', 'm1': {'value': array([ 0.92068328,  0.92068326,  0.92068585]), 'unit': 'rad'},
#'m0': {'value': array([-2.08658811, -2.08655073, -2.08655326]), 'unit': 'rad'},
#'m2': {'value': array([ 6364639.28758924,  6364639.27051283,  6364627.33064587]), 'unit': 'm'}}

me.expand(bl)

#{'return': {'m0': {'unit': 'rad',
#                  'value': array([-0.51637894, -0.36575235,  1.50036599])},
#            'm1': {'unit': 'rad',
#                   'value': array([-0.00060966,  0.00302388,  0.02206414])},
#            'm2': {'unit': 'm',
#                   'value': array([ 143.98943974,  135.78652583,   22.58992696])},
#            'refer': 'J2000',
#            'type': 'baseline'},
# 'xyz': {'unit': 'm',
#         'value': array([  1.25215025e+02,  -7.10925354e+01,  -8.77850493e-02,
#         1.26804339e+02,  -4.85640980e+01,   4.10601842e-01,
#         1.58931410e+00,   2.25284374e+01,   4.98386892e-01])}}

--------------------------------------------------------------------------------
") asbaseline;

%feature("docstring", "

Summary:
    get known reference code names (list indices do not necessarily correspond to enumeration indices)

Description:


listcodes will produce the known reference codes for a specified measure
type. It will return a record with two entries. The first is a string vector
of all normal codes; the second a string vector (maybe empty) with all extra
codes (like planets).
NOTE: Synonyms and different code groups may be present in the code name lists.
The indices in these lists therefore do not necessarily correspond to
the internal CASA enumeration indices.

Input Parameters:
    ms                        the measure type for which to list

Example:

print 't----t listcodes Ex 1 t----'
# Generate some direction
# Note that an empty or non-specified reference code will produce the
# measure with the default code for that measure type
a=me.direction()
print me.getref(a)
#'J2000'
print me.ismeasure(a)
#True
# Get the known reference codes for direction
print me.listcodes(a)
# {'normal': array(['J2000', 'JMEAN', 'JTRUE', 'APP', 'B1950', 'B1950_VLA', 'BMEAN',
#       'BTRUE', 'GALACTIC', 'HADEC', 'AZEL', 'AZELSW', 'AZELNE', 'AZELGEO',
#       'AZELSWGEO', 'AZELNEGEO', 'JNAT', 'ECLIPTIC', 'MECLIPTIC',
#       'TECLIPTIC', 'SUPERGAL', 'ITRF', 'TOPO', 'ICRS'],
#      dtype='|S10'), 'extra': array(['MERCURY', 'VENUS', 'MARS', 'JUPITER', 'SATURN', 'URANUS',
#       'NEPTUNE', 'PLUTO', 'SUN', 'MOON', 'COMET'],
#      dtype='|S8')}

--------------------------------------------------------------------------------
") listcodes;

%feature("docstring", "

Summary:
    convert a measure to another reference

Description:


measure converts measures (epoch, direction etc.) from one reference to
another. It will, for instance, convert a direction from J2000 to AZEL
representation. 
Its arguments are a measure, an output reference code (see the individual
measures for the allowable codes (direction,
position,
epoch,
frequency,
doppler,
radialvelocity,
baseline,
uvw,
earthmagnetic)), and an optional offset of
the same type as the main measure. The offset will be subtracted from the
result before it is returned.
In some cases (see the individual measures for when), more information than
just a reference code is necessary. E.g. the above example of a conversion to
AZEL, needs to know for when, and where on Earth we want it. This information
is stored in a reference frame. Measures are set in the reference frame with
the doframe function. The frame is tool
wide.

{bf IMPORTANT NOTE:}
To get an accurate conversion of solar system objects direction to a celestial frame, one should convert to AZEL or HADEC before to get parallax accounted for. Thus if you want to get the moon's position in J2000..one would do it in 2 stages
i.e (after setting the appropriate frames) 

moonazel=me.measure(me.direction('moon'), 'AZELGEO')
moonJ2000=me.measure(moonazel, 'J2000')

Input Parameters:
    v                         measure to be converted
    rf                        output reference code
    off                       optional output offset measure

Example:

print 't----t measure Ex 1 t----'
a = me.epoch('utc','today')         # a time
print a
#{'m0': {'value': 54054.872957673608, 'unit': 'd'},
# 'refer': 'UTC',
# 'type': 'epoch'}
print me.doframe(me.source('1934-638'))
print me.measure(a, 'tai')# convert to IAT
#{'m0': {'value': 54054.873339618054, 'unit': 'd'},
# 'refer': 'TAI',
# 'type': 'epoch'}
print me.doframe(a)# set time in frame
#True
print me.doframe(me.observatory('ALMA'))# set position in frame
#True
b=me.direction('j2000', qa.toangle('0h'), '-30deg')  # a direction
print b
#{'m0': {'value': 0.0, 'unit': 'rad'},
# 'm1': {'value': -0.52359877559829882, 'unit': 'rad'},
# 'refer': 'J2000',
# 'type': 'direction'}
print me.measure(b, 'azel')# convert to AZEL
#{'m0': {'value': 1.9244096810822324, 'unit': 'rad'},
# 'm1': {'value': 0.76465385681363052, 'unit': 'rad'},
# 'refer': 'AZEL',
# 'type': 'direction'}
print qa.angle(me.getvalue(me.measure(b,'azel'))['m0'])     # show as angles
#['+110.15.38']
print qa.angle(me.getvalue(me.measure(b,'azel'))['m1'])
#['+043.48.41']


Another example:

print 't----t measure Ex 2 t----'
# Fill the frame with necessary information
print me.doframe(me.epoch('utc','today'))
#True
print me.doframe(me.observatory('ALMA'))
#True
print me.doframe(me.direction('mars'))
#True
a=qa.unit('1GHz')
print a
#{'value': 1.0, 'unit': 'GHz'}
m=me.frequency('lsrk',qa.quantity(qa.getvalue(a),qa.getunit(a)))
print m
#{'m0': {'value': 1000000000.0, 'unit': 'Hz'},
# 'refer': 'LSRK',
# 'type': 'frequency'}
print me.measure(m,'lsrd')
#{'m0': {'value': 1000001766.3928765, 'unit': 'Hz'},
# 'refer': 'LSRD',
# 'type': 'frequency'}

--------------------------------------------------------------------------------
") measure;

%feature("docstring", "

Summary:
    save a measure as frame reference

Description:


doframe will set the measure specified as part of a frame.

If conversion from one type to another is necessary,  with the
measure function,
the following frames
should be set if one of the reference types involved in the conversion is as
in the following lists.
{em Epoch}

UTC
TAI
LASTposition
LMST position
GMST1
GAST
UT1
UT2
TDT
TCG
TDB
TCD

{em Direction}

J2000
JMEANepoch
JTRUE epoch
APP epoch
B1950
BMEAN epoch
BTRUE epoch
GALACTIC
HADEC epochposition
AZELepoch position
SUPERGALACTIC
ECLIPTIC
MECLIPTIC      epoch
TECLIPTICepoch
PLANETepoch   [position]

{em Position}

WGS84
ITRF

{em Radial Velocity}

LSRK direction
LSRD direction
BARY direction
GEO directionepoch
TOPO directionepochposition
GALACTOdirection

{em Doppler}

RADIO
OPTICAL
Z
RATIO
RELATIVISTIC
BETA
GAMMA

{em Frequency}

REST directionradialvelocity
LSRK direction
LSRD direction
BARY direction
GEO directionepoch
TOPO directionepochposition
GALACTO

Input Parameters:
    v                         measure to be set in frame

Example:

print 't----t doframe Ex 1 t----'
a = me.epoch('utc', 'today') # a time
print a
#{'m0': {'value': 54054.91671484954, 'unit': 'd'},
# 'refer': 'UTC',
# 'type': 'epoch'}
print me.doframe(a)# set time in frame
#True

--------------------------------------------------------------------------------
") doframe;

%feature("docstring", "

Summary:
    set the active frame time at now

Description:


framenow will fill the active frame time with the current date and time.
The different frame values necessary are described in the
doframe function

Example:

print 't----t framenow Ex 1 t----'
print me.framenow()# specify now as frame reference
#True
print me.showframe()        # and show the current frame
#'Frame: Epoch: 54054::22:01:42.2880'

--------------------------------------------------------------------------------
") framenow;

%feature("docstring", "

Summary:
    show the currently active frame reference

Description:


showframe will display the currently active reference frame values  on the
terminal.  The
different frame values necessary are described in the
doframe function.
The frame is
displayed on the terminal using the formatting as done for the
show function.

Example:

print 't----t showframe Ex 1 t----'
print me.doframe(me.epoch('utc','today'))# specify now as frame reference
#T
print me.showframe()# and show the current frame
#'Frame: Epoch: 54054::22:01:42.2880'

--------------------------------------------------------------------------------
") showframe;

%feature("docstring", "

Summary:
    convert a doppler type value to a real radial velocity

Description:


toradialvelocity will convert a Doppler type value (e.g. in radio mode) to a
real radialvelocity. The type of velocity (e.g. LSRK) should be specified

Input Parameters:
    rf                        radial velocity reference type
    v0                        doppler value measure

Example:

print 't----t toradialvelocity Ex 1 t----'
a = me.doppler('radio','0.4')
print a
#  Out[4]:
#{'m0': {'value': 119916983.2, 'unit': 'm/s'},
# 'refer': 'RADIO',
# 'type': 'doppler'}
print me.toradialvelocity('topo',a)
#{'m0': {'value': 141078803.7647059, 'unit': 'm/s'},
# 'refer': 'TOPO',
# 'type': 'radialvelocity'}

--------------------------------------------------------------------------------
") toradialvelocity;

%feature("docstring", "

Summary:
    convert a doppler type value to a frequency

Description:


tofrequency will convert a Doppler type value (e.g. in radio mode) to a
frequency. The type of frequency (e.g. LSRK) and a rest frequency (either as a
frequency quantity (e.g. qa.constants('HI')) or a frequency measure (e.g.
me.frequency('rest','5100MHz')) should be specified

Input Parameters:
    rf                        frequency reference type
    v0                        doppler measure value
    rfq                       rest frequency (frequency measure or freuency quantity)

Example:

print 't----t tofrequency Ex 1 t----'
a=me.doppler('radio','0.4')
print a
#{'m0': {'value': 119916983.2, 'unit': 'm/s'},
# 'refer': 'RADIO',
# 'type': 'doppler'}
print me.tofrequency('lsrk',a,qa.constants('HI'))
#{'m0': {'value': 852243451.07159996, 'unit': 'Hz'},
# 'refer': 'LSRK',
# 'type': 'frequency'}

--------------------------------------------------------------------------------
") tofrequency;

%feature("docstring", "

Summary:
    convert a frequency or radialvelocity measure to a doppler measure

Description:


todoppler will convert a radialvelocity measure or a frequency measure to a
doppler measure. In the case of a frequency, a rest frequency has to be
specified. The type of doppler wanted (e.g. RADIO) has to be specified.

Input Parameters:
    rf                        doppler reference type
    v0                        radial velocity or frequency measure
    rfq                       rest frequency (frequency measure or frequency quantity)

Example:

print 't----t todoppler Ex 1 t----'
f = me.frequency('lsrk','1410MHz')     # specify a frequency
print f
#{'m0': {'value': 1410000000.0, 'unit': 'Hz'},
# 'refer': 'LSRK',
# 'type': 'frequency'}
print me.todoppler('radio', f, qa.constants('HI')) # give doppler, using HI rest
#{'m0': {'value': 2196249.8401180855, 'unit': 'm/s'},
# 'refer': 'RADIO',
# 'type': 'doppler'}

--------------------------------------------------------------------------------
") todoppler;

%feature("docstring", "

Summary:
    convert a frequency and doppler measure to a rest frequency

Description:


torestfrequency will convert a frequency measure and a doppler measure
(e.g. obtained from another spectral line with a known rest frequency) to a
rest frequency.

Input Parameters:
    v0                        frequency reference type
    d0                        doppler measure value

Example:

print 't----t torestfrequency Ex 1 t----'
dp = me.doppler('radio', '2196.24984km/s')  # a measured doppler speed
print dp
#{'m0': {'value': 2196249.8399999999, 'unit': 'm/s'},
# 'refer': 'RADIO',
# 'type': 'doppler'}
f = me.frequency('lsrk','1410MHz')    # a measured frequency
print f
#{'m0': {'value': 1410000000.0, 'unit': 'Hz'},
# 'refer': 'LSRK',
# 'type': 'frequency'}
print me.torestfrequency(f, dp)                   # the corresponding rest frequency
#{'m0': {'value': 1420405751.7854364, 'unit': 'Hz'},
# 'refer': 'REST',
# 'type': 'frequency'}

--------------------------------------------------------------------------------
") torestfrequency;

%feature("docstring", "

Summary:
    get rise and set sidereal time

Description:


rise will give the rise/set hour-angles of a source. It needs the position
in the frame, and a time. If the latter is not set, the current time will be
used.

Input Parameters:
    crd                       direction of source (direction measure)
    ev                        elevation angle limit

Example:

# NOT IMPLEMENTED
print 't----t rise Ex 1 t----'
print me.rise(me.direction('sun'))
#[rise=[value=267.12445, unit=deg], set=[value=439.029964, unit=deg]]
print qa.form.long(me.rise(me.direction('sun')).rise)
#17:48:29.868
#

--------------------------------------------------------------------------------
") rise;

%feature("docstring", "

Summary:
    get rise and set times

Description:


rise will give the rise/set times of a source. It needs the position
in the frame, and a time. If the latter is not set, the current time will be
used. The returned value is a record with a 'solved' field, which is F if the
source is always below or above the horizon. In that case the rise and set
fields will all have a string value. The record also returns a rise and set
record, with 'last' and 'utc' fields showing the rise and set times as epochs.

Input Parameters:
    crd                       direction of source (direction measure)
    ev                        elevation limit

Example:

# NOT IMPLEMENTED
print 't----t riseset Ex 1 t----'
print me.riseset(me.direction('sun'))
#[solved=T,
# rise=[last=[type=epoch, refer=LAST, m0=[value=0.0731388605, unit=d]],
#       utc=[type=epoch, refer=UTC, m0=[value=52085.8964, unit=d]]],
# set=[last=[type=epoch, refer=LAST, m0=[value=0.455732593, unit=d]],
#       utc=[type=epoch, refer=UTC, m0=[value=52086.2779, unit=d]]]]
print me.riseset(me.direction('sun'), qa.unit('80deg'))
#[solved=F,
# rise=[last=below, utc=below],
# set=[last=below, utc=below]]
print qa.form.long(me.riseset(me.direction('sun')).rise.utc.m0)
#21:30:47.439
#

--------------------------------------------------------------------------------
") riseset;

%feature("docstring", "

Summary:
    get position angle of two directions

Description:


posangle will give the position angle from a direction to another. I.e. the
angle in a direction between the direction to the North pole and the other
direction.
The posiation angle is calculated in the frame of the first argument. m2 is thus converted to the frame of m1 before calculating the position angle.

Input Parameters:
    m1                        direction of source (direction measure)
    m2                        direction of other source (direction measure)

Example:

print 't----t posangle Ex 1 t----'
a=me.direction('j2000','0deg','70deg')
b=me.direction('j2000','0deg','80deg')
print me.posangle(a,b)
#{'value': -0.0, 'unit': 'deg'}
print me.separation(a,b)
#{'value': 9.9999999999999893, 'unit': 'deg'}
tim=me.epoch('utc','today')
print me.doframe(tim)
#True
pos=me.observatory('ATCA')
print me.doframe(pos)
#True
print me.posangle(a,b)
#{'value': -0.0, 'unit': 'deg'}

###Example of how to calculate the parallactic angle of a given direction on thesky.

###set the frames and epoch

--------------------------------------------------------------------------------
") posangle;

%feature("docstring", "

Summary:
    get separation angle between two directions

Description:


separation will give the separation of a direction from another as an angle.

Input Parameters:
    m1                        direction of source (direction measure)
    m2                        direction of other source (direction measure)

Example:

print 't----t separation Ex 1 t----'
a=me.direction('j2000','0deg','70deg')
b=me.direction('j2000','0deg','80deg')
print me.separation(a,b)
#{'value': 9.9999999999999893, 'unit': 'deg'}
tim = me.epoch('utc','today')              # set the time
print me.doframe(tim)
#True
pos = me.observatory('ATCA')               # set where
print me.doframe(pos)
#True
c=me.measure(b,'azel')                     # try with different type
print me.separation(a,c)
#{'value': 10.000000000062277, 'unit': 'deg'}

### the example below is how to calculate
### the parallactic angle
me.doframe(me.epoch('utc','2015/06/30/19:30:40')))
me.doframe(me.observatory('ALMA'))
mydir = me.direction('J2000','17h28m00','-28d00m00' )
#convert direction to AZEL
mydirazel=me.measure(mydir, 'AZEL')
hadecpol=me.direction('HADEC', '00h00m00', '90d00m00')
### no need to convert north pole direction to AZEL
### as it will coverted to the frame of mydirazel
parAngle=me.posangle(mydirazel, hadecpol)

--------------------------------------------------------------------------------
") separation;

%feature("docstring", "

Summary:
    get some additional measure information

Description:


addxvalue will give some additional information about some measures as a vector
of quantities. It is used internally to get the rectangular coordinates of
measures that are normally given in angles. The casual user will probably in
general not interested in this function.

Input Parameters:
    a                         measures for which extra information is to be gotten

Example:

print 't----t addxvalue Ex 1 t----'
a=me.observatory('atca')
print a
#{'m0': {'value': 2.6101423190348916, 'unit': 'rad'},
# 'm1': {'value': -0.5261379196128062, 'unit': 'rad'},
# 'm2': {'value': 6372960.2577234386, 'unit': 'm'},
# 'refer': 'ITRF',
# 'type': 'position'}
print me.addxvalue(a)
#{'value': [-4750915.8370000012, 2792906.1819999996, -3200483.747], 'unit': 'm'}
print me.addxvalue(me.epoch('utc','today'))
#{}

--------------------------------------------------------------------------------
") addxvalue;

%feature("docstring", "

Summary:
    type of tool

Description:


type will return the tool name.

Example:

print 't----t type Ex 1 t----'
print me.type()
#'measures'

--------------------------------------------------------------------------------
") type;

%feature("docstring", "

Summary:
    free resources used by tool.

Description:


In general you will not want to call this method.  It removes and then
recreates the default measures tool.

Example:

print 't----t done Ex 1 t----'
print me.done()
#True

--------------------------------------------------------------------------------
") done;

%feature("docstring", "

Summary:
    Check if measure

Description:


Checks if the operand is a correct measure

Input Parameters:
    v                         value to be tested

Example:

print 't----t ismeasure Ex 1 t----'
x=me.epoch('utc','today')
print x
#{'m0': {'value': 54056.043754386577, 'unit': 'd'},
# 'refer': 'UTC',
# 'type': 'epoch'}
print me.ismeasure(x)
#True
y=me.getvalue(x)
print y
#{'m0': {'value': 54056.043754386577, 'unit': 'd'}}
print me.ismeasure(y)
#False
print 'Last example, exiting!'
exit()

--------------------------------------------------------------------------------
") ismeasure;

%exception {
   try {
      $action
      } catch (const casacore::AipsError &ae) {
         PyErr_SetString(PyExc_RuntimeError, ae.what());
	 //PyErr_Print();
         return NULL;
      }
}
%include "measures_cmpt.h"

%{
#include <exception>
#include <measures_cmpt.h>
%}

