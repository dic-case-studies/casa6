<casaxml xsi:schemaLocation="http://casa.nrao.edu/schema/casa.xsd file:///opt/casa/code/xmlcasa/xml/casa.xsd" xmlns="http://casa.nrao.edu/schema/psetTypes.html" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">


<task type="function" name="deconvolve" category="imaging">

  <shortdescription>Radio Interferometric Image Reconstruction</shortdescription>

  <description>TODO

</description>

  <input>

    <param type="any" name="imagename" required="true">
     <shortdescription>Pre-name of output images</shortdescription>
<description>Pre-name of output images

                       example : imagename='try'

                       Output images will be (a subset of) :

                       try.psf              - Point spread function
                       try.residual      - Residual image
                       try.image         - Restored image
                       try.model         - Model image (contains only flux components)
                       try.sumwt        - Single pixel image containing sum-of-weights.
                                                 (for natural weighting, sensitivity=1/sqrt(sumwt))
                       try.pb              - Primary beam model (values depend on the gridder used)

                       Widefield projection algorithms (gridder=mosaic,awproject) will
                       compute the following images too.
                       try.weight        - FT of gridded weights or the
                                                 un-normalized sum of PB-square (for all pointings)
                                                 Here, PB = sqrt(weight) normalized to a maximum of 1.0

                       For multi-term wideband imaging, all relevant images above will
                       have additional .tt0,.tt1, etc suffixes to indicate Taylor terms,
                       plus the following extra output images.
                       try.alpha            - spectral index
                       try.alpha.error   - estimate of error on spectral index
                       try.beta              - spectral curvature (if nterms \&gt; 2)

                       Tip : Include a directory name in 'imagename' for all
                               output images to be sent there instead of the
                               current working directory : imagename='mydir/try'

                       Tip : Restarting an imaging run without changing 'imagename'
                               implies continuation from the existing model image on disk.
                                - If 'startmodel' was initially specified it needs to be set to &quot;&quot;
                                  for the restart run (or deconvolve will exit with an error message).
                                - By default, the residual image and psf will be recomputed
                                  but if no changes were made to relevant parameters between
                                  the runs, set calcres=False, calcpsf=False to resume directly from
                                  the minor cycle without the (unnecessary) first major cycle.
                                To automatically change 'imagename' with a numerical
                                increment, set restart=False (see deconvolve docs for 'restart').

                        Note : All imaging runs will by default produce restored images.
                                  For a niter=0 run, this will be redundant and can optionally
                                  be turned off via the 'restoration=T/F' parameter.

</description>
      <type>int</type><type>string</type><type>stringVec</type>
      <value type="string"/>
    </param>

    <param name="startmodel" type="any"> 
     <shortdescription>Name of starting model image</shortdescription>
<description>Name of starting model image

                      The contents of the supplied starting model image will be
                      copied to the imagename.model before the run begins.

                      example : startmodel = 'singledish.im'

                      For deconvolver='mtmfs', one image per Taylor term must be provided.
                      example : startmodel = ['try.model.tt0', 'try.model.tt1']
                                      startmodel = ['try.model.tt0']  will use a starting model only
                                                           for the zeroth order term.
                                      startmodel = ['','try.model.tt1']  will use a starting model only
                                                           for the first order term.

                       This starting model can be of a different image shape and size from
                       what is currently being imaged. If so, an image regrid is first triggered
                       to resample the input image onto the target coordinate system.

                       A common usage is to set this parameter equal to a single dish image

                       Negative components in the model image will be included as is.

                      [ Note : If an error occurs during image resampling/regridding,
                                   please try using task imregrid to resample the starting model
                                   image onto a CASA image with the target shape and
                                   coordinate system before supplying it via startmodel ]

 </description>
      <value type="string"/>
    </param>

    <param type="string" name="deconvolver">
      <shortdescription>Minor cycle algorithm (hogbom,clark,multiscale,mtmfs,mem,clarkstokes)</shortdescription>
<description>Name of minor cycle algorithm (hogbom,clark,multiscale,mtmfs,mem,clarkstokes)

                       Each of the following algorithms operate on residual images and psfs
                       from the gridder and produce output model and restored images.
                       Minor cycles stop and a major cycle is triggered when cyclethreshold
                       or cycleniter are reached. For all methods, components are picked from
                       the entire extent of the image or (if specified) within a mask.

                       hogbom : An adapted version of Hogbom Clean [Hogbom, 1974]
                                       - Find the location of the peak residual
                                       - Add this delta function component to the model image
                                       - Subtract a scaled and shifted PSF of the same size as the image
                                         from regions of the residual image where the two overlap.
                                       - Repeat

                       clark : An adapted version of Clark Clean [Clark, 1980]
                                       - Find the location of max(I^2+Q^2+U^2+V^2)
                                       - Add delta functions to each stokes plane of the model image
                                       - Subtract a scaled and shifted PSF within a small patch size
                                         from regions of the residual image where the two overlap.
                                       - After several iterations trigger a Clark major cycle to subtract
                                         components from the visibility domain, but without de-gridding.
                                       - Repeat

                                      ( Note : 'clark' maps to imagermode='' in the old clean task.
                                                   'clark_exp' is another implementation that maps to
                                                    imagermode='mosaic' or 'csclean' in the old clean task
                                                    but the behavior is not identical. For now, please
                                                    use deconvolver='hogbom' if you encounter problems. )

                       clarkstokes : Clark Clean operating separately per Stokes plane

                                  (Note : 'clarkstokes_exp' is an alternate version. See above.)

                       multiscale : MultiScale Clean [Cornwell, 2008]
                                       - Smooth the residual image to multiple scale sizes
                                       - Find the location and scale at which the peak occurs
                                       - Add this multiscale component to the model image
                                       - Subtract a scaled,smoothed,shifted PSF (within a small
                                         patch size per scale) from all residual images
                                       - Repeat from step 2

                       mtmfs : Multi-term (Multi Scale) Multi-Frequency Synthesis [Rau and Cornwell, 2011]
                                       - Smooth each Taylor residual image to multiple scale sizes
                                       - Solve a NTxNT system of equations per scale size to compute
                                         Taylor coefficients for components at all locations
                                       - Compute gradient chi-square and pick the Taylor coefficients
                                          and scale size at the location with maximum reduction in
                                          chi-square
                                       - Add multi-scale components to each Taylor-coefficient
                                         model image
                                       - Subtract scaled,smoothed,shifted PSF (within a small patch size
                                         per scale) from all smoothed Taylor residual images
                                       - Repeat from step 2


                       mem : Maximum Entropy Method [Cornwell and Evans, 1985]
                                       - Iteratively solve for values at all individual pixels via the
                                         MEM method. It minimizes an objective function of
                                          chi-square plus entropy (here, a measure of difference
                                         between the current model and a flat prior model).

                                         (Note : This MEM implementation is not very robust.
                                                      Improvements will be made in the future.)



</description>
      <value type="string">hogbom</value>
      <allowed kind="enum">
              <value>hogbom</value>
              <value>clark</value>
              <value>clarkstokes</value>
              <value>clark_exp</value>
              <value>clarkstokes_exp</value>
              <value>multiscale</value>
              <value>mtmfs</value>
              <value>mem</value>

      </allowed>
    </param>

    <param type="any" name="scales" subparam="true">
           <shortdescription>List of scale sizes (in pixels) for multi-scale algorithms</shortdescription>
     <description>List of scale sizes (in pixels) for multi-scale and mtmfs algorithms.
                                  --&gt;  scales=[0,6,20]
                                  This set of scale sizes should represent the sizes
                                  (diameters in units of number of pixels)
                                  of dominant features in the image being reconstructed.

                                  The smallest scale size is recommended to be 0 (point source),
                                  the second the size of the synthesized beam and the third 3-5
                                  times the synthesized beam, etc. For example, if the synthesized
                                  beam is 10&quot; FWHM and cell=2&quot;,try scales = [0,5,15].

                                  For numerical stability, the largest scale must be
                                  smaller than the image (or mask) size and smaller than or
                                  comparable to the scale corresponding to the lowest measured
                                  spatial frequency (as a scale size much larger than what the
                                  instrument is sensitive to is unconstrained by the data making
                                  it harder to recovery from errors during the minor cycle).
     </description>
      <type>intVec</type><type>doubleVec</type>
      <value type="intVec"/>
    </param>

    <param type="double" name="smallscalebias" subparam="true">
     <shortdescription>Biases the scale selection when using multi-scale or mtmfs deconvolvers </shortdescription>
     <description>A numerical control to bias the scales when using multi-scale or mtmfs algorithms.
                      The peak from each scale's smoothed residual is
                      multiplied by ( 1 - smallscalebias * scale/maxscale )
                      to increase or decrease the amplitude relative to other scales,
                      before the scale with the largest peak is chosen. 
                      Smallscalebias can be varied between -1.0 and 1.0. 
                      A score of 0.0 gives all scales equal weight (default). 
		      A score larger than 0.0 will bias the solution towards smaller scales. 
		      A score smaller than 0.0 will bias the solution towards larger scales.
		      The effect of smallscalebias is more pronounced when using multi-scale relative to mtmfs. 
</description>
      <value type="double">0.0</value>
    </param>


    <param type="bool" name="restoration">
     <shortdescription>Do restoration steps (or not)</shortdescription>
<description> Restore the model image.

                       Construct a restored image : imagename.image by convolving the model
                       image with a clean beam and adding the residual image to the result.
                       If a restoringbeam is specified, the residual image is also
                       smoothed to that target resolution before adding it in.

                       If a .model does not exist, it will make an empty one and create
                       the restored image from the residuals ( with additional smoothing if needed ).
                       With algorithm='mtmfs', this will construct Taylor coefficient maps from
                       the residuals and compute .alpha and .alpha.error.

</description>
      <value type="bool">True</value>
    </param>


    <param type="any" name="restoringbeam" subparam="true">
           <shortdescription>Restoring beam shape to use. Default is the PSF main lobe</shortdescription>
<description> Restoring beam shape/size to use.

                       - restoringbeam='' or ['']
                         A Gaussian fitted to the PSF main lobe (separately per image plane).

                       - restoringbeam='10.0arcsec'
                         Use a circular Gaussian of this width for all planes

                       - restoringbeam=['8.0arcsec','10.0arcsec','45deg']
                         Use this elliptical Gaussian for all planes

                       - restoringbeam='common'
                         Automatically estimate a common beam shape/size appropriate for
                         all planes.

                       Note : For any restoring beam different from the native resolution
                                  the model image is convolved with the beam and added to
                                  residuals that have been convolved to the same target resolution.

</description>
      <type>string</type><type>stringVec</type>
      <value type="stringVec"/>
    </param>

    <param type="bool" name="pbcor" subparam="true">
     <shortdescription>Apply PB correction on the output restored image</shortdescription>
<description> Apply PB correction on the output restored image

                       A new image with extension .image.pbcor will be created from
                       the evaluation of   .image / .pb  for all pixels above the specified pblimit.

                       Note : Stand-alone PB-correction can be triggered by re-running
                                 deconvolve with the appropriate imagename and with
                                 niter=0, calcpsf=False, calcres=False, pbcor=True, vptable='vp.tab'
                                 ( where vp.tab is the name of the vpmanager file.
                                    See the inline help for the 'vptable' parameter )

                       Note : Multi-term PB correction that includes a correction for the
                                 spectral index of the PB has not been enabled for the 4.7 release.
                                 Please use the widebandpbcor task instead.
                                 ( Wideband PB corrections are required when the amplitude of the
                                    brightest source is known accurately enough to be sensitive
                                    to the difference in the PB gain between the upper and lower
                                    end of the band at its location. As a guideline, the artificial spectral
                                    index due to the PB is -1.4 at the 0.5 gain level and less than -0.2
                                    at the 0.9 gain level at the middle frequency )
</description>
      <value type="bool">False</value>
    </param>







    <param type="string" name="outlierfile">
     <shortdescription>Name of outlier-field image definitions</shortdescription>
<description>Name of outlier-field image definitions

                       A text file containing sets of parameter=value pairs,
                       one set per outlier field.

                       Example :   outlierfile='outs.txt'

                                          Contents of outs.txt :

                                                    imagename=tst1
                                                    nchan=1
                                                    imsize=[80,80]
                                                    cell=[8.0arcsec,8.0arcsec]
                                                    phasecenter=J2000 19:58:40.895 +40.55.58.543
                                                    mask=circle[[40pix,40pix],10pix]

                                                    imagename=tst2
                                                    nchan=1
                                                    imsize=[100,100]
                                                    cell=[8.0arcsec,8.0arcsec]
                                                    phasecenter=J2000 19:58:40.895 +40.56.00.000
                                                    mask=circle[[60pix,60pix],20pix]

                          The following parameters are currently allowed to be different between
                          the main field and the outlier fields (i.e. they will be recognized if found
                          in the outlier text file). If a parameter is not listed, the value is picked from
                          what is defined in the main task input.

                              imagename, imsize, cell, phasecenter, startmodel, mask
                              specmode, nchan, start, width, nterms, reffreq,
                              gridder, deconvolver, wprojplanes

                          Note : 'specmode' is an option, so combinations of mfs and cube
                                     for different image fields, for example, are supported.
                                    'deconvolver' and 'gridder' are also options that allow different
                                     imaging or deconvolution algorithm per image field.

                                     For example, multiscale with wprojection and 16 w-term planes
                                     on the main field and mtmfs with nterms=3 and wprojection
                                     with 64 planes on a bright outlier source for which the frequency
                                     dependence of the primary beam produces a strong effect that
                                     must be modeled.   The traditional alternative to this approach is
                                     to first image the outlier, subtract it out of the data (uvsub) and
                                     then image the main field.

                          Note : If you encounter a use-case where some other parameter needs
                                    to be allowed in the outlier file (and it is logical to do so), please
                                    send us feedback. The above is an initial list.

</description>
      <value type="string"/>
    </param>

    <param type="int" name="niter">
     <shortdescription>Maximum number of iterations</shortdescription>
<description>Maximum number of iterations

                       A stopping criterion based on total iteration count.
                       Currently the parameter type is defined as an integer therefore the integer value 
                       larger than 2147483647 will not be set properly as it causes an overflow.

                       Iterations are typically defined as the selecting one flux component
                       and partially subtracting it out from the residual image.

                       niter=0 : Do only the initial major cycle (make dirty image, psf, pb, etc)

                       niter larger than zero : Run major and minor cycles.

                       Note : Global stopping criteria vs major-cycle triggers

                                  In addition to global stopping criteria, the following rules are
                                  used to determine when to terminate a set of minor cycle iterations
                                  and trigger major cycles [derived from Cotton-Schwab Clean, 1984]

                                  'cycleniter' : controls the maximum number of iterations per image
                                                      plane before triggering a major cycle.
                                  'cyclethreshold' : Automatically computed threshold related to the
                                                              max sidelobe level of the PSF and peak residual.
                                   Divergence, detected as an increase of 10% in peak residual from the
                                   minimum so far (during minor cycle iterations)

                                   The first criterion to be satisfied takes precedence.

                       Note :  Iteration counts for cubes or multi-field images :
                                   For images with multiple planes (or image fields) on which the
                                   deconvolver operates in sequence, iterations are counted across
                                   all planes (or image fields). The iteration count is compared with
                                   'niter' only after all channels/planes/fields have completed their
                                   minor cycles and exited either due to 'cycleniter' or 'cyclethreshold'.
                                   Therefore, the actual number of iterations reported in the logger
                                   can sometimes be larger than the user specified value in 'niter'.
                                   For example, with niter=100, cycleniter=20,nchan=10,threshold=0,
                                   a total of 200 iterations will be done in the first set of minor cycles
                                   before the total is compared with niter=100 and it exits.

                        Note : Additional global stopping criteria include
                                  - no change in peak residual across two major cycles
                                  - a 50% or more increase in peak residual across one major cycle


</description>
      <value type="int">0</value>
    </param>

    <param type="double" name="gain" subparam="true">
     <shortdescription>Loop gain</shortdescription>
<description>Loop gain

                       Fraction of the source flux to subtract out of the residual image
                       for the CLEAN algorithm and its variants.

                       A low value (0.2 or less) is recommended when the sky brightness
                       distribution is not well represented by the basis functions used by
                       the chosen deconvolution algorithm. A higher value can be tried when
                       there is a good match between the true sky brightness structure and
                       the basis function shapes.  For example, for extended emission,
                       multiscale clean with an appropriate set of scale sizes will tolerate
                       a higher loop gain than Clark clean (for example).

                       

</description>
      <value type="double">0.1</value>
    </param>

    <param type="any" name="threshold" subparam="true">
     <shortdescription>Stopping threshold </shortdescription>
<description>Stopping threshold (number in units of Jy, or string)

                      A global stopping threshold that the peak residual (within clean mask)
                      across all image planes is compared to.

                      threshold = 0.005  : 5mJy
                      threshold = '5.0mJy'

                      Note : A 'cyclethreshold' is internally computed and used as a major cycle
                                 trigger. It is related what fraction of the PSF can be reliably
                                 used during minor cycle updates of the residual image. By default
                                 the minor cycle iterations terminate once the peak residual reaches
                                 the first sidelobe level of the brightest source.

                                 'cyclethreshold' is computed as follows using the settings in
                                  parameters 'cyclefactor','minpsffraction','maxpsffraction','threshold' :

                                psf_fraction = max_psf_sidelobe_level * 'cyclefactor'
                                psf_fraction = max(psf_fraction, 'minpsffraction');
                                psf_fraction = min(psf_fraction, 'maxpsffraction');
                                cyclethreshold = peak_residual * psf_fraction
                                cyclethreshold = max( cyclethreshold, 'threshold' )

                                If nsigma is set (&gt;0.0), the N-sigma threshold is calculated (see
                                the description under nsigma), then cyclethreshold is further modified as,

                                cyclethreshold = max( cyclethreshold, nsgima_threshold )


                                'cyclethreshold' is made visible and editable only in the
                                interactive GUI when deconvolve is run with interactive=True.
</description>

      <value type="double">0.0</value>
    </param>

    <param type="double" name="nsigma" subparam="true">
     <shortdescription>Multiplicative factor for rms-based threshold stopping</shortdescription>
<description>Multiplicative factor for rms-based threshold stopping

                       N-sigma threshold is calculated as nsigma * rms value per image plane determined
                       from a robust statistics. For nsigma &gt; 0.0, in a minor cycle, a maximum of the two values,
                       the N-sigma threshold and cyclethreshold, is used to trigger a major cycle
                       (see also the descreption under 'threshold').
                       Set nsigma=0.0 to preserve the previous deconvolve behavior without this feature.
                       The top level parameter, fastnoise is relevant for the rms noise calculation which is used 
                       to determine the threshold. 

</description>
      <value type="double">0.0</value>
    </param>

    <param type="double" name="cyclefactor" subparam="true">
     <shortdescription>Scaling on PSF sidelobe level to compute the minor-cycle stopping threshold.</shortdescription>
<description>Scaling on PSF sidelobe level to compute the minor-cycle stopping threshold.

                       Please refer to the Note under the documentation for 'threshold' that
                       discussed the calculation of 'cyclethreshold'

                       cyclefactor=1.0 results in a cyclethreshold at the first sidelobe level of
                       the brightest source in the residual image before the minor cycle starts.

                       cyclefactor=0.5 allows the minor cycle to go deeper.
                       cyclefactor=2.0 triggers a major cycle sooner.

</description>
      <value type="double">1.0</value>
    </param>

    <param type="double" name="minpsffraction" subparam="true">
     <shortdescription>PSF fraction that marks the max depth of cleaning in the minor cycle</shortdescription>
<description>PSF fraction that marks the max depth of cleaning in the minor cycle

                       Please refer to the Note under the documentation for 'threshold' that
                       discussed the calculation of 'cyclethreshold'

                       For example, minpsffraction=0.5 will stop cleaning at half the height of
                       the peak residual and trigger a major cycle earlier.

</description>
      <value type="double">0.05</value>
    </param>

    <param type="double" name="maxpsffraction" subparam="true">
     <shortdescription>PSF fraction that marks the minimum depth of cleaning in the minor cycle </shortdescription>
<description>PSF fraction that marks the minimum depth of cleaning in the minor cycle

                       Please refer to the Note under the documentation for 'threshold' that
                       discussed the calculation of 'cyclethreshold'

                       For example, maxpsffraction=0.8 will ensure that at least the top 20
                       percent of the source will be subtracted out in the minor cycle even if
                       the first PSF sidelobe is at the 0.9 level (an extreme example), or if the
                       cyclefactor is set too high for anything to get cleaned.

</description>
      <value type="double">0.8</value>
    </param>


    <param type="any" name="interactive" subparam="true">
     <shortdescription>Modify masks and parameters at runtime</shortdescription>
<description>Modify masks and parameters at runtime

                       interactive=True will trigger an interactive GUI at every major cycle
                       boundary (after the major cycle and before the minor cycle).

                       The interactive mode is currently not available for parallel cube imaging (please also
                       refer to the Note under the documentation for 'parallel' below).

                       Options for runtime parameter modification are :

                       Interactive clean mask : Draw a 1/0 mask (appears as a contour) by hand.
                                                              If a mask is supplied at the task interface or if
                                                              automasking is invoked, the current mask is
                                                              displayed in the GUI and is available for manual
                                                              editing.

                                                              Note : If a mask contour is not visible, please
                                                                         check the cursor display at the bottom of
                                                                         GUI to see which parts of the mask image
                                                                         have ones and zeros. If the entire mask=1
                                                                         no contours will be visible.


                       Operation buttons :  -- Stop execution now (restore current model and exit)
                                                        -- Continue on until global stopping criteria are reached
                                                           without stopping for any more interaction
                                                        -- Continue with minor cycles and return for interaction
                                                            after the next major cycle.

                       Iteration control : -- max cycleniter :  Trigger for the next major cycle

                                                                                   The display begins with
                                                                                   [ min( cycleniter, niter - itercount ) ]
                                                                                   and can be edited by hand.

                                                    -- iterations left :  The display begins with [niter-itercount ]
                                                                                and can be edited to increase or
                                                                                decrease the total allowed niter.

                                                    -- threshold : Edit global stopping threshold

                                                    -- cyclethreshold : The display begins with the
                                                                                  automatically computed value
                                                                                  (see Note in help for 'threshold'),
                                                                                  and can be edited by hand.

                                                    All edits will be reflected in the log messages that appear
                                                    once minor cycles begin.


                       [ For scripting purposes, replacing True/False with 1/0 will get deconvolve to
                         return an imaging summary dictionary to python ]

</description>
      <type>bool</type><type>int</type>
      <value type="bool">False</value>
    </param>

    <param type="bool" name="plotReport">
           <shortdescription>Plot reported minor cycle changes.</shortdescription>
           <value type="bool">False</value>
<description>Plot reported minor cycle changes. Otherwise, the changes will just be returned as normal.
</description>
    </param>

    <param type="string" name="usemask">
           <shortdescription>Type of mask(s) for deconvolution:  user, pb, or auto-multithresh</shortdescription>

<description>Type of mask(s) to be used for deconvolution

                       user: (default) mask image(s) or user specified region file(s) or string CRTF expression(s)
                         subparameters: mask, pbmask
                       pb: primary beam mask
                         subparameter: pbmask

                           Example: usemask=&quot;pb&quot;, pbmask=0.2
                                             Construct a mask at the 0.2 pb gain level.
                                             (Currently, this option will work only with
                                             gridders that produce .pb (i.e. mosaic and awproject)
                                             or if an externally produced .pb image exists on disk)

                       auto-multithresh : auto-masking by multiple thresholds for deconvolution
                          subparameters : sidelobethreshold, noisethreshold, lownoisethreshold, negativethrehsold,  smoothfactor,
                                          minbeamfrac, cutthreshold, pbmask, growiterations, dogrowprune, minpercentchange, verbose
                          Additional top level parameter relevant to auto-multithresh: fastnoise

                          if pbmask is &gt;0.0, the region outside the specified pb gain level is excluded from
                          image statistics in determination of the threshold.

                      
                       

                       Note: By default the intermediate mask generated by automask at each deconvolution cycle
                             is over-written in the next cycle but one can save them by setting
                             the environment variable, SAVE_ALL_AUTOMASKS=&quot;true&quot;.
                             (e.g. in the CASA prompt, os.environ['SAVE_ALL_AUTOMASKS']=&quot;true&quot; )
                             The saved CASA mask image name will be imagename.mask.autothresh#, where
                             # is the iteration cycle number.

</description>
      <value type="string">user</value>
      <allowed kind="enum">
              <value>user</value>
              <value>pb</value>
              <value>auto-multithresh</value>
      </allowed>
    </param>

    
    <param type="any" name="mask" subparam="true">
     <shortdescription>Mask (a list of image name(s) or region file(s) or region string(s) )</shortdescription>
<description>Mask (a list of image name(s) or region file(s) or region string(s)

    
                       The name of a CASA image or region file or region string that specifies
                       a 1/0 mask to be used for deconvolution. Only locations with value 1 will
                       be considered for the centers of flux components in the minor cycle.
                       If regions specified fall completely outside of the image, deconvolve will throw an error.

                       Manual mask options/examples :

                       mask='xxx.mask'  : Use this CASA image named xxx.mask and containing
                                                       ones and zeros as the mask. 
                                                       If the mask is only different in spatial coordinates from what is being made 
                                                       it will be resampled to the target coordinate system before being used.
                                                       The mask has to have the same shape in velocity and Stokes planes
                                                       as the output image. Exceptions are single velocity and/or single
                                                       Stokes plane masks. They will be expanded to cover all velocity and/or
                                                       Stokes planes of the output cube.

                                                       [ Note : If an error occurs during image resampling or
                                                                   if the expected mask does not appear, please try
                                                                   using tasks 'imregrid' or 'makemask' to resample
                                                                   the mask image onto a CASA image with the target
                                                                   shape and coordinates and supply it via the 'mask'
                                                                   parameter. ]


                       mask='xxx.crtf' : A text file with region strings and the following on the first line
                                                  ( #CRTFv0 CASA Region Text Format version 0 )
                                                  This is the format of a file created via the viewer's region
                                                  tool when saved in CASA region file format.

                       mask='circle[[40pix,40pix],10pix]'  : A CASA region string.

                       mask=['xxx.mask','xxx.crtf', 'circle[[40pix,40pix],10pix]']  : a list of masks


              


                       Note : Mask images for deconvolution must contain 1 or 0 in each pixel.
                                  Such a mask is different from an internal T/F mask that can be
                                  held within each CASA image. These two types of masks are not
                                  automatically interchangeable, so please use the makemask task
                                  to copy between them if you need to construct a 1/0 based mask
                                  from a T/F one.

                       Note : Work is in progress to generate more flexible masking options and
                                  enable more controls.

</description>


      <type>string</type><type>stringVec</type>
      <value type="string"/>
    </param>


    <param type="double" name="pbmask" subparam="true">
     <shortdescription>primary beam mask</shortdescription>
<description>Sub-parameter for usemask='auto-multithresh': primary beam mask

                       Examples : pbmask=0.0 (default, no pb mask)
                                  pbmask=0.2 (construct a mask at the 0.2 pb gain level)

</description>
      <value type="double">0.0</value>
    </param>
    
    
    
    
    <param type="double" name="sidelobethreshold" subparam="true">
           <shortdescription>sidelobethreshold *  the max sidelobe level * peak residual</shortdescription>
           <value type="double">3.0</value>
<description>Sub-parameter for &quot;auto-multithresh&quot;:  mask threshold based on sidelobe levels:  sidelobethreshold * max_sidelobe_level * peak residual

</description>
    </param>

    <param subparam="true" name="noisethreshold" type="double">
    <shortdescription>noisethreshold * rms in residual image + location(median) </shortdescription>
           <value type="double">5.0</value>
<description>Sub-parameter for &quot;auto-multithresh&quot;:  mask threshold based on the noise level: noisethreshold * rms + location (=median)

              The rms is calculated from MAD with rms = 1.4826*MAD.
</description>
    </param>

    <param type="double" name="lownoisethreshold" subparam="true">
    <shortdescription>lownoisethreshold * rms in residual image + location(median) </shortdescription>
           <value type="double">1.5</value>
<description>Sub-parameter for &quot;auto-multithresh&quot;:  mask threshold to grow previously masked regions via binary dilation:   lownoisethreshold * rms in residual image + location (=median)

              The rms is calculated from MAD with rms = 1.4826*MAD.
</description>
    </param>
    <param type="double" name="negativethreshold" subparam="true">
           <shortdescription>negativethreshold * rms in residual image + location(median) </shortdescription>
           <value type="double">0.0</value>
<description>Sub-parameter for &quot;auto-multithresh&quot;: mask threshold  for negative features: -1.0* negativethreshold * rms + location(=median)

              The rms is calculated from MAD with rms = 1.4826*MAD.
</description>
    </param>
    <param type="double" name="smoothfactor" subparam="true">
           <shortdescription>smoothing factor in a unit of the beam</shortdescription>
           <value type="double">1.0</value>
<description>Sub-parameter for &quot;auto-multithresh&quot;:  smoothing factor in a unit of the beam
</description>
    </param>
    <param type="double" name="minbeamfrac" subparam="true">
           <shortdescription>minimum beam fraction for pruning</shortdescription>
           <value type="double">0.3</value>
<description>Sub-parameter for &quot;auto-multithresh&quot;:  minimum beam fraction in size to prune masks smaller than mimbeamfrac * beam
                       &lt;=0.0 : No pruning
</description>
    </param>
    <param type="double" name="cutthreshold" subparam="true">
           <shortdescription>threshold to cut the smoothed mask to create a final mask</shortdescription>
           <value type="double">0.01</value>
<description>Sub-parameter for &quot;auto-multithresh&quot;: threshold to cut the smoothed mask to create a final mask: cutthreshold * peak of the smoothed mask
</description>
    </param>
    <param type="int" name="growiterations" subparam="true">
           <shortdescription>number of binary dilation iterations for growing the mask</shortdescription>
           <value type="int">75</value>
<description>Sub-parameter for &quot;auto-multithresh&quot;: Maximum number of iterations to perform using binary dilation for growing the mask
</description>
    </param>

    <param type="bool" name="dogrowprune" subparam="true">
           <shortdescription>Do pruning on the grow mask</shortdescription>
           <value type="bool">True</value>
<description>Experimental sub-parameter for &quot;auto-multithresh&quot;: Do pruning on the grow mask
</description>
    </param>

    <param type="bool" name="verbose" subparam="true">
           <shortdescription>True: print more automasking information in the logger</shortdescription>
           <value type="bool">False</value>
<description> If it is set to True, the summary of automasking at the end of each automasking process
                        is printed in the logger.  Following information per channel will be listed in the summary.

                        chan: channel number
                        masking?: F - stop updating automask for the subsequent iteration cycles
                        RMS: robust rms noise
                        peak: peak in residual image
                        thresh_type: type of threshold used (noise or sidelobe)
                        thresh_value: the value of threshold used
                        N_reg: number of the automask regions
                        N_pruned: number of the automask regions removed by pruning
                        N_grow: number of the grow mask regions
                        N_grow_pruned: number of the grow mask regions removed by pruning
                        N_neg_pix: number of pixels for negative mask regions

                        Note that for a large cube, extra logging may slow down the process.
</description>
    </param>
    <param type="bool" name="fastnoise">
           <shortdescription>True: use the faster (old) noise calculation. False: use the new improved noise calculations</shortdescription>
           <value type="bool">True</value>
<description> Only relevant when automask (user='multi-autothresh') and/or n-sigma stopping threshold (nsigma&gt;0.0) are/is used. If it is set to True,  a simpler but faster noise calucation is used. 
                        In this case, the threshold values are determined based on classic statistics (using all
                        unmasked pixels for the calculations).
                          
                        If it is set to False,  the new noise calculation
                        method is used based on pre-existing mask.   
 
                        Case 1: no exiting mask
                        Calculate image statistics using Chauvenet algorithm 
                        
                        Case 2: there is an existing mask
                        Calculate image statistics by classical method on the region
                        outside the mask and inside the primary beam mask.

                        In all cases above RMS noise is calculated from MAD. 
</description>
    </param>




    <param type="bool" name="restart">
     <shortdescription>True : Re-use existing images. False : Increment imagename</shortdescription>
<description> Restart using existing images (and start from an existing model image)
                        or automatically increment the image name and make a new image set.

                        True : Re-use existing images. If imagename.model exists the subsequent
                                  run will start from this model (i.e. predicting it using current gridder
                                  settings and starting from the residual image).  Care must be taken
                                  when combining this option with startmodel. Currently, only one or
                                  the other can be used.

                                  startmodel='', imagename.model exists :
                                            - Start from imagename.model
                                  startmodel='xxx', imagename.model does not exist :
                                            - Start from startmodel
                                  startmodel='xxx', imagename.model exists :
                                            - Exit with an error message requesting the user to pick
                                              only one model.  This situation can arise when doing one
                                              run with startmodel='xxx' to produce an output
                                              imagename.model that includes the content of startmodel,
                                              and wanting to restart a second run to continue deconvolution.
                                              Startmodel should be set to '' before continuing.

                                   If any change in the shape or coordinate system of the image is
                                   desired during the restart, please change the image name and
                                   use the startmodel (and mask) parameter(s) so that the old model
                                   (and mask) can be regridded to the new coordinate system before starting.

                         False : A convenience feature to increment imagename with '_1', '_2',
                                    etc as suffixes so that all runs of deconvolve are fresh starts (without
                                    having to change the imagename parameter or delete images).

                                    This mode will search the current directory for all existing
                                    imagename extensions, pick the maximum, and adds 1.
                                    For imagename='try' it will make try.psf, try_2.psf, try_3.psf, etc.

                                    This also works if you specify a directory name in the path :
                                    imagename='outdir/try'.  If './outdir' does not exist, it will create it.
                                    Then it will search for existing filenames inside that directory.

                                    If outlier fields are specified, the incrementing happens for each
                                    of them (since each has its own 'imagename').  The counters are
                                    synchronized across imagefields, to make it easier to match up sets
                                    of output images.  It adds 1 to the 'max id' from all outlier names
                                    on disk.  So, if you do two runs with only the main field
                                   (imagename='try'), and in the third run you add an outlier with
                                   imagename='outtry', you will get the following image names
                                   for the third run :  'try_3' and 'outtry_3' even though
                                   'outry' and 'outtry_2' have not been used.


</description>
      <value type="bool">True</value>
    </param>

    <param type="any" name="iterbot">
      <shortdescription>Used for existing iteration controller</shortdescription>
      <description>The iteration controller. Can be set to use the same iteration controller between
                   major cycles in tclean and minor cycles in deconvolve.

                   Leave or set to None to allow deconvolve to create its own iteration controller.
      </description>
      <value type="any">False</value>
    </param>

   <constraints>

     <when param="deconvolver">
       <equals type="string" value="hogbom">
       </equals>
       <equals type="string" value="clark">
       </equals>
       <equals type="string" value="multiscale">
         <default param="scales"><value type="intVec"/></default>
         <default param="smallscalebias"><value>0.0</value></default>
       </equals>
       <equals type="string" value="mtmfs">
         <default param="scales"><value type="intVec"/></default>
         <!--<default param="nterms"><value>2</value></default>-->
	 <default param="smallscalebias"><value>0.0</value></default>
       </equals>
       <equals type="string" value="aasp">
       </equals>
     </when>

     <when param="restoration">
       <equals type="bool" value="True">
         <default param="restoringbeam"><value type="stringVec"/></default>
         <default param="pbcor"><value>False</value></default>
       </equals>
     </when>

     <when param="niter">
       <notequals type="int" value="0">
         <default param="gain"><value>0.1</value></default>
         <default param="threshold"><value>0.0</value></default>
         <default param="nsigma"><value>0.0</value></default>
         <!--<default param="cycleniter"><value>-1</value></default>-->
         <default param="cyclefactor"><value>1.0</value></default>
         <default param="minpsffraction"><value>0.05</value></default>
         <default param="maxpsffraction"><value>0.8</value></default>
         <default param="interactive"><value>False</value></default>


       </notequals>

     </when>




   <when param="usemask">
       <equals type="string" value="user">
         <default param="mask"><value>&quot;&quot;</value></default>
         <default param="pbmask"><value>0.0</value></default>
       </equals>
       <equals type="string" value="pb">
         <default param="pbmask"><value type="double">0.2</value></default>
       </equals>
       
       
       
       
       
       <equals type="string" value="auto-multithresh">
         <default param="pbmask"><value>0.2</value></default>
         <default param="sidelobethreshold"><value>3.0</value></default>
         <!--<default param="noisethreshold"><value>5.0</value></default>-->
         <default param="lownoisethreshold"><value>1.5</value></default>
         <default param="negativethreshold"><value>0.0</value></default>
         <default param="smoothfactor"><value>1.0</value></default>
         <default param="minbeamfrac"><value type="double">0.3</value></default>
         <default param="cutthreshold"><value>0.01</value></default>
         <default param="growiterations"><value>75</value></default>
         <default param="dogrowprune"><value type="bool">True</value></default>
         <!--<default param="minpercentchange"><value>-1.0</value></default>-->
         <default param="verbose"><value type="bool">False</value></default>
         
       </equals>
       
   </when>



   </constraints>

  </input>

  <returns type="void"/>

  <example>

    Please refer to the CASAdocs pages for the task deconvolve for examples.

  </example>

</task>

</casaxml>
