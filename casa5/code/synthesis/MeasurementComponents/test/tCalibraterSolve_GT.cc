//# tCalibraterSolve_GT:  test Calibrater-conducted solving
//# Copyright (C) 1995,1999,2000,2001,2016
//# Associated Universities, Inc. Washington DC, USA.
//#
//# This program is free software; you can redistribute it and/or modify it
//# under the terms of the GNU General Public License as published by the Free
//# Software Foundation; either version 2 of the License, or (at your option)
//# any later version.
//#
//# This program is distributed in the hope that it will be useful, but WITHOUT
//# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
//# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
//# more details.
//#
//# You should have received a copy of the GNU General Public License along
//# with this program; if not, write to the Free Software Foundation, Inc.,
//# 675 Massachusetts Ave, Cambridge, MA 02139, USA.
//#
//# Correspondence concerning AIPS++ should be addressed as follows:
//#        Internet email: aips2-request@nrao.edu.
//#        Postal address: AIPS++ Project Office
//#                        National Radio Astronomy Observatory
//#                        520 Edgemont Road
//#                        Charlottesville, VA 22903-2475 USA
//#
//# $Id$

#include <casa/aips.h>
#include <casa/Exceptions/Error.h>
#include <casacore/casa/OS/EnvVar.h>
#include <casa/iostream.h>
#include <synthesis/MeasurementComponents/CalSolVi2Organizer.h>
#include <synthesis/MeasurementEquations/VisEquation.h>
#include <synthesis/MeasurementComponents/StandardVisCal.h>
#include <synthesis/MeasurementComponents/MSMetaInfoForCal.h>
#include <synthesis/MeasurementComponents/SolveDataBuffer.h>
#include <synthesis/MeasurementComponents/VisCalSolver2.h>
#include <msvis/MSVis/MSIter2.h>
//#include <msvis/MSVis/SimpleSimVi2.h>
//#include <msvis/MSVis/AveragingVi2Factory.h>
//#include <mstransform/TVI/ChannelAverageTVI.h>
#include <msvis/MSVis/VisBuffer2.h>
#include <casa/Arrays/ArrayMath.h>
#include <casa/Arrays/ArrayLogical.h>
#include <casa/iomanip.h>
#include <gtest/gtest.h>

using namespace std;
using namespace casa;
using namespace casacore;
using namespace casa::vi;

int main(int argc, char **argv) {
  ::testing::InitGoogleTest(&argc, argv);
  return RUN_ALL_TESTS();
}

class genericGatherAndSolveRealDataTests : public ::testing::Test {

public:

  MeasurementSet ms_;
  Calibrater cal_;


  genericGatherAndSolveRealDataTests()
  {
    cout << boolalpha;
    cout.precision(12);

    cout << "Real data tests***************" << endl;

    // Find test dataset
    String *casapath = new String[2];
    split(EnvironmentVariable::get("CASAPATH"), casapath, 2, String(" "));
    // Use of Path().absoluteName() absorbs relative stuff in casapath
    String mspath(Path(casapath[0]+"/data/regression/unittest/flagdata/Four_ants_3C286.ms").absoluteName());
    ms_=MeasurementSet(mspath);

  }
  
};


TEST_F( genericGatherAndSolveRealDataTests , RealData_G ) {

  // Calibrater-driven exercise with real data for genericGatherAndSolve

  // The Calibrater object

  cal_.initialize(ms_,false,false,false);

  //  cal_.selectvis("","11:20,12:20,13:20,15:20","30,31");
  cal_.selectvis("","11","31");


  // the "SVC": a SolvableVisCal object (e.g., GJones) that is the solved-for
  //            term; ordinarily generated by Calibrater::setSolve
  Record solvePar;
  String caltablename("realdata_test.G.11_3s"); solvePar.define("table",caltablename);
  String solint("3.0s");         solvePar.define("solint",solint);
  Double preavg(-1.0);           solvePar.define("preavg",preavg);
  Int minblperant(3);            solvePar.define("minblperant",minblperant);
  Vector<Int> refantlist(1,0);   solvePar.define("refant",refantlist);
  Bool solnorm(False);           solvePar.define("solnorm",solnorm);
  String apmode("ap");           solvePar.define("apmode",apmode);
  String combine("");         solvePar.define("combine",combine);
  cal_.setsolve(String("G"),solvePar);

  // Set an alternate Stokes model?  (smodel in tasks)
  Vector<Double> stokes(4,0.0); stokes(0)=1.0;
  cal_.setModel(stokes);

  // Call the solve (calls genericGatherAndSolve)
  cal_.solve();

  cout << cal_.getActRec() << endl;



}

TEST_F( genericGatherAndSolveRealDataTests , RealData_B ) {

  // Calibrater-driven exercise with real data for genericGatherAndSolve

  cal_.initialize(ms_,false,false,false);
  cal_.selectvis("","","31");  // scan 31 only


  // the "SVC": a SolvableVisCal object (e.g., GJones) that is the solved-for
  //            term; ordinarily generated by Calibrater::setSolve
  Record solvePar;
  String caltablename("realdata_test.B"); solvePar.define("table",caltablename);
  String solint("inf");          solvePar.define("solint",solint);
  Bool solnorm(false);          solvePar.define("solnorm",solnorm);
  Double preavg(-1.0);          solvePar.define("preavg",preavg);
  Int minblperant(3);          solvePar.define("minblperant",minblperant);
  Vector<Int> refantlist(1,0);   solvePar.define("refant",refantlist);

  cal_.setsolve(String("B"),solvePar);

  // Set an alternate Stokes model?  (smodel in tasks)
  Vector<Double> stokes(4,0.0); stokes(0)=1.0;
  cal_.setModel(stokes);

  // Call the solve (calls genericGatherAndSolve)
  cal_.solve();

  cout << cal_.getActRec() << endl;



}

TEST_F( genericGatherAndSolveRealDataTests , RealData_K ) {

  // Calibrater-driven exercise with real data for genericGatherAndSolve

  cal_.initialize(ms_,false,false,false);
  cal_.selectvis("","","31");  // scan 31 only


  // the "SVC": a SolvableVisCal object (e.g., GJones) that is the solved-for
  //            term; ordinarily generated by Calibrater::setSolve
  Record solvePar;
  String caltablename("realdata_test.K"); solvePar.define("table",caltablename);
  String solint("inf");          solvePar.define("solint",solint);
  Bool solnorm(false);          solvePar.define("solnorm",solnorm);
  Double preavg(-1.0);          solvePar.define("preavg",preavg);
  Int minblperant(3);          solvePar.define("minblperant",minblperant);
  Vector<Int> refantlist(1,0);   solvePar.define("refant",refantlist);

  cal_.setsolve(String("K"),solvePar);

  // Set an alternate Stokes model?  (smodel in tasks)
  Vector<Double> stokes(4,0.0); stokes(0)=1.0;
  cal_.setModel(stokes);

  // Call the solve (calls genericGatherAndSolve)
  cal_.solve();

  cout << cal_.getActRec() << endl;

}


TEST_F( genericGatherAndSolveRealDataTests , RealData_preB_G ) {

  // Calibrater-driven exercise with real data for genericGatherAndSolve

  cal_.initialize(ms_,false,false,false);
  cal_.selectvis("","11,12","31");  // scan 31 only

  cal_.setapply("",0.0,"realdata_test.B","","","nearest,nearest",true,Vector<Int>(),Vector<Double>());
  

  // the "SVC": a SolvableVisCal object (e.g., GJones) that is the solved-for
  //            term; ordinarily generated by Calibrater::setSolve
  Record solvePar;
  String caltablename("realdata_preB_test.G"); solvePar.define("table",caltablename);
  String solint("10.0s");          solvePar.define("solint",solint);
  Double preavg(-1.0);          solvePar.define("preavg",preavg);
  Int minblperant(3);          solvePar.define("minblperant",minblperant);
  Vector<Int> refantlist(1,0);   solvePar.define("refant",refantlist);

  cal_.setsolve(String("G"),solvePar);

  // Set an alternate Stokes model?  (smodel in tasks)
  Vector<Double> stokes(4,0.0); stokes(0)=1.0;
  cal_.setModel(stokes);

  // Call the solve (calls genericGatherAndSolve)
  cal_.solve();

  cout << cal_.getActRec() << endl;



}

TEST_F( genericGatherAndSolveRealDataTests , RealData_preB_K ) {

  // Calibrater-driven exercise with real data for genericGatherAndSolve

  cal_.initialize(ms_,false,false,false);
  cal_.selectvis("","","31");  // scan 31 only

  cal_.setapply("",0.0,"realdata_test.B","","","nearest,nearest",true,Vector<Int>(),Vector<Double>());
  

  // the "SVC": a SolvableVisCal object (e.g., GJones) that is the solved-for
  //            term; ordinarily generated by Calibrater::setSolve
  Record solvePar;
  String caltablename("realdata_preB_test.K"); solvePar.define("table",caltablename);
  String solint("inf");          solvePar.define("solint",solint);
  Double preavg(-1.0);          solvePar.define("preavg",preavg);
  Int minblperant(3);          solvePar.define("minblperant",minblperant);
  Vector<Int> refantlist(1,0);   solvePar.define("refant",refantlist);

  cal_.setsolve(String("K"),solvePar);

  // Set an alternate Stokes model?  (smodel in tasks)
  Vector<Double> stokes(4,0.0); stokes(0)=1.0;
  cal_.setModel(stokes);

  // Call the solve (calls genericGatherAndSolve)
  cal_.solve();

  cout << cal_.getActRec() << endl;

}

TEST_F( genericGatherAndSolveRealDataTests , RealData_preB_Kcrs ) {

  // Calibrater-driven exercise with real data for genericGatherAndSolve

  cal_.initialize(ms_,false,false,false);
  cal_.selectvis("","","31");  // scan 31 only

  cal_.setapply("",0.0,"realdata_test.B","","","nearest,nearest",true,Vector<Int>(),Vector<Double>());
  

  // the "SVC": a SolvableVisCal object (e.g., GJones) that is the solved-for
  //            term; ordinarily generated by Calibrater::setSolve
  Record solvePar;
  String caltablename("realdata_preB_test.KCROSS"); solvePar.define("table",caltablename);
  String solint("inf");          solvePar.define("solint",solint);
  Double preavg(-1.0);          solvePar.define("preavg",preavg);
  Int minblperant(3);          solvePar.define("minblperant",minblperant);
  Vector<Int> refantlist(1,0);   solvePar.define("refant",refantlist);

  cal_.setsolve(String("KCROSS"),solvePar);

  // Set an alternate Stokes model?  (smodel in tasks)
  Vector<Double> stokes(4,0.0); stokes(0)=1.0; stokes(1)=0.1;
  cal_.setModel(stokes);

  // Call the solve (calls genericGatherAndSolve)
  cal_.solve();

  cout << cal_.getActRec() << endl;

}

TEST_F( genericGatherAndSolveRealDataTests , RealData_preB_D ) {

  // Calibrater-driven exercise with real data for genericGatherAndSolve

  cal_.initialize(ms_,false,false,false);
  cal_.selectvis("","","31");  // scan 31 only

  cal_.setapply("",0.0,"realdata_test.B","","","nearest,nearest",true,Vector<Int>(),Vector<Double>());
  cal_.setapply("",0.0,"realdata_preB_test.KCROSS","","","nearest,nearest",true,Vector<Int>(),Vector<Double>());
  

  // the "SVC": a SolvableVisCal object (e.g., GJones) that is the solved-for
  //            term; ordinarily generated by Calibrater::setSolve
  Record solvePar;
  String caltablename("realdata_preB_test.D"); solvePar.define("table",caltablename);
  String solint("inf,8ch");          solvePar.define("solint",solint);
  Double preavg(-1.0);          solvePar.define("preavg",preavg);
  Int minblperant(3);          solvePar.define("minblperant",minblperant);
  Vector<Int> refantlist(1,0);   solvePar.define("refant",refantlist);

  cal_.setsolve(String("Dflls"),solvePar);

  // Set an alternate Stokes model?  (smodel in tasks)
  Vector<Double> stokes(4,0.0); stokes(0)=1.0;
  cal_.setModel(stokes);

  // Call the solve (calls genericGatherAndSolve)
  cal_.solve();

  cout << cal_.getActRec() << endl;


}

/*
Int mssicomp(MSSmartInterval& mssi, Double a, Double b) {
  return mssi.comp(&a,&b);
}

TEST_F( genericGatherAndSolveRealDataTests , MSSmartIntervalTest ) {

  Vector<Double> tb(2,0.0);
  
  tb[1]=110.0;

  Double interval(60.0);

  MSSmartInterval mssi(interval,tb);

  cout << mssicomp(mssi,2.0,3.0) << endl;
  cout << mssicomp(mssi,2.0,59.0) << endl << endl;

  cout << mssicomp(mssi,59.0,60.0) << endl;
  cout << mssicomp(mssi,60.0,59.0) << endl << endl;

  cout << mssicomp(mssi,60.0,60.0) << endl << endl;

  cout << mssicomp(mssi,59.0,61.0) << endl;
  cout << mssicomp(mssi,61.0,59.0) << endl << endl;

  cout << mssicomp(mssi,59.0,121.0) << endl;
  cout << mssicomp(mssi,121.0,59.0) << endl << endl;


  for (Int i=0;i<200;++i) {
    Double a(i+1);
    Double b(i);
    cout << a << " " << b << " "  << mssicomp(mssi,a,b) << endl;
  }
  
}
*/


 
/*
TEST( CalibraterSolve , Proto_genericGatherAndSolve ) {

  cout << boolalpha;
  cout.precision(12);

  // This test is a prototype for a new Calibrater::genericGatherAndSolve
  // method that will use the VI2 for data access---and be completely
  // independent of the old VisSet and VisIter.
  // The data for this test is spoofed by the SimpleSimVi2, and is
  // composed of visibilities with constant amplitude and with a constant (over
  // baselines) and small non-zero phase; this non-closing visibility ensemble 
  // enables a noise-free systematic test of the solver, which should yield
  // systematic antenna-based phase solutions equal to iant*2*dph/nant, where
  // iant is the antenna index and dph is the constant visibility phase offset.


  //*******************************************************
  //
  // This first section sets up the objects and state that must exist
  // outside the genericGatherAndSolve method.  This includes:
  // 

  // the "MS":  instead of a (selected) MS, a SimpleSimVi2Parameters object
  //            that enables spoofing the bottom "diskIO" layer of the VI2.
  Int nFld(1),nScan(4),nSpw(1),nAnt(5),nCorr(4);
  Int nchan(128), ntime(16);
  Float nonclose(1.0*C::pi/180.);  // 1 degree
  const SimpleSimVi2Parameters s1(nFld,nScan,nSpw,nAnt,nCorr,
			    Vector<Int>(nFld,ntime),  // per field
			    Vector<Int>(nSpw,nchan),  // per spw
			    Complex(cos(nonclose),sin(nonclose)));   // 1 degree
  MSMetaInfoForCal msmc(s1);

  // the "SVC": a SolvableVisCal object (e.g., GJones) that is the solved-for
  //            term; ordinarily generated by Calibrater::setSolve
  Record solvePar;
  String caltablename("proto_test.G"); solvePar.define("table",caltablename);
  String solint("16s,4ch");          solvePar.define("solint",solint);
  Double preavg(-1.0);          solvePar.define("preavg",preavg);
  Vector<Int> refantlist(1,0);   solvePar.define("refant",refantlist);

  GJones G(msmc);
  G.setSolve(solvePar);


  // the "VisEquation":  knows pre-applied and solvable terms; handles order
  VisEquation ve;   // A private object in the Calibrater



  // Pointers to helper objects used within the prototype
  SolvableVisCal* svc_p(&G);
  VisEquation* ve_p(&ve); 
  MSMetaInfoForCal* msmc_p(&msmc);

  // TBDs:
  // o Review fsolint parsing in SVC
  // o solve-context spwMap() in SVC
  // o Improve CT freq-setting so special cases
  // o combine='spw' and/or 'field', include the solveSpwMap
  // o unsolspw?  Does the CalibratingVi2 need to use ve->spwOK()?



  // This re-parses the solint specification
  //  Needs work to better handle possibility of partial chan ave
  //   for !freqDepPar() case, etc....
  svc_p->reParseSolintForVI2();

  // Tell VisEquation what we are solving for
  //  (This is executed in Calibrater::solve() before 
  //  genericGatherAndSolve() is called)
  ve_p->setsolve(*svc_p);

  // Set an alternate Stokes model  (smodel in tasks)
  Vector<Float> stokes(1,0.25);  // I=0.25, Q=U=V=0.0
  ve_p->setModel(stokes);



  //*************************
  //  This is where genericGatherAndSolve() nominally begins
  //

  // The VI2 for solving:
  CalSolVi2Organizer vi2org;
  Int nlayer(3);  // nominally; may not add chan-ave layer
  vi2org.addSimIO(s1);
  vi2org.addCalForSolving(ve);
  vi2org.addTimeAve(svc_p->solTimeInterval());
  if (!svc_p->freqDepMat() ||       // entirely unchannelized cal  OR
      (svc_p->freqDepPar() &&       // channelized par and 
       svc_p->fsolint()!="none" &&  //  some partial channel ave
       svc_p->fintervalCh()>0.0)) { //  specified
    // Add chan-ave layer
    //cout << "svc_p->fintervalCh() = " << svc_p->fintervalCh() << endl;
    vi2org.addChanAve(Int(svc_p->fintervalCh()));  // For G, full channel averaging
    ++nlayer;  // one more layer
  }
  //cout << "nLayers=" << vi2org.nLayers() << " (" << nlayer << ")" << endl;
  ASSERT_EQ(nlayer,vi2org.nLayers());

  Int nSol;
  Vector<Int> nChunkPerSol;
  nSol=vi2org.countSolutions(nChunkPerSol);

  // test------------------------------------------
  //cout << "nSol=" << nSol << endl;
  ASSERT_EQ(nSpw*nScan,nSol);
  //cout << "nChunkPerSol = " << nChunkPerSol << endl;
  ASSERT_TRUE(allEQ(nChunkPerSol,1));
  
  VisibilityIterator2& vi(vi2org.makeFullVI());
  VisBuffer2 *vb = vi.getImpl()->getVisBuffer();

  cout << "VI Layers: " << vi.ViiType() << endl;

  //Block<Int> sc=vi.getSortColumns().getColumnIds();
  //cout << "vi.getSortColumns() = " << sc.nelements() << endl;

  // Create the output caltable
  //  (this version doesn't revise frequencies)
  svc_p->createMemCalTable2();

  //  Vector<Bool> unsolspw(msmc_p->nSpw(),False);  // this is set in old system by ve_p
  Vector<Int64> nexp(msmc_p->nSpw(),0), natt(msmc_p->nSpw(),0),nsuc(msmc_p->nSpw(),0);

  Int nGood(0);
  vi.originChunks();
  for (Int isol=0;isol<nSol && vi.moreChunks();++isol) {

    // Data will accumulate here
    SDBList sdbs;

    // Gather the chunks/VBs for this solution
    for (Int ichunk=0;ichunk<nChunkPerSol(isol)&&vi.moreChunks();++ichunk,vi.nextChunk()) {
      Int ivb(0);
      for (vi.origin();vi.more();++ivb,vi.next()) {
	// NB: Expecting only one VB per chunk, in general, though  (correct?)
	cout << "isol=" << isol
	     << " ich="<<ichunk
	     << " ivb="<<ivb
	     << " scan="<<vb->scan()(0)
	     << " field="<<vb->fieldId()(0)
	     << " spw="<<vb->spectralWindows()(0)
	     << " nchan="<<vb->nChannels()
	     << " time="<<vb->time()(0)
	     << endl;

	// Add this VB to the SDBList
	//	cout << "Adding to SDBList..." << endl;
	sdbs.add(*vb);

      }
    }

    //cout << "sdbs.nSDB() = " << sdbs.nSDB()<< endl;
    ASSERT_EQ(1,sdbs.nSDB());

    // Use first spw id in the SDBList
    Int thisSpw(sdbs(0).spectralWindow()(0));

    // Expecting a solution
    nexp(thisSpw)+=1;

    if (sdbs.Ok()) {

      // Some unflagged data, so Attempting a solution
      natt(thisSpw)+=1;

      // make phase- or amp-only, if necessary
      sdbs.enforceAPonData(svc_p->apmode());
      
      // zero cross-hand weights, if necessary
      sdbs.enforceSolveWeights(svc_p->phandonly());

      // Synchronize meta-info in SVC
      svc_p->syncSolveMeta(sdbs);

      // Set or verify freqs in the caltable
      //      svc_p->setOrVerifyCTFrequencies(thisSpw);

      // Size the solvePar arrays inside SVC
      //  (smart:  if freqDepPar()=F, uses 1)
      //  returns the number of channel solutions to iterate over
      //cout << "sdbs.nChannels() = " << sdbs.nChannels() << endl;
      Int nChanSol=svc_p->sizeSolveParCurrSpw(sdbs.nChannels());
      //cout << "nChanSol = " << nChanSol << endl;

      if (svc_p->useGenericSolveOne()) {

	// We'll use the generic solver
	VisCalSolver2 vcs;
	
	// Guess from the data
	svc_p->guessPar(sdbs);


	Bool totalGoodSol(False);  // Will be set True if any channel is good
	for (Int ich=0;ich<nChanSol;++ich) {
	  svc_p->markTimer();
	  svc_p->focusChan()=ich;
      
	  // Execute the solve
	  Bool goodsol=vcs.solve(*ve_p,*svc_p,sdbs);
      

	  if (goodsol) {
	    totalGoodSol=True;

	    svc_p->formSolveSNR();
	    svc_p->applySNRThreshold();
	  }
	  else
	    svc_p->currMetaNote();

	  // Record solution in its channel, good or bad
	  if (svc_p->freqDepPar())
	    svc_p->keep1(ich);

	} // ich

	Cube<Float> phtest(phase(svc_p->solveCPar()));
	Array<Float> r(phtest(Slice(0,1,1),Slice(),Slice())); r-=phtest(0,0,0);
	Array<Float> l(phtest(Slice(1,1,1),Slice(),Slice())); l-=phtest(1,0,0);
	phtest/=(2*nonclose/nAnt);  // norm by expected step size
	//    cout << "phase=" << phase(svc_p->solveCPar())*180./C::pi << endl;
	//	cout << "Solution: Phase frac = " << phtest << endl;
	for (Int iant=1;iant<nAnt;++iant) {
	  //cout << iant << " " << 1.0f+phtest(0,0,iant)/Float(iant) << " " << (phtest(1,0,iant)/Float(2*iant)-1.0f)/2.0f << endl;
	  ASSERT_NEAR(0.0f,1.0f+phtest(0,0,iant)/Float(iant),4e-6);
	  ASSERT_NEAR(0.0f,(phtest(1,0,iant)/Float(2*iant)-1.0f)/2.f,4e-6);
	}

	// Test amplitudes
	//  should all be ~1/sqrt(I), but slightly depressed because of phase incoherence
	//   TBD: calculate incoherence, and improve this test
	Vector<Float> A=partialMeans(amplitude(svc_p->solveCPar()),IPosition(2,1,2));
	Vector<Float> Pnorm=square(A)*stokes(0);
	//cout << "Amps = " << A  << " " << Pnorm  << " " << 1.0f-Pnorm << endl;
	ASSERT_NEAR(1.0f,Pnorm(0),1e-4);
	ASSERT_NEAR(1.0f,Pnorm(1),1e-3);  // 2nd pol has more incoherence, so amp is more depressed

	//cout << "solveParErr() = " << svc_p->solveParErr() << endl;

	// SNR is linear vs. sqrt(nAnt-1), but unclear how to 
	//  predict it for noise-free non-closing case
	//cout << "solveParSNR() = " << partialMeans(svc_p->solveParSNR(),IPosition(2,1,2)) << endl;


	if (totalGoodSol) {
	  // Keep this good solution, and count it
	  svc_p->keepNCT();
	  ++nGood;
	  nsuc(thisSpw)+=1;
	}

      } // useGenericSolveOne
      else {
	// Use self-directed individual solve
	//   TBD: return T/F for goodness?
	svc_p->selfSolveOne(sdbs);  // NYI

	// Keep this good solution, and count it
	svc_p->keepNCT();
	++nGood;
	nsuc(thisSpw)+=1;
      }

    } // sdbs.Ok()
  } // isol

  cout << "  Found good " << svc_p->typeName() << " solutions in "
       << nGood << " solution intervals."
       << endl;
  ASSERT_EQ(nSpw*nScan,nGood);

  //summarize_uncalspws(unsolspw, "solv");

  //  cout << "Expected, Attempted, Succeeded (by spw) = " << nexp << ", " << natt << ", " << nsuc << endl;
  ASSERT_TRUE(allEQ(nexp,Int64(nScan)));
  ASSERT_TRUE(allEQ(natt,Int64(nScan)));
  ASSERT_TRUE(allEQ(nsuc,Int64(nScan)));

  if (nGood>0) {   // Can't do this in the test program yet
    if (svc_p->typeName()!="BPOLY") {  // needed?
      // apply refant, etc.
      svc_p->globalPostSolveTinker();

      // write to disk
      svc_p->storeNCT();
    }
  }
    

}

*/
