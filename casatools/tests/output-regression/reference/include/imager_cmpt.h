#ifndef _IMAGER_XML_IMAGER_CMPT_
#define _IMAGER_XML_IMAGER_CMPT_
/******************** generated by xml-casa (v2) from imager.xml ********************
********************* cdfa978e12a3db4a421bf7d1347680e3 *****************************/

#include <vector>
#include <string>
#include <complex>
#include <stdcasa/record.h>
#include <casaswig_types.h>
#include <casa/Exceptions/Error.h>
#include <imager_forward.h>


using namespace std;

namespace casac {

  class  imager  {
    public:

      imager();
      bool advise(bool _takeadvice=bool(true), double _amplitudeloss=double(0.05), const variant& _fieldofview=variant( ), int& _pixels=_pixels_advise, record& _cell=_cell_advise, int& _facets=_facets_advise, string& _phasecenter=_phasecenter_advise);
      record* advisechansel(double _freqstart=double(1.0e6), double _freqend=double(1.1e6), double _freqstep=double(100.0), const string& _freqframe=string("LSRK"), const string& _msname=string(""), int _fieldid=int(0), bool _getfreqrange=bool(false), const string& _spwselection=string(""));
      bool approximatepsf(const string& _psf=string(""), bool _async=bool(false));
      bool boxmask(const string& _mask=string(""), const std::vector<int>& _blc=std::vector<int>({0,0,0,0}), const std::vector<int>& _trc=std::vector<int>({}), double _value=double(1.0));
      bool calcuvw(const std::vector<int>& _fields=std::vector<int>({-1}), const string& _refcode=string(""), bool _reuse=bool(true));
      record* clean(const string& _algorithm=string("clark"), int _niter=int(1000), double _gain=double(0.1), const variant& _threshold=variant( ), bool _displayprogress=bool(false), const std::vector<std::string>& _model=std::vector<std::string>({}), const std::vector<bool>& _keepfixed=std::vector<bool>({false}), const string& _complist=string(""), const std::vector<std::string>& _mask=std::vector<std::string>({}), const std::vector<std::string>& _image=std::vector<std::string>({}), const std::vector<std::string>& _residual=std::vector<std::string>({}), const std::vector<std::string>& _psfimage=std::vector<std::string>({}), bool _interactive=bool(false), int _npercycle=int(100), const string& _masktemplate=string(""), bool _async=bool(false));
      bool clipimage(const string& _image=string(""), const variant& _threshold=variant( ));
      bool clipvis(const variant& _threshold=variant( ));
      bool close();
      bool defineimage(int _nx=int(128), int _ny=int(-1), const variant& _cellx=variant( ), const variant& _celly=variant( ), const string& _stokes=string("I"), const variant& _phasecenter=variant( ), const string& _mode=string("mfs"), int _nchan=int(-1), const variant& _start=variant( ), const variant& _step=variant( ), const std::vector<int>& _spw=std::vector<int>({0}), const variant& _restfreq=variant( ), const string& _outframe=string("LSRK"), const string& _veltype=string("radio"), int _facets=int(1), const variant& _movingsource=variant( ), const variant& _distance=variant( ), const string& _projection=string("SIN"));
      bool done();
      record* drawmask(const string& _image=string(""), const string& _mask=string(""), int _niter=int(0), int _npercycle=int(0), const string& _threshold=string("0 mJy"));
      bool exprmask(const string& _mask=string(""), double _expr=double(1.0));
      bool feather(const string& _image=string(""), const string& _highres=string(""), const string& _lowres=string(""), const string& _lowpsf=string(""), double _effdishdiam=double(-1.0), bool _lowpassfiltersd=bool(false), bool _async=bool(false));
      bool filter(const string& _type=string("gaussian"), const variant& _bmaj=variant( ), const variant& _bmin=variant( ), const variant& _bpa=variant( ), bool _async=bool(false));
      bool fitpsf(const string& _psf=string(""), bool _async=bool(false), record& _bmaj=_bmaj_fitpsf, record& _bmin=_bmin_fitpsf, record& _bpa=_bpa_fitpsf);
      bool fixvis(const std::vector<int>& _fields=std::vector<int>({-1}), const std::vector<std::string>& _phasedirs=std::vector<std::string>({}), const string& _refcode=string(""), const std::vector<double>& _distances=std::vector<double>({0.0}), const string& _datacolumn=string("all"));
      bool ft(const std::vector<std::string>& _model=std::vector<std::string>({}), const string& _complist=string(""), bool _incremental=bool(false), double _phasecentertime=double(-1.0));
      variant* getweightgrid(const string& _type=string("imaging"), const std::vector<std::string>& _wgtimages=std::vector<std::string>({}));
      bool linearmosaic(const std::vector<std::string>& _images=std::vector<std::string>({}), const string& _mosaic=string(""), const string& _fluxscale=string(""), const string& _sensitivity=string(""), const std::vector<int>& _fieldids=std::vector<int>({0}), bool _usedefaultvp=bool(true), const string& _vptable=string(""), bool _async=bool(false));
      bool make(const string& _image=string(""), bool _async=bool(false));
      string predictcomp(const string& _objname=string(""), const string& _standard=string(""), const variant& _epoch=variant( ), const std::vector<double>& _freqs=std::vector<double>({1.0e11}), const string& _pfx=string("predictcomp"));
      bool makeimage(const string& _type=string("observed"), const string& _image=string(""), const string& _compleximage=string(""), bool _verbose=bool(true), bool _async=bool(false));
      bool makemodelfromsd(const string& _sdimage=string(""), const string& _modelimage=string(""), const string& _sdpsf=string(""), const string& _maskimage=string(""));
      bool mask(const string& _image=string(""), const string& _mask=string(""), const variant& _threshold=variant( ), bool _async=bool(false));
      bool mem(const string& _algorithm=string("entropy"), int _niter=int(20), const variant& _sigma=variant( ), const variant& _targetflux=variant( ), bool _constrainflux=bool(false), bool _displayprogress=bool(false), const std::vector<std::string>& _model=std::vector<std::string>({}), const std::vector<bool>& _keepfixed=std::vector<bool>({false}), const string& _complist=string(""), const std::vector<std::string>& _prior=std::vector<std::string>({}), const std::vector<std::string>& _mask=std::vector<std::string>({}), const std::vector<std::string>& _image=std::vector<std::string>({}), const std::vector<std::string>& _residual=std::vector<std::string>({}), bool _async=bool(false));
      bool nnls(const std::vector<std::string>& _model=std::vector<std::string>({}), const std::vector<bool>& _keepfixed=std::vector<bool>({false}), const string& _complist=string(""), int _niter=int(0), double _tolerance=double(1e-06), const std::vector<std::string>& _fluxmask=std::vector<std::string>({}), const std::vector<std::string>& _datamask=std::vector<std::string>({}), const std::vector<std::string>& _image=std::vector<std::string>({}), const std::vector<std::string>& _residual=std::vector<std::string>({}), bool _async=bool(false));
      bool open(const string& _thems=string(""), bool _compress=bool(false), bool _usescratch=bool(false));
      bool pb(const string& _inimage=string(""), const string& _outimage=string(""), const string& _incomps=string(""), const string& _outcomps=string(""), const string& _operation=string("apply"), const variant& _pointingcenter=variant( ), const variant& _parangle=variant( ), const string& _pborvp=string("pb"), bool _async=bool(false));
      bool plotsummary();
      bool plotuv(bool _rotate=bool(false));
      bool plotvis(const string& _type=string("all"), int _increment=int(1));
      bool plotweights(bool _gridded=bool(false), int _increment=int(1));
      bool regionmask(const string& _mask=string(""), const record& _region=initialize_record(""""), const variant& _boxes=variant( ), const variant& _circles=variant( ), double _value=double(1.0));
      bool regiontoimagemask(const string& _mask=string(""), const record& _region=initialize_record(""""), const variant& _boxes=variant( ), const variant& _circles=variant( ), double _value=double(1.0));
      bool residual(const std::vector<std::string>& _model=std::vector<std::string>({}), const string& _complist=string(""), const std::vector<std::string>& _image=std::vector<std::string>({}), bool _async=bool(false));
      bool restore(const std::vector<std::string>& _model=std::vector<std::string>({}), const string& _complist=string(""), const std::vector<std::string>& _image=std::vector<std::string>({}), const std::vector<std::string>& _residual=std::vector<std::string>({}), bool _async=bool(false));
      bool updateresidual(const std::vector<std::string>& _model=std::vector<std::string>({}), const string& _complist=string(""), const std::vector<std::string>& _image=std::vector<std::string>({}), const std::vector<std::string>& _residual=std::vector<std::string>({}));
      bool sensitivity(bool _async=bool(false), record& _pointsource=_pointsource_sensitivity, double& _relative=_relative_sensitivity, double& _sumweights=_sumweights_sensitivity, record& _senrec=_senrec_sensitivity);
      bool apparentsens(bool _async=bool(false), double& _pointsource=_pointsource_apparentsens, double& _relative=_relative_apparentsens);
      bool setbeam(const variant& _bmaj=variant( ), const variant& _bmin=variant( ), const variant& _bpa=variant( ), bool _async=bool(false));
      bool selectvis(const string& _vis=string(""), const std::vector<int>& _nchan=std::vector<int>({-1}), const std::vector<int>& _start=std::vector<int>({0}), const std::vector<int>& _step=std::vector<int>({1}), const variant& _spw=variant( ), const variant& _field=variant( ), const variant& _baseline=variant( ), const variant& _time=variant( ), const variant& _scan=variant( ), const string& _intent=string(""), const variant& _observation=variant( ), const variant& _uvrange=variant( ), const string& _taql=string(""), bool _usescratch=bool(false), bool _datainmemory=bool(false), bool _writeaccess=bool(true));
      record* setjy(const variant& _field=variant( ), const variant& _spw=variant( ), const string& _modimage=string(""), const std::vector<double>& _fluxdensity=std::vector<double>({0.0,0.0,0.0,0.0}), const string& _standard=string("SOURCE"), bool _scalebychan=bool(false), const std::vector<double>& _spix=std::vector<double>({0.0}), const variant& _reffreq=variant( ), const std::vector<double>& _polindex=std::vector<double>({0.0}), const std::vector<double>& _polangle=std::vector<double>({0.0}), double _rotmeas=double(0.0), const string& _time=string(""), const string& _scan=string(""), const string& _intent=string(""), const string& _observation=string(""), const string& _interpolation=string("nearest"));
      bool ssoflux();
      bool setmfcontrol(double _cyclefactor=double(1.5), double _cyclespeedup=double(-1), double _cyclemaxpsffraction=double(0.8), int _stoplargenegatives=int(2), int _stoppointmode=int(-1), double _minpb=double(0.1), const string& _scaletype=string("NONE"), double _constpb=double(0.4), const std::vector<std::string>& _fluxscale=std::vector<std::string>({}), bool _flatnoise=bool(true));
      bool setoptions(const string& _ftmachine=string("ft"), int _cache=int(-1), int _tile=int(16), const string& _gridfunction=string("SF"), const variant& _location=variant( ), double _padding=double(1.0), const string& _freqinterp=string("nearest"), int _wprojplanes=int(-1), const string& _epjtablename=string(""), bool _applypointingoffsets=bool(false), bool _dopbgriddingcorrections=bool(true), const string& _cfcachedirname=string(""), double _rotpastep=double(5.0), double _pastep=double(360.0), double _pblimit=double(0.05), int _imagetilevol=int(0), bool _singleprecisiononly=bool(false), int _numthreads=int(-1), bool _psterm=bool(true), bool _aterm=bool(true), bool _mterm=bool(true), bool _wbawp=bool(false), bool _conjbeams=bool(true));
      bool setscales(const string& _scalemethod=string("nscales"), int _nscales=int(5), const std::vector<double>& _uservector=std::vector<double>({0.0,3.0,10.0}));
      bool setsmallscalebias(float _inbias=float(0.6));
      bool settaylorterms(int _ntaylorterms=int(2), double _reffreq=double(0.0));
      bool setsdoptions(double _scale=double(1.0), double _weight=double(1.0), int _convsupport=int(-1), const string& _pointingcolumntouse=string("DIRECTION"), const variant& _truncate=variant( ), const variant& _gwidth=variant( ), const variant& _jwidth=variant( ), double _minweight=double(0.), bool _clipminmax=bool(false));
      bool setvp(bool _dovp=bool(false), bool _usedefaultvp=bool(true), const string& _vptable=string(""), bool _dosquint=bool(false), const variant& _parangleinc=variant( ), const variant& _skyposthreshold=variant( ), const string& _telescope=string(""), bool _verbose=bool(true));
      bool setweightgrid(const variant& _weight=variant( ), const string& _type=string("imaging"));
      bool smooth(const std::vector<std::string>& _model=std::vector<std::string>({}), const std::vector<std::string>& _image=std::vector<std::string>({}), bool _usefit=bool(true), const variant& _bmaj=variant( ), const variant& _bmin=variant( ), const variant& _bpa=variant( ), bool _normalize=bool(true), bool _async=bool(false));
      bool stop();
      bool summary();
      bool uvrange(double _uvmin=double(0.0), double _uvmax=double(0.0));
      bool weight(const string& _type=string("natural"), const string& _rmode=string("none"), const variant& _noise=variant( ), double _robust=double(0.0), const variant& _fieldofview=variant( ), int _npixels=int(0), bool _mosaic=bool(false), bool _async=bool(false));
      record* mapextent(const string& _ref=string("J2000"), const string& _movingsource=string(""), const string& _pointingcolumntouse=string("DIRECTION"));
      record* pointingsampling(const string& _pattern=string("raster"), const string& _ref=string("J2000"), const string& _movingsource=string(""), const string& _pointingcolumntouse=string("DIRECTION"), const string& _antenna=string(""));

        ~imager( );

    private:

#include <imager_private.h>


      // --- declarations of static parameter defaults ---
    public:
      static int _pixels_advise;
      static record _cell_advise;
      static int _facets_advise;
      static string _phasecenter_advise;
      static record _bmaj_fitpsf;
      static record _bmin_fitpsf;
      static record _bpa_fitpsf;
      static record _pointsource_sensitivity;
      static double _relative_sensitivity;
      static double _sumweights_sensitivity;
      static record _senrec_sensitivity;
      static double _pointsource_apparentsens;
      static double _relative_apparentsens;
  };

}

#endif
