##################### generated by xml-casa (v2) from synthesisutils.xml ############
##################### 446f8d72a8d4a8d7938e884151ff05b6 ##############################
from __future__ import absolute_import 
from .__casac__ import synthesisutils as _synthesisutils
from .platform import str_encode as _str_ec
from .platform import str_decode as _str_dc
from .platform import dict_encode as _dict_ec
from .platform import dict_decode as _dict_dc
from .platform import dict_encode as _quant_ec
from .platform import dict_decode as _quant_dc
from .platform import encode as _any_ec
from .platform import decode as _any_dc
from .typecheck import validator as _pc
from .coercetype import coerce as _coerce
from .synthesisimstore import synthesisimstore as _wrap_synthesisimstore

class synthesisutils:
    ### self
    def __init__(self, *args, **kwargs):
        """This is used to construct {tt synthesisutils} tool.
        """
        self._swigobj = kwargs.get('swig_object',None)
        if self._swigobj is None:
            self._swigobj = _synthesisutils()

    def contdatapartition(self, selpars={ }, npart=int(1)):
        """
        """
        schema = {'selpars': {'type': 'cDict'}, 'npart': {'type': 'cInt'}}
        doc = {'selpars': selpars, 'npart': npart}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _contdatapartition_result = _dict_dc(self._swigobj.contdatapartition(_dict_ec(_pc.document['selpars']), _pc.document['npart']))
        return _contdatapartition_result

    def cubedatapartition(self, selpars={ }, npart=int(1), fstart=[ ], fend=[ ], frame='LSRK'):
        """returns a dictionary with data spectral parttiion that maps  data  to  nparts
        of the input range frequency... usually to be used for doing data selection
        when imaging a cube from fstart to fend in npart subcubes
        """
        schema = {'selpars': {'type': 'cDict'}, 'npart': {'type': 'cInt'}, 'fstart': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'fend': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'frame': {'type': 'cStr'}}
        doc = {'selpars': selpars, 'npart': npart, 'fstart': fstart, 'fend': fend, 'frame': frame}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _cubedatapartition_result = _dict_dc(self._swigobj.cubedatapartition(_dict_ec(_pc.document['selpars']), _pc.document['npart'], _any_ec(_pc.document['fstart']), _any_ec(_pc.document['fend']), _str_ec(_pc.document['frame'])))
        return _cubedatapartition_result

    def cubeimagepartition(self, impars={ }, npart=int(1)):
        """
        """
        schema = {'impars': {'type': 'cDict'}, 'npart': {'type': 'cInt'}}
        doc = {'impars': impars, 'npart': npart}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _cubeimagepartition_result = _dict_dc(self._swigobj.cubeimagepartition(_dict_ec(_pc.document['impars']), _pc.document['npart']))
        return _cubeimagepartition_result

    def cubedataimagepartition(self, selpars={ }, incsys={ }, npart=int(1), nchannel=int(1)):
        """
        """
        schema = {'selpars': {'type': 'cDict'}, 'incsys': {'type': 'cDict'}, 'npart': {'type': 'cInt'}, 'nchannel': {'type': 'cInt'}}
        doc = {'selpars': selpars, 'incsys': incsys, 'npart': npart, 'nchannel': nchannel}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _cubedataimagepartition_result = _dict_dc(self._swigobj.cubedataimagepartition(_dict_ec(_pc.document['selpars']), _dict_ec(_pc.document['incsys']), _pc.document['npart'], _pc.document['nchannel']))
        return _cubedataimagepartition_result

    def checkselectionparams(self, selpars={ }):
        """
        """
        schema = {'selpars': {'type': 'cDict'}}
        doc = {'selpars': selpars}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _checkselectionparams_result = _dict_dc(self._swigobj.checkselectionparams(_dict_ec(_pc.document['selpars'])))
        return _checkselectionparams_result

    def checkimageparams(self, impars={ }):
        """
        """
        schema = {'impars': {'type': 'cDict'}}
        doc = {'impars': impars}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _checkimageparams_result = _dict_dc(self._swigobj.checkimageparams(_dict_ec(_pc.document['impars'])))
        return _checkimageparams_result

    def checkgridparams(self, gridpars={ }):
        """
        """
        schema = {'gridpars': {'type': 'cDict'}}
        doc = {'gridpars': gridpars}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _checkgridparams_result = _dict_dc(self._swigobj.checkgridparams(_dict_ec(_pc.document['gridpars'])))
        return _checkgridparams_result

    def updateimpars(self, impars={ }):
        """
        """
        schema = {'impars': {'type': 'cDict'}}
        doc = {'impars': impars}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _updateimpars_result = _dict_dc(self._swigobj.updateimpars(_dict_ec(_pc.document['impars'])))
        return _updateimpars_result

    def getOptimumSize(self, size=int(100)):
        """
        """
        schema = {'size': {'type': 'cInt'}}
        doc = {'size': size}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _getOptimumSize_result = self._swigobj.getOptimumSize(_pc.document['size'])
        return _getOptimumSize_result

    def done(self):
        """
        """
        _done_result = self._swigobj.done()
        return _done_result

