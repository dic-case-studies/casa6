##################### generated by xml-casa (v2) from imager.xml ####################
##################### cdfa978e12a3db4a421bf7d1347680e3 ##############################
from __future__ import absolute_import 
from .__casac__ import imager as _imager
from .platform import str_encode as _str_ec
from .platform import str_decode as _str_dc
from .platform import dict_encode as _dict_ec
from .platform import dict_decode as _dict_dc
from .platform import dict_encode as _quant_ec
from .platform import dict_decode as _quant_dc
from .platform import encode as _any_ec
from .platform import decode as _any_dc
from .typecheck import validator as _pc
from .coercetype import coerce as _coerce


class imager:
    ### self
    def __init__(self, *args, **kwargs):
        """This is used to construct {tt imager} tools associated
        with a MeasurementSet. The {tt imager} tool may then be
        used to generate various types of images. Note that
        a new executable is started every time the constructor
        is called.
        
        This returns a Glish variable containing the tool functions of
        imager in an alternate universe that you have to tunnel to with a wormhole
        """
        self._swigobj = kwargs.get('swig_object',None)
        if self._swigobj is None:
            self._swigobj = _imager()

    def advise(self, takeadvice=True, amplitudeloss=float(0.05), fieldofview=[ ], pixels=int(0), cell={ }, facets=int(0), phasecenter=''):
        """Advise on recommended values of certain parameters. Return these
        values and optionally use them in Imager.
        
        The calculations are performed as following:
        
        begin{description}
        item[cell] The maximum uv distance in wavelength is found and then half of the
        inverse is taken as the maximum cellsize allowed.
        item[pixels] The field of view is converted to a number of pixels
        using the calculated cell size.
        item[facets] The number of facets on an axis is calculated in two
        different ways. The first method simply requires that the peeling of
        facets away from the celestial sphere should not cause an amplitude
        drop of more than the argument {tt amplitudeloss}. The positions may
        be incorrect, but all the sources will be removed correctly. The
        second method requires that the source positions be accurate to the
        same fraction of the beam specified by {tt amplitudeloss}. The
        second calculates the second moment in w and in uv distance and
        chooses the number of facets correspondingly. The first method does
        the same but after fitting a plane to the sampling: $w = a u + b v$.
        For an approximately coplanar array, the positions may be wrong but
        the removal of sidelobes will be accurate. The number of facets
        returned is the second, usually smaller, number. The formula used
        is:
        begin{equation}
        N_{facets} = N_{pixels} sqrt{{{Delta theta}over{sqrt{8 delta A}}}{w_{rms}}over{uv_{rms}}}
        end{equation}
        where $Delta theta$ is the cellsize in radians, and $delta A$ is
        the amplitude loss. This formula can be derived from (a) the peeling
        of facets from the celestial sphere, and (b) a quadratic approximation
        for the beam size both in the plane of the sky and along the $w$ axis.
        end{description}
        """
        schema = {'takeadvice': {'type': 'cBool'}, 'amplitudeloss': {'type': 'cFloat', 'coerce': _coerce.to_float}, 'fieldofview': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'pixels': {'type': 'cInt'}, 'cell': {'type': 'cDict'}, 'facets': {'type': 'cInt'}, 'phasecenter': {'type': 'cStr'}}
        doc = {'takeadvice': takeadvice, 'amplitudeloss': amplitudeloss, 'fieldofview': fieldofview, 'pixels': pixels, 'cell': cell, 'facets': facets, 'phasecenter': phasecenter}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _advise_result = self._swigobj.advise(_pc.document['takeadvice'], _pc.document['amplitudeloss'], _any_ec(_pc.document['fieldofview']), _pc.document['pixels'], _dict_ec(_pc.document['cell']), _pc.document['facets'], _str_ec(_pc.document['phasecenter']))
        pixels = _pc.document['pixels']
        cell = _dict_dc(_dict_ec(_pc.document['cell']))
        facets = _pc.document['facets']
        phasecenter = _str_dc(_str_ec(_pc.document['phasecenter']))
        return _advise_result

    def advisechansel(self, freqstart=float(1.0e6), freqend=float(1.1e6), freqstep=float(100.0), freqframe='LSRK', msname='', fieldid=int(0), getfreqrange=False, spwselection=''):
        """Basically tells you what channels of which spectral window need to be
        selected for your image spectral parameters.  The freqstep is used to
        calulate the extra padding needed for data selection at the begining
        and end of the range.  The freqframe parameter is the frame in which
        the frequency range is being given. It will be converted to the frame
        of the data with time to locate which channel match.
        A record will be returned with an element for each ms  used in selectvis.
        Each element of the record will have the spwids and channel start and nchan for each spwid.
        if the parameter msname is used then the MSs associated associated with
        this tool (that have been either 'open'ed or 'selectvis'ed) are ignored
        In this mode it is a helper function to the general world ...no need to
        open or selectvis. You need to specify the field_id for which this calculation is
        being done for in the helper mode.
        If you have already set MS's and selected data and msname="" then
        the calulation is done for the field(s) selected in selectvis.
        
        If the parameter {tt getfreqrange=True} then the reverse is requested. You set {tt spwselection} to be the range of data selection you want to use and you'll get the range of frequency covered in the frame you set.
        """
        schema = {'freqstart': {'type': 'cFloat', 'coerce': _coerce.to_float}, 'freqend': {'type': 'cFloat', 'coerce': _coerce.to_float}, 'freqstep': {'type': 'cFloat', 'coerce': _coerce.to_float}, 'freqframe': {'type': 'cStr'}, 'msname': {'type': 'cStr'}, 'fieldid': {'type': 'cInt'}, 'getfreqrange': {'type': 'cBool'}, 'spwselection': {'type': 'cStr'}}
        doc = {'freqstart': freqstart, 'freqend': freqend, 'freqstep': freqstep, 'freqframe': freqframe, 'msname': msname, 'fieldid': fieldid, 'getfreqrange': getfreqrange, 'spwselection': spwselection}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _advisechansel_result = _dict_dc(self._swigobj.advisechansel(_pc.document['freqstart'], _pc.document['freqend'], _pc.document['freqstep'], _str_ec(_pc.document['freqframe']), _str_ec(_pc.document['msname']), _pc.document['fieldid'], _pc.document['getfreqrange'], _str_ec(_pc.document['spwselection'])))
        return _advisechansel_result

    def approximatepsf(self, psf='', async=False):
        """Calculate the approximate point spread function.
        {em Note that the model visibilities are updated}.
        
        Some types of imaging do not yield a well-defined point spread
        function. For example, mosaicing or single dish imaging both yield
        point spread functions that are position dependent. Nevertheless, one
        can still usefully define an {em approximate} PSF that is of some
        utility. This is calculated by doing the following calculation: a
        point source is located at the center of the specified coordinate
        system and the model data predicted. The approximate PSF is then formed from
        those model data using the full sky equation. For regular sampling in
        the image plane, this approximate PSF is actually quite good. It can
        be used in a deconvolution. For a mosaic with similar uv sampling per
        pointing, the approximate PSF is roughly the PSF per pointing
        multiplied by the primary beam. For a single dish image, it is roughly
        the telescope primary beam convolved with itself (if the
        gridfunction='pb' was selected).
        """
        schema = {'psf': {'type': 'cStr'}, 'async': {'type': 'cBool'}}
        doc = {'psf': psf, 'async': async}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _approximatepsf_result = self._swigobj.approximatepsf(_str_ec(_pc.document['psf']), _pc.document['async'])
        return _approximatepsf_result

    def boxmask(self, mask='', blc=[ int(0),int(0),int(0),int(0) ], trc=[ int() ], value=float(1.0)):
        """A mask image is an image with the same shape as the other images but
        with values between 0.0 and 1.0 as a pixel value. Mask images are used in
        imager to control the region selected in a deconvolution.
        
        In the Clark CLEAN, the mask image can usefully have any value between
        0.0 and 1.0. Intermediate value discourage but do not rule out
        selection of clean components in that region. This is accomplished by
        multiplying the residual image by the mask prior to entering the minor
        cycle. Note that if you do use a mask for the Clark or Hogbom Clean,
        it must cover only a quarter of the image. boxmask does not enforce
        this requirement.
        """
        schema = {'mask': {'type': 'cStr'}, 'blc': {'type': 'cIntVec', 'coerce': [_coerce.to_list,_coerce.to_intvec]}, 'trc': {'type': 'cIntVec', 'coerce': [_coerce.to_list,_coerce.to_intvec]}, 'value': {'type': 'cFloat', 'coerce': _coerce.to_float}}
        doc = {'mask': mask, 'blc': blc, 'trc': trc, 'value': value}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _boxmask_result = self._swigobj.boxmask(_str_ec(_pc.document['mask']), _pc.document['blc'], _pc.document['trc'], _pc.document['value'])
        return _boxmask_result

    def calcuvw(self, fields=[ int(-1) ], refcode='', reuse=True):
        """This calculates (u, v, w) positions for the visibilities using the antenna
        and feed positions and offsets, the time, and the phase tracking center(s).
        
        """
        schema = {'fields': {'type': 'cIntVec', 'coerce': [_coerce.to_list,_coerce.to_intvec]}, 'refcode': {'type': 'cStr'}, 'reuse': {'type': 'cBool'}}
        doc = {'fields': fields, 'refcode': refcode, 'reuse': reuse}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _calcuvw_result = self._swigobj.calcuvw(_pc.document['fields'], _str_ec(_pc.document['refcode']), _pc.document['reuse'])
        return _calcuvw_result

    def clean(self, algorithm='clark', niter=int(1000), gain=float(0.1), threshold=[ ], displayprogress=False, model=[  ], keepfixed=[ False ], complist='', mask=[  ], image=[  ], residual=[  ], psfimage=[  ], interactive=False, npercycle=int(100), masktemplate='', async=False):
        """Makes a clean image using either the Hogbom, Clark, multi-scale or multi-field
        algorithms. The Clark algorithm is the default. The clean is performed
        on the residual image calculated from the visibility data currently
        selected. Hence the first step performed in clean is to transform the
        current model or models (optionally including a componentlist) to fill
        in the MODEL_DATA column, and then inverse transform the residual
        visibilities to get a residual image. This residual image is then
        cleaned using the corresponding point spread function. This means that
        the initial model is used as the starting point for the
        deconvolution. Thus if you want to restart a clean, simply set the
        model to the model that was previously produced by clean.
        
        Rather than explicit CLEAN boxes, mask images are used to constrain
        the region that is to be deconvolved. To make mask images,
        use either boxmask (to define a mask
        via the corner locations blc and trc) or
        mask (to define a mask via
        thresholding an existing image) or regionmask (to make masks via regions using the regionmanager or interactively through the viewer)  . The default mask is the inner quarter
        of the image.
        
        The CLEAN deconvolution is joint in whatever Stokes parameters are
        present. Thus it searchs for peaks in either $I$ or $I+|V|$ or
        $I+sqrt{Q^2+U^2+V^2}$, the rationale for the latter two forms being
        to be biased towards finding strongly polarized pixels first (these
        forms are also the maximum eigenvalue of the coherency matrix).  The
        PSF is constrained to be the same in all polarizations (a feature of
        this implementation, not of the Hamaker-Bregman-Sault formalism). But the option of
        searching peaks in the stokes planes independently is available via
        the {tt clarkstokes} parameter
        
        
        
        The clean algorithms possible are:
        begin{description}
        item[Hogbom] The classic algorithm: points are found iteratively
        by searching for the peak. Each point is subtracted from the
        full residual image using the shifted and scaled point spread
        function.
        item[Multiscale] An experimental multi-scale clean algorithm is invoked.
        The algorithm is fully described in
        deconvolver.
        item[Clark] The faster algorithm: the cleaning is split into
        minor and major cycles. In the minor cycles only the brightest
        points are cleaned, using a subset of the point spread function.
        In the major cycle, the points thus found are subtracted correctly
        by using an FFT-based convolution.
        item[Multi-field] Cleaning is split into minor and major
        cycles. For each field, a Clark-style minor cycle is performed.
        In the major cycle, the points thus found are subtracted
        either from the original visibilities (for multiple fields)
        or using a convolution (for only one field). The latter is
        much faster.  Multi-field imaging has been implemented for
        Clark, Hogbom, and Multi-scale deconvolution algorithms.
        item[Cotton-Schwab] Cleaning is split into minor and major
        cycles. For each field, a Clark-style minor cycle is performed.
        In the major cycle, the points thus found are subtracted
        from the original visibilities. A fast variant does a convolution
        using a FFT. This will be faster for large numbers of
        visibilities. Double the image size from that used for Cotton-Schwab
        and set a mask to clean only the inner quarter.
        item[Wide-field] The user will need to use a wide-field algorithm to
        deconvolve if the array is not coplanar over the field of view being
        imaged . The technique used is to break the field being imaged into
        smaller pieces (facets), over each of which the array appear
        planar. We implement a rectangular facetting scheme. If the number of
        facets specified in defineimage is
        greater than one, Either wfhogbom or wfclark algorithm has to be
        selected here to perform a wide-field decovolution. The function
        advise can be used to calculate or
        check if you need to use a wide-field deconvolution. Note that
        aliasing can be reduced by using the {tt padding} argument in
        setoptions. In practice the
        previous sentence means that if you notice the clean to diverge at the
        edges of the facets then you need to use a larger amount of padding
        for the FT; the default being 1.2. Wide-field imaging has been
        implemented for Clark and Hogbom algorithms.
        end{description}
        
        The multi-field clean should be used if either of two conditions
        hold:
        begin{enumerate}
        item Multiple fields are to be cleaned simultaneously {bf OR}
        item Primary beam correction is enabled. In this case, a
        mosaiced clean is performed.
        end{enumerate}
        
        Note that for the single pointing algorithms, only a quarter of the
        image may be cleaned. If no mask is set, then the cleaned region
        defaults to the inner quarter. If a mask larger than a quarter of the
        image is set, then only the inner quarter part of that mask is used.
        However, for the wide-field and multi-field imaging (including the
        Cotton-Schwab algorithm), the entire field may be imaged because the
        major cycles either do an exact subtraction from the visibilities or
        because PSF extent is more than twice the extent of the primary beam
        support.
        
        Before {tt clean} can be run, you must run {tt selectvis} and {tt defineimage}.
        Before {tt clean} can be run with a multi-field algorithm (especially for mosaic), you should run
        {tt setvp}.  You may want to run {tt setmfcontrol} before running {tt clean}
        with a multi-field or wide-field algorithm, though the default control values
        may be acceptable.  Before {tt clean} can be run with a multi-scale algorithm,
        {tt setscales} must be run.
        
        
        Interactive cleaning/masking: If the user wants to see what the clean
        image looks like after npercycle iteration and mask or modify the mask
        each time, he/she should set {tt interactive=True} and give npercycle to a
        fraction of niter. A viewer with the last residual image along with an
        overlayed mask appear after every npercycle iteration. The user can
        add or delete regions (by clicking on the appropriate button) to the
        mask using the region button and drawing regions and double clicking
        inside the region. When satisfied and ready to continue cleaning press 'DONE
        with masking' (if the user want to terminate the cleaning process use
        the 'STOP' button). The button 'No more mask changes' should be used
        if the user want clean to proceed without any further interruption.
        Even if {tt interactive=False}, and if the parameter
        'mask' is non-empty, it is still used in limiting the search area for
        clean components.  If the parameter 'masktemplate' is not empty this
        means that the user want to use an apriori image to make the mask the
        first time (e.g a previously cleaned image)
        
        This function returns a record containing convergence, iterations used and threshold reached.
        """
        schema = {'algorithm': {'type': 'cStr'}, 'niter': {'type': 'cInt'}, 'gain': {'type': 'cFloat', 'coerce': _coerce.to_float}, 'threshold': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'displayprogress': {'type': 'cBool'}, 'model': {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}, 'keepfixed': {'type': 'cBoolVec'}, 'complist': {'type': 'cStr'}, 'mask': {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}, 'image': {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}, 'residual': {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}, 'psfimage': {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}, 'interactive': {'type': 'cBool'}, 'npercycle': {'type': 'cInt'}, 'masktemplate': {'type': 'cStr'}, 'async': {'type': 'cBool'}}
        doc = {'algorithm': algorithm, 'niter': niter, 'gain': gain, 'threshold': threshold, 'displayprogress': displayprogress, 'model': model, 'keepfixed': keepfixed, 'complist': complist, 'mask': mask, 'image': image, 'residual': residual, 'psfimage': psfimage, 'interactive': interactive, 'npercycle': npercycle, 'masktemplate': masktemplate, 'async': async}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _clean_result = _dict_dc(self._swigobj.clean(_str_ec(_pc.document['algorithm']), _pc.document['niter'], _pc.document['gain'], _any_ec(_pc.document['threshold']), _pc.document['displayprogress'], [_str_ec(_x) for _x in _pc.document['model']], _pc.document['keepfixed'], _str_ec(_pc.document['complist']), [_str_ec(_x) for _x in _pc.document['mask']], [_str_ec(_x) for _x in _pc.document['image']], [_str_ec(_x) for _x in _pc.document['residual']], [_str_ec(_x) for _x in _pc.document['psfimage']], _pc.document['interactive'], _pc.document['npercycle'], _str_ec(_pc.document['masktemplate']), _pc.document['async']))
        return _clean_result

    def clipimage(self, image='', threshold=[ ]):
        """All pixels in the image with Stokes I less than some threshold
        are set to zero. This is useful prior to self-calibration where one
        oftens wishes to remove negative pixels from the model. Note that
        if the image has polarization information, then the polarized
        part of a pixel is also set to zero if Stokes I is less than the
        threshold.
        """
        schema = {'image': {'type': 'cStr'}, 'threshold': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}}
        doc = {'image': image, 'threshold': threshold}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _clipimage_result = self._swigobj.clipimage(_str_ec(_pc.document['image']), _any_ec(_pc.document['threshold']))
        return _clipimage_result

    def clipvis(self, threshold=[ ]):
        """All visibilities where the residual exceeds some threshold
        are flagged. This provides a simple way of flagging bad
        data.
        """
        schema = {'threshold': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}}
        doc = {'threshold': threshold}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _clipvis_result = self._swigobj.clipvis(_any_ec(_pc.document['threshold']))
        return _clipvis_result

    def close(self):
        """This is used to close {tt imager} tools. Note that the
        data is written to disk. The {tt imager} process keeps running
        until a done tool function call is performed.
        """
        _close_result = self._swigobj.close()
        return _close_result

    def defineimage(self, nx=int(128), ny=int(-1), cellx=[ ], celly=[ ], stokes='I', phasecenter=[ ], mode='mfs', nchan=int(-1), start=[ ], step=[ ], spw=[ int(0) ], restfreq=[ ], outframe='LSRK', veltype='radio', facets=int(1), movingsource=[ ], distance=[ ], projection='SIN'):
        """Define the default image parameters. If an image is to be
        made, then these parameters are used in the construction
        of the image. Thus, for example, the tool function make
        makes an (empty) image using these parameters.
        
        Note that some parameters can be specified either in canonical units
        or via measures. To establish default values, the ids for the default
        spectral window and default field id must be given.
        
        The parameter {tt mode} can be one of the following:
        begin{itemize}
        item mfs
        item channel
        item velocity or opticalvelocity
        item frequency
        end{itemize}
        
        {tt imager} can perform multi-frequency synthesis over several
        spectral windows (mode='mfs'). To achieve this, you should set spwid
        to an array of the required spectral windows ({em e.g.}  {tt
        spwid=[0,1]}). WARNING: For multifrequency synthesis, 'mfs', it is
        important that the spwid's selected in selectvis be the SAME
        as the one selected in {tt defineimage}.  Otherwise the frequency at which
        the image is made is not going to be the same as to the one as the one
        used in gridding the visibility and can lead to image artifacts.  For
        {tt mode='velocity'} and {tt mode='frequency'} the {tt step}
        parameter has to be a measure/quantity of velocity or frequency,
        otherwise for {tt mode='channel'} step is the number of data
        channels to be averaged to make one image channel( see examples
        below).
        
        
        The phase center of the image defaults to that of the specified
        phasecenter (the first fieldid in the ms is taken if none is
        specified), this parameter can be a fieldid or a measure string or the
        record output from the direction function of the measures tool( direction ).
        This is important if you have multiple pointings in the data. The user
        would have used selectvis to select which pointings would be used in imaging. If the
        conversion from the observed direction requires frame information then
        this is taken as follows: begin{itemize} item Direction information,
        including the coordinate system, is taken from the relevant entry in
        the Field table of the MeasurementSet.  item The epoch is taken from
        the time of observation of each visibility.  item A position is
        specified via the {tt imager} tool function setoptions
        end{itemize}
        
        If the specified number of facets is greater than unity then the image
        is split into facets (this number along the x and y axes) and
        processed. This is necessary when using wide-field algorithm for
        deconvolving the image, in cases of non-coplanar arrays (e.g the VLA
        at low frequencies but can be safely left at 1 for the ATCA or WSRT).
        This is now recommended only when memory or image size is of a problem,
        otherwise for widefield issues, wprojection (ftmachine parameter in setoptions) is recommended with a single
        facet.
        
        For spectral imaging {tt defineimage} and {tt selectvis} defines the
        spectral channels that are imaged. Examples are given in the selectvis section.
        The parameter {tt restfreq} can be used to define what rest frequency
        to use in the resulting images. If none is specified imager will try
        to use the one that is defined in the ms. It will use the first one
        defined in the first spectral window selected.
        
        For wide-field or 3D imaging see setoptions
        section for some examples.
        
        If the telescope is observing moving source (e.g planet or moon) over
        a period of time. One may wish to image in a frame where the source is
        fixed. The parameter {tt movingsource} is for that. Setting it to a
        source that {tt measures} is aware of will force the imaging to
        realign (shift in SD imaging or phase rotation in interferometry
        imaging) the data so that the source appears fixed in the
        image. Obviously in doing so the background sources will be
        blurred. The coordinate system used to fix the source on is the one where
        the source is at the first time observed in the selected data.
        """
        schema = {'nx': {'type': 'cInt'}, 'ny': {'type': 'cInt'}, 'cellx': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'celly': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'stokes': {'type': 'cStr'}, 'phasecenter': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'mode': {'type': 'cStr'}, 'nchan': {'type': 'cInt'}, 'start': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'step': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'spw': {'type': 'cIntVec', 'coerce': [_coerce.to_list,_coerce.to_intvec]}, 'restfreq': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'outframe': {'type': 'cStr'}, 'veltype': {'type': 'cStr'}, 'facets': {'type': 'cInt'}, 'movingsource': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'distance': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'projection': {'type': 'cStr'}}
        doc = {'nx': nx, 'ny': ny, 'cellx': cellx, 'celly': celly, 'stokes': stokes, 'phasecenter': phasecenter, 'mode': mode, 'nchan': nchan, 'start': start, 'step': step, 'spw': spw, 'restfreq': restfreq, 'outframe': outframe, 'veltype': veltype, 'facets': facets, 'movingsource': movingsource, 'distance': distance, 'projection': projection}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _defineimage_result = self._swigobj.defineimage(_pc.document['nx'], _pc.document['ny'], _any_ec(_pc.document['cellx']), _any_ec(_pc.document['celly']), _str_ec(_pc.document['stokes']), _any_ec(_pc.document['phasecenter']), _str_ec(_pc.document['mode']), _pc.document['nchan'], _any_ec(_pc.document['start']), _any_ec(_pc.document['step']), _pc.document['spw'], _any_ec(_pc.document['restfreq']), _str_ec(_pc.document['outframe']), _str_ec(_pc.document['veltype']), _pc.document['facets'], _any_ec(_pc.document['movingsource']), _any_ec(_pc.document['distance']), _str_ec(_pc.document['projection']))
        return _defineimage_result

    def done(self):
        """This is used to totally stop the {tt imager} process. It is a good idea
        to conserve memory use on your machine by stopping the process once
        you no longer need it.
        """
        _done_result = self._swigobj.done()
        return _done_result

    def drawmask(self, image='', mask='', niter=int(0), npercycle=int(0), threshold='0 mJy'):
        """A mask image is an image with the same shape as the other images but
        with values between 0.0 and 1.0 as a pixel value. Mask images are used in
        imager to control the region selected in a deconvolution.
        
        drawmask  is used to interactively draw  regions over a template image which you want to allow deconvolution to occur.
        """
        schema = {'image': {'type': 'cStr'}, 'mask': {'type': 'cStr'}, 'niter': {'type': 'cInt'}, 'npercycle': {'type': 'cInt'}, 'threshold': {'type': 'cStr'}}
        doc = {'image': image, 'mask': mask, 'niter': niter, 'npercycle': npercycle, 'threshold': threshold}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _drawmask_result = _dict_dc(self._swigobj.drawmask(_str_ec(_pc.document['image']), _str_ec(_pc.document['mask']), _pc.document['niter'], _pc.document['npercycle'], _str_ec(_pc.document['threshold'])))
        return _drawmask_result

    def exprmask(self, mask='', expr=float(1.0)):
        """A mask image is an image with the same shape as the other images but
        with values between 0.0 and 1.0 as a pixel value. Mask images are used in
        imager to control the region selected in a deconvolution.
        
        In the Clark CLEAN, the mask image can usefully have any value between
        0.0 and 1.0. Intermediate value discourage but do not rule out
        selection of clean components in that region. This is accomplished by
        multiplying the residual image by the mask prior to entering the minor
        cycle. Note that if you do use a mask for the Clark or Hogbom Clean,
        it must cover only a quarter of the image. boxmask does not enforce
        this requirement.
        
        This function allows Lattice Express Language (LEL) expressions to
        be used in defining a mask. See the documentation on
        imagecalc for more details.
        """
        schema = {'mask': {'type': 'cStr'}, 'expr': {'type': 'cFloat', 'coerce': _coerce.to_float}}
        doc = {'mask': mask, 'expr': expr}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _exprmask_result = self._swigobj.exprmask(_str_ec(_pc.document['mask']), _pc.document['expr'])
        return _exprmask_result

    def feather(self, image='', highres='', lowres='', lowpsf='', effdishdiam=float(-1.0), lowpassfiltersd=False, async=False):
        """Basically the "imerg" algorithm of AIPS and SDE, or the "feather"
        algorithm of MIRIAD, we regrid the total power (or low resolution)
        image onto the interferometer (or high resolution) image, Fourier
        transform both the interferometer and single dish images, down weight
        the Fourier transform of the interferometer image by 1.0 - FT(low res psf),
        add the weighted interferometer Fourier plane to the single dish Fourier
        plane, and transform back into the image plane.
        
        The tapering is by the transform of a point spread function. If lowpsf
        is specified, that image is used, otherwise the appropriate telescope
        beam is used. The point spread function for a single dish image may be
        calculated using makeimage.
        
        {tt Advice:} Note that if you are feathering large images, you'd be advised to have
        the number of pixels along the X and Y axes to be composite numbers
        and  definitely not  prime numbers. In general FFTs work much faster on even
        and composite numbers. You may use subimage function of image
        tool to trim the number of pixels to something desirable.
        """
        schema = {'image': {'type': 'cStr'}, 'highres': {'type': 'cStr'}, 'lowres': {'type': 'cStr'}, 'lowpsf': {'type': 'cStr'}, 'effdishdiam': {'type': 'cFloat', 'coerce': _coerce.to_float}, 'lowpassfiltersd': {'type': 'cBool'}, 'async': {'type': 'cBool'}}
        doc = {'image': image, 'highres': highres, 'lowres': lowres, 'lowpsf': lowpsf, 'effdishdiam': effdishdiam, 'lowpassfiltersd': lowpassfiltersd, 'async': async}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _feather_result = self._swigobj.feather(_str_ec(_pc.document['image']), _str_ec(_pc.document['highres']), _str_ec(_pc.document['lowres']), _str_ec(_pc.document['lowpsf']), _pc.document['effdishdiam'], _pc.document['lowpassfiltersd'], _pc.document['async'])
        return _feather_result

    def filter(self, type='gaussian', bmaj=[ ], bmin=[ ], bpa=[ ], async=False):
        """Apply visibility tapering to emphasize certain scale structures.  The
        imaging tapers are applied to a Table column called IMAGING_WEIGHT,
        which may be plotted using
        tb and pl.
        plotweights.
        In addition, this column
        may be accessed directly using either the table
        or ms modules. Note that the taper is multiplicative and
        so the weights must be calculated first using
        weight. The points are not flagged!
        
        Note that the scale size to be emphasized is given in the image plane
        as the parameters of the corresponding Gaussian. Note also use of this
        function provides an optimum detection for the given scale size, which
        is not the same as requiring that the resulting dirty beam have the
        specified Gaussian fit. The resultant fitted beam size will {em very
        roughly} be the quadratic sum of the original beam and the specified
        beam. If you wish to obtain a specified beam, then the best approach
        is to perform this calculation and check the value obtained using
        imager.fitpsf.
        """
        schema = {'type': {'type': 'cStr'}, 'bmaj': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'bmin': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'bpa': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'async': {'type': 'cBool'}}
        doc = {'type': type, 'bmaj': bmaj, 'bmin': bmin, 'bpa': bpa, 'async': async}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _filter_result = self._swigobj.filter(_str_ec(_pc.document['type']), _any_ec(_pc.document['bmaj']), _any_ec(_pc.document['bmin']), _any_ec(_pc.document['bpa']), _pc.document['async'])
        return _filter_result

    def fitpsf(self, psf, async=False, bmaj={ }, bmin={ }, bpa={ }):
        """This fits an elliptical Gaussian to the point spread function
        and returns the fitted beam parameters. If psf image is not specified
        then a psf is made and used. The values for the beam fit
        are saved internally and used whenever needed (for example in the functions restore or smooth) until invalidated. The values
        are invalidated by selectvis, defineimage or any tool function that changes
        the weights. Use the function summary to check if there is a valid fitted psf stored internally.
        
        """
        schema = {'psf': {'type': 'cStr'}, 'async': {'type': 'cBool'}, 'bmaj': {'type': 'cDict'}, 'bmin': {'type': 'cDict'}, 'bpa': {'type': 'cDict'}}
        doc = {'psf': psf, 'async': async, 'bmaj': bmaj, 'bmin': bmin, 'bpa': bpa}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _fitpsf_result = self._swigobj.fitpsf(_str_ec(_pc.document['psf']), _pc.document['async'], _dict_ec(_pc.document['bmaj']), _dict_ec(_pc.document['bmin']), _dict_ec(_pc.document['bpa']))
        bmaj = _dict_dc(_dict_ec(_pc.document['bmaj']))
        bmin = _dict_dc(_dict_ec(_pc.document['bmin']))
        bpa = _dict_dc(_dict_ec(_pc.document['bpa']))
        return _fitpsf_result

    def fixvis(self, fields=[ int(-1) ], phasedirs=[  ], refcode='', distances=[ float(0.0) ], datacolumn='all'):
        """Corrects UVW coordinates and optionally the visibilities for various
        effects that can be calculated without fitting a model to the data.
        
        The effects include:
        begin{itemize}
        item changing the phase tracking center(s),
        item correcting for differential aberration,  (Not yet implemented)
        item changing the equinox (i.e. B1950_VLA to J2000 or APP, etc.) of the UVW coordinates,
        item changing the projection, as in (-)NCP to SIN.  (Not yet implemented),
        item refocusing.
        end{itemize}
        
        """
        schema = {'fields': {'type': 'cIntVec', 'coerce': [_coerce.to_list,_coerce.to_intvec]}, 'phasedirs': {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}, 'refcode': {'type': 'cStr'}, 'distances': {'type': 'cFloatVec', 'coerce': [_coerce.to_list,_coerce.to_floatvec]}, 'datacolumn': {'type': 'cStr'}}
        doc = {'fields': fields, 'phasedirs': phasedirs, 'refcode': refcode, 'distances': distances, 'datacolumn': datacolumn}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _fixvis_result = self._swigobj.fixvis(_pc.document['fields'], [_str_ec(_x) for _x in _pc.document['phasedirs']], _str_ec(_pc.document['refcode']), _pc.document['distances'], _str_ec(_pc.document['datacolumn']))
        return _fixvis_result

    def ft(self, model=[  ], complist='', incremental=False, phasecentertime=float(-1.0)):
        """Fourier transform the specified model (and optionally componentlist)
        and insert into the MODEL_DATA column. The current contents of
        the MODEL_DATA column are replaced unless incremental is set to
        T (in which case the results are added to the column).
        phasecentertime is optional useful for field which is have time varying phasecenters (polynomials or ephemerides phasecenters). The default is to calculate the phasecenter at each time in the data but the time provided here can be used to calculate phasecenters
        """
        schema = {'model': {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}, 'complist': {'type': 'cStr'}, 'incremental': {'type': 'cBool'}, 'phasecentertime': {'type': 'cFloat', 'coerce': _coerce.to_float}}
        doc = {'model': model, 'complist': complist, 'incremental': incremental, 'phasecentertime': phasecentertime}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _ft_result = self._swigobj.ft([_str_ec(_x) for _x in _pc.document['model']], _str_ec(_pc.document['complist']), _pc.document['incremental'], _pc.document['phasecentertime'])
        return _ft_result

    def getweightgrid(self, type='imaging', wgtimages=[  ]):
        """This is a utility function when running multi imager processes in parallel on subsection of an ms/data independently
        One would wish to weight the dirty image before averaging or set the imaging weight density (when using unform or
        Brigg's style weighting) to account for all the data being used. This is {bf NOT} for the general user but for people who
        are parallelizing at the scripting level.
        
        {bf imaging}: will return a the weight griddensity 
        
        {bf ftweight}: will put the FT-machine weight images in the names given in wgtimage parameters..these may be needed to average residual images from different processes running seperately on different section of the data.
        """
        schema = {'type': {'type': 'cStr'}, 'wgtimages': {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}}
        doc = {'type': type, 'wgtimages': wgtimages}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _getweightgrid_result = _any_dc(self._swigobj.getweightgrid(_str_ec(_pc.document['type']), [_str_ec(_x) for _x in _pc.document['wgtimages']]))
        return _getweightgrid_result

    def linearmosaic(self, images=[  ], mosaic='', fluxscale='', sensitivity='', fieldids=[ int(0) ], usedefaultvp=True, vptable='', async=False):
        """Make a linear mosaic of several images.
        Currently, the pointing center is not specified in the image, so
        we specify the pointing center in terms of the row numbers of the FIELD subtable.
        """
        schema = {'images': {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}, 'mosaic': {'type': 'cStr'}, 'fluxscale': {'type': 'cStr'}, 'sensitivity': {'type': 'cStr'}, 'fieldids': {'type': 'cIntVec', 'coerce': [_coerce.to_list,_coerce.to_intvec]}, 'usedefaultvp': {'type': 'cBool'}, 'vptable': {'type': 'cStr'}, 'async': {'type': 'cBool'}}
        doc = {'images': images, 'mosaic': mosaic, 'fluxscale': fluxscale, 'sensitivity': sensitivity, 'fieldids': fieldids, 'usedefaultvp': usedefaultvp, 'vptable': vptable, 'async': async}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _linearmosaic_result = self._swigobj.linearmosaic([_str_ec(_x) for _x in _pc.document['images']], _str_ec(_pc.document['mosaic']), _str_ec(_pc.document['fluxscale']), _str_ec(_pc.document['sensitivity']), _pc.document['fieldids'], _pc.document['usedefaultvp'], _str_ec(_pc.document['vptable']), _pc.document['async'])
        return _linearmosaic_result

    def make(self, image='', async=False):
        """Make an empty image using the current image parameters. Often this is
        unnecessary, but you will typically need to use this if you wish to
        deconvolve a set of images. The steps are to make the empty images
        that you require to be deconvolved, and then pass them into clean as a
        vector of strings.
        """
        schema = {'image': {'type': 'cStr'}, 'async': {'type': 'cBool'}}
        doc = {'image': image, 'async': async}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _make_result = self._swigobj.make(_str_ec(_pc.document['image']), _pc.document['async'])
        return _make_result

    def predictcomp(self, objname='', standard='', epoch=[ ], freqs=[ float(1.0e11) ], pfx='predictcomp'):
        """Make a component list for an object recognized by standard, one of setjy's
        flux density standards.
        """
        schema = {'objname': {'type': 'cStr'}, 'standard': {'type': 'cStr'}, 'epoch': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'freqs': {'type': 'cFloatVec', 'coerce': [_coerce.to_list,_coerce.to_floatvec]}, 'pfx': {'type': 'cStr'}}
        doc = {'objname': objname, 'standard': standard, 'epoch': epoch, 'freqs': freqs, 'pfx': pfx}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _predictcomp_result = _str_dc(self._swigobj.predictcomp(_str_ec(_pc.document['objname']), _str_ec(_pc.document['standard']), _any_ec(_pc.document['epoch']), _pc.document['freqs'], _str_ec(_pc.document['pfx'])))
        return _predictcomp_result

    def makeimage(self, type='observed', image='', compleximage='', verbose=True, async=False):
        """This tool function actually does gridding (and Fourier inversion if
        needed) of visibility data to make an image. It allows calculation of
        various types of image:
        begin{description}
        item[observed] Make the dirty image from the DATA column ({em default})
        item[model] Make the dirty image from the MODEL_DATA column
        item[corrected] Make the dirty image from the CORRECTED_DATA column
        item[residual] Make the dirty image from the difference of the
        CORRECTED_DATA and MODEL_DATA columns
        item[psf] Make the point spread function
        item[singledish] Make a single dish image
        item[coverage] Make a single dish coverage image
        item[holography] Make a complex holography image
        item[pb] Make the primary beam as defined by setvp
        end{description}
        
        Note the full {tt imager} equation is not used and so, for example, the
        primary beam correction is not performed. Use
        restore to get a residual image
        using the full {tt imager} equation where primary beam correction is
        performed.
        
        A position shift can be applied when specifying the image parameters
        with defineimage. If a shift is specified then
        the uvw coordinates are reprojected prior to gridding, and a phase
        rotation is applied. If the image is a PSF then no phase shift is
        applied but the uvw are recomputed. To see the effects of the uvw
        reprojected, you can use the
        plotuv function.
        
        If desired, the full complex image (before conversion to stokes
        I,Q,U,V) may be retained. Note that the image
        tool cannot load a complex image directly. Instead, use the
        imagecalc constructor
        to take {em e.g.}  the real and imaginary parts of the image.
        
        For making single dish and holography images, the data are convolved onto the
        grid using a one of a number of options:
        begin{description}
        item[gridfunction='SF'] Circularly symmetric prolate spheroidal wavefunction.
        This is always the same function in pixels.  To get this to match to
        the antenna primary beam, the optimum cellsize to use in constructing
        the image is the antenna primary beam half-width-half-maximum times
        1.20192.
        item[gridfunction='BOX'] Nearest neighbor gridding.
        item[gridfunction='PB'] The telescope primary beam is used as the
        convolution function. This function is the same in arcseconds,
        independent of the cellsize. This choice is optimum in the least
        squares sense. To override the default choice of telescope primary beam
        for a given telescope, use the function
        setvp. Usually the default will be acceptable.
        end{description}
        
        To make a reasonable approximation to the sky, one should divide
        the type='singledish' image by the type='coverage' image, thresholding
        at some level. For example:
        
        begin{verbatim}
        
        ia.open('scanweight');
        ia.statistics(s);
        threshold = s.max / 10.0;
        #
        ia.imagecalc('sdimage',
        pixels=spaste('scanimage[scanweight>', threshold,
        ']/scanweight[scanweight>', threshold, ']'))
        ###ia.view(raster=True, axislabels=True);
        end{verbatim}
        """
        schema = {'type': {'type': 'cStr'}, 'image': {'type': 'cStr'}, 'compleximage': {'type': 'cStr'}, 'verbose': {'type': 'cBool'}, 'async': {'type': 'cBool'}}
        doc = {'type': type, 'image': image, 'compleximage': compleximage, 'verbose': verbose, 'async': async}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _makeimage_result = self._swigobj.makeimage(_str_ec(_pc.document['type']), _str_ec(_pc.document['image']), _str_ec(_pc.document['compleximage']), _pc.document['verbose'], _pc.document['async'])
        return _makeimage_result

    def makemodelfromsd(self, sdimage='', modelimage='', sdpsf='', maskimage=''):
        """This functions use an image from a single dish and make a model
        (clean component) image out of it. This allows one to use this as the
        starting model in a deconvoltion  function e.g
        clean or mem
        This provides an alternative to
        feather.
        The difference between the two is that in {tt feather} the
        interferometer image is deconvolved first and the single dish image is
        put in at the end. Whereas if one starts with a model from the single
        dish image it will give a different starting point for the deconvolving
        algorithm to interpolate the missing short baseline.
        
        The function setsdoptions may be used to set
        a factor by which to scale the SD image, if necessary.
        
        The {tt sdpsf} parameter (optional) should be used if an external PSF image of the
        single dish is needed to calculate the beam parameters of the primary
        beam of the dish. This is usually needed if the dish image is from a
        non standard telescope or the beam is not in the {tt CASA} system.
        
        The {tt mask} is a mask image that may be needed to be used for
        clean.  This is usually the case when the dish image does not fully
        cover the field defined by defineimage.
        """
        schema = {'sdimage': {'type': 'cStr'}, 'modelimage': {'type': 'cStr'}, 'sdpsf': {'type': 'cStr'}, 'maskimage': {'type': 'cStr'}}
        doc = {'sdimage': sdimage, 'modelimage': modelimage, 'sdpsf': sdpsf, 'maskimage': maskimage}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _makemodelfromsd_result = self._swigobj.makemodelfromsd(_str_ec(_pc.document['sdimage']), _str_ec(_pc.document['modelimage']), _str_ec(_pc.document['sdpsf']), _str_ec(_pc.document['maskimage']))
        return _makemodelfromsd_result

    def mask(self, image='', mask='', threshold=[ ], async=False):
        """A mask image is an image with the same shape as the other images but
        with values between 0.0 and 1.0 as a pixel value. Mask images are used
        in {tt imager} to control the region selected in a deconvolution.
        One makes a mask image by clipping the I part of the restored image
        (this function) or via the boxmask,
        regionmask, and
        exprmask functions.  In this
        function, all points greater than the threshold are set to unity. The
        mask is the same in I,Q,U, and V. Note that
        exprmask is the most powerful
        method for making mask images.
        
        In the Clark CLEAN, the mask image can usefully have any value between
        0.0 and 1.0. Intermediate value discourage but do not rule out
        selection of clean components in that region. This is accomplished by
        multiplying the residual image by the mask prior to entering the minor
        cycle.
        
        Note that if you do use a mask for the Clark or Hogbom Clean, it must
        cover only a quarter of the image. It is particularly important to
        check this when creating an image using a threshold. If it extends
        further, the easiest fix is to use
        getchunk and
        getchunk to set parts of it to zero.
        """
        schema = {'image': {'type': 'cStr'}, 'mask': {'type': 'cStr'}, 'threshold': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'async': {'type': 'cBool'}}
        doc = {'image': image, 'mask': mask, 'threshold': threshold, 'async': async}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _mask_result = self._swigobj.mask(_str_ec(_pc.document['image']), _str_ec(_pc.document['mask']), _any_ec(_pc.document['threshold']), _pc.document['async'])
        return _mask_result

    def mem(self, algorithm='entropy', niter=int(20), sigma=[ ], targetflux=[ ], constrainflux=False, displayprogress=False, model=[  ], keepfixed=[ False ], complist='', prior=[  ], mask=[  ], image=[  ], residual=[  ], async=False):
        """Makes a mem image using either the Cornwell-Evans maximum entropy or
        maximum emptiness algorithms, using the single field or multi-field
        contexts. The maximum entropy algorithm is the default. The mem is performed
        on the residual image calculated from the visibility data currently
        selected. Hence the first step performed in mem is to transform the
        current model or models (optionally including a componentlist) to fill
        in the MODEL_DATA column, and then inverse transform the residual
        visibilities to get a residual image. This residual image is then
        deconvolved using the corresponding point spread function. This means that
        the initial model is used as the starting point for the
        deconvolution. Thus if you want to restart a mem, simply set the
        model to the model that was previously produced by clean.
        
        Mask images are used to constrain the region that is to be
        deconvolved. To make mask images, use either
        boxmask (to define a mask via the
        corner locations blc and trc) or mask (to
        define a mask via thresholding an existing image). The default mask is
        the inner quarter of the image.
        
        The MEM deconvolution only operates on one Stokes parameter at a time.
        Joint MEM deconvolution for multiple Stokes parameters will be
        implemented in the future.
        
        Some reference regarding MEM :
        Cornwell and Evans,
        Astronomy and Astrophysics (ISSN 0004-6361), vol. 143, no. 1, Feb. 1985,
        p. 77-83.
        
        Narayan and  Nityananda,
        Annual review of astronomy and astrophysics. Volume 24 (A87-26730
        10-90). Palo Alto, CA, Annual Reviews, Inc., 1986, p. 127-170.
        
        The mem algorithms possible are:
        begin{description}
        item[Cornwell-Evans Maximum Entropy (entropy)] The classic "vm" or "vtess"
        deconvolution algorithm.
        item[Cornwell-Evans Maximum Emptiness (emptiness)] The historic, but
        largely undocumented, modification to the Cornwell-Evans algorithm
        which seeks a model image which is consistent with the data and
        simultaneously minimizes the number of pixels with no emission
        (meaning "with pixel values below the noise level").
        item[Multi-field Maximum Entropy (mfentropy)] Deconvolution is split
        into minor and major cycles. For each field, the MEM analog of a Clark
        Clean minor cycle is performed. In the major cycle, the emission thus
        modelled is subtracted either from the original visibilities (for
        multiple fields) or using a convolution (for only one field). The
        latter is much faster.
        item[Multi-field Maximum Emptiness (mfemptiness)] Just like {tt mfentropy},
        but with emptiness.
        end{description}
        
        The multi-field mem ({tt mfentropy} or {tt mfemptiness}) should be
        used if either of two conditions hold:
        begin{enumerate}
        item Multiple fields are to be deconvolved simultaneously {bf OR}
        item Primary beam correction is enabled. In this case, a
        mosaiced mem is performed.
        end{enumerate}
        
        Note that for the single pointing algorithms, only a quarter of the
        image may be deconvolved. If no mask is set, then the deconvolved
        region defaults to the inner quarter. If a mask larger than a quarter
        of the image is set, then only the quarter starting at the bottom left
        corner is used.  However, for the multi-field imaging, the entire
        field may be imaged because the major cycles either do an exact
        subtraction from the visibilities or because PSF extent is more than
        twice the extent of the primary beam support.
        
        Before {tt mem} can be run, you must run {tt selectvis} and {tt defineimage}.
        Before {tt mem} can be run with a multi-field algorithm, you should run
        {tt setvp}.  You may want to run {tt setmfcontrol} before running {tt mem}
        with a multi-field algorithm, though the default control values
        may be acceptable.
        """
        schema = {'algorithm': {'type': 'cStr'}, 'niter': {'type': 'cInt'}, 'sigma': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'targetflux': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'constrainflux': {'type': 'cBool'}, 'displayprogress': {'type': 'cBool'}, 'model': {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}, 'keepfixed': {'type': 'cBoolVec'}, 'complist': {'type': 'cStr'}, 'prior': {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}, 'mask': {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}, 'image': {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}, 'residual': {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}, 'async': {'type': 'cBool'}}
        doc = {'algorithm': algorithm, 'niter': niter, 'sigma': sigma, 'targetflux': targetflux, 'constrainflux': constrainflux, 'displayprogress': displayprogress, 'model': model, 'keepfixed': keepfixed, 'complist': complist, 'prior': prior, 'mask': mask, 'image': image, 'residual': residual, 'async': async}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _mem_result = self._swigobj.mem(_str_ec(_pc.document['algorithm']), _pc.document['niter'], _any_ec(_pc.document['sigma']), _any_ec(_pc.document['targetflux']), _pc.document['constrainflux'], _pc.document['displayprogress'], [_str_ec(_x) for _x in _pc.document['model']], _pc.document['keepfixed'], _str_ec(_pc.document['complist']), [_str_ec(_x) for _x in _pc.document['prior']], [_str_ec(_x) for _x in _pc.document['mask']], [_str_ec(_x) for _x in _pc.document['image']], [_str_ec(_x) for _x in _pc.document['residual']], _pc.document['async'])
        return _mem_result

    def nnls(self, model=[  ], keepfixed=[ False ], complist='', niter=int(0), tolerance=float(1e-06), fluxmask=[  ], datamask=[  ], image=[  ], residual=[  ], async=False):
        """Solve for the model brightness using the Briggs' Non-Negative Least
        Squares algorithm. Since NNLS works only on the $I$ image, the $I$
        pixels in the current image is set to zero where the fluxmask is $> 0.0$,
        then NNLS is used to estimate the $I$-pixels for that region.
        The deconvolution is performed on the residual image calculated from
        the visibility data currently selected. Hence the first step performed
        in clean is to transform the current model to fill in the MODEL_DATA
        column, and then inverse transform the residual visibilities to get a
        residual image. This residual image is then deconvolved using the
        corresponding point spread function.
        
        Some other points to remember are that rather than explicit boxes,
        mask images are used to constrain the region that is to be
        deconvolved.  For NNLS, there are two masks, the fluxmask specifying
        the region within which flux is allowed, and the datamask specifying
        the region of the dirty image to be used as constraints. Typically the
        datamask will be somewhat larger than the fluxmask. On a large
        machine, a practical limit to both will be about 5000-6000
        pixels. Hence NNLS is only useful for compact tools.  (For more
        details, see the htmladdnormallink{Briggs thesis}{briggsURL}).  To
        make mask images, use either boxmask (to
        define a mask via the corner locations blc and trc) or
        mask (to define a mask via
        thresholding an existing image).
        
        On the canonical aipspp machine with 64MBytes of physical memory,
        you should try to keep the product of the pixels in the fluxmask
        and the datamask below about 5-10 million. Otherwise the
        solution phase will swap badly.
        """
        schema = {'model': {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}, 'keepfixed': {'type': 'cBoolVec'}, 'complist': {'type': 'cStr'}, 'niter': {'type': 'cInt'}, 'tolerance': {'type': 'cFloat', 'coerce': _coerce.to_float}, 'fluxmask': {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}, 'datamask': {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}, 'image': {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}, 'residual': {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}, 'async': {'type': 'cBool'}}
        doc = {'model': model, 'keepfixed': keepfixed, 'complist': complist, 'niter': niter, 'tolerance': tolerance, 'fluxmask': fluxmask, 'datamask': datamask, 'image': image, 'residual': residual, 'async': async}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _nnls_result = self._swigobj.nnls([_str_ec(_x) for _x in _pc.document['model']], _pc.document['keepfixed'], _str_ec(_pc.document['complist']), _pc.document['niter'], _pc.document['tolerance'], [_str_ec(_x) for _x in _pc.document['fluxmask']], [_str_ec(_x) for _x in _pc.document['datamask']], [_str_ec(_x) for _x in _pc.document['image']], [_str_ec(_x) for _x in _pc.document['residual']], _pc.document['async'])
        return _nnls_result

    def open(self, thems='', compress=False, usescratch=False):
        """Close the current MeasurementSet and open a new MeasurementSet
        instead. The current state of {tt imager} is retained, except for
        the data selection.
        """
        schema = {'thems': {'type': 'cStr'}, 'compress': {'type': 'cBool'}, 'usescratch': {'type': 'cBool'}}
        doc = {'thems': thems, 'compress': compress, 'usescratch': usescratch}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _open_result = self._swigobj.open(_str_ec(_pc.document['thems']), _pc.document['compress'], _pc.document['usescratch'])
        return _open_result

    def pb(self, inimage='', outimage='', incomps='', outcomps='', operation='apply', pointingcenter=[ ], parangle=[ ], pborvp='pb', async=False):
        """Multiply ({tt operation='apply'}) or divide ({tt operation='correct'})
        by the primary beam function.  The primary beam can be applied to images and/or
        Componentlists.
        
        If {tt pointingcenter==false} then you must specify {tt inimage}
        and the pointing center is taken from its reference direction.
        Otherwise, {tt pointingcenter} must be a Direction measure.
        It cannot take on the value {tt True}.
        
        The applied primary beam function is deterimed as follows.  If you used
        function Imager.setvp to set an external
        voltage pattern table, then this is where the applied primary beam will
        come from (regardless of whether you set {tt inimage} or not).  If you
        did not run this function, then you must supply argument {tt inimage}.
        The telescope name embedded in its Coordinate System will be used to
        determine the primary beam function.
        """
        schema = {'inimage': {'type': 'cStr'}, 'outimage': {'type': 'cStr'}, 'incomps': {'type': 'cStr'}, 'outcomps': {'type': 'cStr'}, 'operation': {'type': 'cStr'}, 'pointingcenter': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'parangle': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'pborvp': {'type': 'cStr'}, 'async': {'type': 'cBool'}}
        doc = {'inimage': inimage, 'outimage': outimage, 'incomps': incomps, 'outcomps': outcomps, 'operation': operation, 'pointingcenter': pointingcenter, 'parangle': parangle, 'pborvp': pborvp, 'async': async}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _pb_result = self._swigobj.pb(_str_ec(_pc.document['inimage']), _str_ec(_pc.document['outimage']), _str_ec(_pc.document['incomps']), _str_ec(_pc.document['outcomps']), _str_ec(_pc.document['operation']), _any_ec(_pc.document['pointingcenter']), _any_ec(_pc.document['parangle']), _str_ec(_pc.document['pborvp']), _pc.document['async'])
        return _pb_result

    def plotsummary(self):
        """Performs a simple plot of the field and spectral window IDs
        versus time (after sorting).
        """
        _plotsummary_result = self._swigobj.plotsummary()
        return _plotsummary_result

    def plotuv(self, rotate=False):
        """Performs a simple plot of the uv coverage of all selected data.
        
        Optionally, plotuv will rotate the uvw coordinates to the
        specified phase center (set via defineimage).
        """
        schema = {'rotate': {'type': 'cBool'}}
        doc = {'rotate': rotate}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _plotuv_result = self._swigobj.plotuv(_pc.document['rotate'])
        return _plotuv_result

    def plotvis(self, type='all', increment=int(1)):
        """Performs a simple plot of the visibility amplitudes of all selected data.
        """
        schema = {'type': {'type': 'cStr'}, 'increment': {'type': 'cInt'}}
        doc = {'type': type, 'increment': increment}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _plotvis_result = self._swigobj.plotvis(_str_ec(_pc.document['type']), _pc.document['increment'])
        return _plotvis_result

    def plotweights(self, gridded=False, increment=int(1)):
        """Performs a plot of the visibility weights of all selected data (stored in
        the IMAGING_WEIGHT column of the MeasurementSet).
        The plot can be of the gridded weights (type='gridded') or
        ungridded.
        
        
        """
        schema = {'gridded': {'type': 'cBool'}, 'increment': {'type': 'cInt'}}
        doc = {'gridded': gridded, 'increment': increment}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _plotweights_result = self._swigobj.plotweights(_pc.document['gridded'], _pc.document['increment'])
        return _plotweights_result

    def regionmask(self, mask='', region={ }, boxes=[ ], circles=[ ], value=float(1.0)):
        """A mask image is an image with the same shape as the other images but
        with values between 0.0 and 1.0 as a pixel value. Mask images are used in
        imager to control the region selected in a deconvolution.
        
        In the Clark CLEAN, the mask image can usefully have any value between
        0.0 and 1.0. Intermediate value is discouraged but do not rule out
        selection of clean components in that region. This is accomplished by
        multiplying the residual image by the mask prior to entering the minor
        cycle. Note that if you do use a mask for the Clark or Hogbom Clean,
        it must cover only a quarter of the image. {tt regionmask} does not enforce
        this requirement.
        
        The function regionmask also allows multiple regions to be used. A record of the regions can be made as in the example below.
        
        Regions can be made in many different ways using the
        regionmanager functions. An example
        using wbox function is given
        below. The default regionmanager tool 'rg' can be used for cases the user want to have flexibility in manipulating regions. The {tt region} parameter takes a record that comes from the regionmanager output.
        The parameter boxes allow the user to sent in a list of 4 elements numbers representing blc's and trc's
        
        If both the parameters, {tt regions} and {tt boxes} are used the a union is done with the two sets of region thus defined.
        
        
        
        
        """
        schema = {'mask': {'type': 'cStr'}, 'region': {'type': 'cDict'}, 'boxes': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'circles': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'value': {'type': 'cFloat', 'coerce': _coerce.to_float}}
        doc = {'mask': mask, 'region': region, 'boxes': boxes, 'circles': circles, 'value': value}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _regionmask_result = self._swigobj.regionmask(_str_ec(_pc.document['mask']), _dict_ec(_pc.document['region']), _any_ec(_pc.document['boxes']), _any_ec(_pc.document['circles']), _pc.document['value'])
        return _regionmask_result

    def regiontoimagemask(self, mask='', region={ }, boxes=[ ], circles=[ ], value=float(1.0)):
        """This function is very similar to regionmask function
        except that the mask image has to be existant already and this is an
        independent helper function (i.e does not care about the state of the imager tool... e.g does not need imager to have an
        attached ms).
        
        
        
        
        """
        schema = {'mask': {'type': 'cStr'}, 'region': {'type': 'cDict'}, 'boxes': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'circles': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'value': {'type': 'cFloat', 'coerce': _coerce.to_float}}
        doc = {'mask': mask, 'region': region, 'boxes': boxes, 'circles': circles, 'value': value}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _regiontoimagemask_result = self._swigobj.regiontoimagemask(_str_ec(_pc.document['mask']), _dict_ec(_pc.document['region']), _any_ec(_pc.document['boxes']), _any_ec(_pc.document['circles']), _pc.document['value'])
        return _regiontoimagemask_result

    def residual(self, model=[  ], complist='', image=[  ], async=False):
        """Calculate the residuals corresponding to the model and
        componentlist. {em Note that the model visibilities are updated}.
        """
        schema = {'model': {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}, 'complist': {'type': 'cStr'}, 'image': {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}, 'async': {'type': 'cBool'}}
        doc = {'model': model, 'complist': complist, 'image': image, 'async': async}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _residual_result = self._swigobj.residual([_str_ec(_x) for _x in _pc.document['model']], _str_ec(_pc.document['complist']), [_str_ec(_x) for _x in _pc.document['image']], _pc.document['async'])
        return _residual_result

    def restore(self, model=[  ], complist='', image=[  ], residual=[  ], async=False):
        """Restore the residuals to a smoothed version of the model. The model
        images are convolved with the specified Gaussian beam and then the
        residual images are added.  {em Note that the model visibilities are
        updated and thus reflect the model and componentlist that was
        used.}. Use setbeam to set the beam
        parameters.
        """
        schema = {'model': {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}, 'complist': {'type': 'cStr'}, 'image': {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}, 'residual': {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}, 'async': {'type': 'cBool'}}
        doc = {'model': model, 'complist': complist, 'image': image, 'residual': residual, 'async': async}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _restore_result = self._swigobj.restore([_str_ec(_x) for _x in _pc.document['model']], _str_ec(_pc.document['complist']), [_str_ec(_x) for _x in _pc.document['image']], [_str_ec(_x) for _x in _pc.document['residual']], _pc.document['async'])
        return _restore_result

    def updateresidual(self, model=[  ], complist='', image=[  ], residual=[  ]):
        """This function is for efficiency and speed purpose only. Same as restore
        It is to be used after you have used clean or mem ...but you wish to tweak the model image, say by clipping unwanted components and it will avoid unnecessary recalculating of psf but will do a proper prediction of the new model visibilities and recalculate residual and restored images.
        """
        schema = {'model': {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}, 'complist': {'type': 'cStr'}, 'image': {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}, 'residual': {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}}
        doc = {'model': model, 'complist': complist, 'image': image, 'residual': residual}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _updateresidual_result = self._swigobj.updateresidual([_str_ec(_x) for _x in _pc.document['model']], _str_ec(_pc.document['complist']), [_str_ec(_x) for _x in _pc.document['image']], [_str_ec(_x) for _x in _pc.document['residual']])
        return _updateresidual_result

    def sensitivity(self, async=False, pointsource={ }, relative=float(0), sumweights=float(0), senrec={ }):
        """NB: The implementation in this function will be removed for CASA v4.5.
        We now recommend that the im.apparentsens() function be used instead
        of this one, especially if their weights are initialized and
        calibrated.
        
        Calculate the point source sensitivity for the selected data, both
        absolutely and relatively (to that for natural weighting).
        
        To do the calculation, we use the imaging weights (in the
        column called IMAGING_WEIGHT) as calculated from the WEIGHT column,
        and an estimate of the effective net bandwidth and integration time.
        The calculation therefore includes all the effects
        of weight and
        filter.
        
        The output is an array with mixed elements.  Counting from zero, the
        second element (out[1]) is the net sensitivity, third element is the
        ratio of the reduction in sensitivity due to the chosen weighting
        scheme.  This ratio is 1.0 for Natural weight and greater than one for
        all other weighting schemes.  (NOTE: Further testing is required of
        this value and hence this is kept separate for now).
        
        The sensitivity calculations require Tsys and collecting area of
        the antenna. These quantities are not known from the MS.  The
        sensitivity is therefore returned in units of Jy m^2/K.  Multiplying the
        second elements with the ration of the Tsys and effective antenna
        collecting area will give the sensitivity in Jy/beam units.
        
        The fourth elements of the return value is a record with the following
        keys: 'nbaselines', 'effectiveintegration', 'effectivebandwidth',
        'sumwt' and 'spwid'.  These can be used to get the number of baselines
        used, effective integration time (in sec), the effective bandwidth (in
        Hz), the sum of weights and the absolute spectral window IDs used.
        """
        schema = {'async': {'type': 'cBool'}, 'pointsource': {'type': 'cDict'}, 'relative': {'type': 'cFloat', 'coerce': _coerce.to_float}, 'sumweights': {'type': 'cFloat', 'coerce': _coerce.to_float}, 'senrec': {'type': 'cDict'}}
        doc = {'async': async, 'pointsource': pointsource, 'relative': relative, 'sumweights': sumweights, 'senrec': senrec}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _sensitivity_result = self._swigobj.sensitivity(_pc.document['async'], _dict_ec(_pc.document['pointsource']), _pc.document['relative'], _pc.document['sumweights'], _dict_ec(_pc.document['senrec']))
        pointsource = _dict_dc(_dict_ec(_pc.document['pointsource']))
        relative = _pc.document['relative']
        sumweights = _pc.document['sumweights']
        senrec = _dict_dc(_dict_ec(_pc.document['senrec']))
        return _sensitivity_result

    def apparentsens(self, async=False, pointsource=float(0), relative=float(0)):
        """This function calculates the point source sensitivity for the data
        selected by im.selectvis(...), and according to the imaging weighting
        parameters specified in im.weight(...) and im.defineimage(...).  The
        calculation is performed solely using the weight information stored in
        the MS WEIGHT column (WEIGHT_SPECTRUM tbd), and as adjusted by the net
        imaging weighting function (natural, uniform, robust, taper, etc.).
        Therefore, it is assumed that the MS WEIGHTs have been properly
        initialized and calibrated along with the visibility data.  As long as
        the WEIGHTs are in the inverse square units of the visibilities (i.e.,
        inverse variance weights), the calculation should yield the real
        theoretical imaging sensitivity for data at any stage of the
        calibration (though data at early and intermediate stages of
        calibration may not be sufficiently coherent for imaging at high--or
        even modest--fidelity).
        
        Two values are reported in the logger and returned (see example
        below). First, the apparent sensitivity (in the units implied by the
        WEIGHTs' units), for the specified imaging weighting scheme.  Second,
        a unitless factor describing the ratio of the apparent sensitivity to
        that obtained with pure 'natural' weighting (the nominal peak
        sensitivity).  When 'natural' weighting is selected, this ratio factor
        will be 1.0; all other weighting choices will yield an apparent
        sensitivity ratio greater than 1.0.
        
        Currently, this function reports only the continuum sensitivity for
        the selected data, and in particular, for the aggregate bandwidth
        indicated by the spectral window selection.  The calculation further
        assumes that the visibility samples are each entirely independent
        (i.e., no redundant samples such as would occur for overlapping
        spectral windows).
        
        A future version of this function will support reporting a sensitivity
        spectrum for the spectral line case (including support for
        WEIGHT_SPECTRUM).  For now, spectral line sensitivity may be
        reasonably estimated by dividing the reported sensitivity by the
        square root of the fractional bandwidth of a single image channel, or
        by selecting a bandwidth matching the width of a single image channel.
        """
        schema = {'async': {'type': 'cBool'}, 'pointsource': {'type': 'cFloat', 'coerce': _coerce.to_float}, 'relative': {'type': 'cFloat', 'coerce': _coerce.to_float}}
        doc = {'async': async, 'pointsource': pointsource, 'relative': relative}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _apparentsens_result = self._swigobj.apparentsens(_pc.document['async'], _pc.document['pointsource'], _pc.document['relative'])
        pointsource = _pc.document['pointsource']
        relative = _pc.document['relative']
        return _apparentsens_result

    def setbeam(self, bmaj=[ ], bmin=[ ], bpa=[ ], async=False):
        """This sets the clean beam that will be used in all restoration
        operations.
        """
        schema = {'bmaj': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'bmin': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'bpa': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'async': {'type': 'cBool'}}
        doc = {'bmaj': bmaj, 'bmin': bmin, 'bpa': bpa, 'async': async}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _setbeam_result = self._swigobj.setbeam(_any_ec(_pc.document['bmaj']), _any_ec(_pc.document['bmin']), _any_ec(_pc.document['bpa']), _pc.document['async'])
        return _setbeam_result

    def selectvis(self, vis='', nchan=[ int(-1) ], start=[ int(0) ], step=[ int(1) ], spw=[ ], field=[ ], baseline=[ ], time=[ ], scan=[ ], intent='', observation=[ ], uvrange=[ ], taql='', usescratch=False, datainmemory=False, writeaccess=True):
        """This setup tool function selects which data are to be used
        subsequently. After invocation of selectvis, only the selected
        data are operated on. Thus, for example, in imaging, only the selected
        data are gridded into an image, and in plotting, only the
        selected data are plotted.
        
        Data can be selected by field and spectral window ids. Note that
        all data thus selected are passed to imaging, and may or
        may not be imaged, depending on how the image was constructed
        using defineimage. For example,
        in mosaicing, use fieldid in defineimage to control what pointing
        is used to define the field center, and use fieldid in selectvis
        to control what pointings are used in the imaging.
        
        For spectral processing, it is possible to make cubes out
        multi-spectral window selections but the selection and combination can
        be a bit confusing (any hint at how to make it clearer is welcome).
        
        If the default values are not used, then data to be used can be selected channel wise. The
        
        begin{description}
        item[nchan]   is the number of data channels selected. It
        defaults to -1 (interpreted as all channels).
        item[start] is the first channel from input dataset that is to be used.
        It defaults to 0 (i.e. first channel).
        item[step] gives the increment between selected input channels. It defaults to 1 channel. A value of {tt n}  means that {tt n-1} data channels will not not be used.
        end{description}
        
        
        
        By choosing the parameters for selectvis and defineimage correctly,
        one may obtain various mappings of visibility channels to image
        channels. For example, to average 512 visibility channels into 64
        image channels (producing image channels consisting of 8
        visibility channels):
        
        
        im.defineimage(mode='channel', spw=0, nchan=64, start=1, step=8);
        im.selectvis(spw=0, nchan=512, start=1, step=1)
        im.clean(.....);
        
        
        This averages the spectral channels during the gridding process. If
        one wanted to only include every 8th channel in the
        deconvolution, one would do:
        
        
        im.selectvis(nchan=64, start=1, step=8)
        im.defineimage(mode='channel', nchan=64, start=1, step=8);
        im.clean(....);
        
        
        For velocity and opticalvelocity modes, the mstart and mstep
        are the start and step velocities as strings.
        
        
        im.defineimage(mode='velocity', nchan=64, start='20 km/s', step='-100m/s');
        im.selectvis(spwid=[-1]); ###selecting all data spectral windows
        im.clean(...);
        
        
        If the image and data selections differ, then averaging is done during
        the gridding and degridding process in the image deconvolution.
        
        
        im.defineimage(mode='channel', nchan=64, start=1, step=8);
        im.selectvis(nchan=512, start=1, step=1)
        im.clean()
        
        
        Note:  The channels numbers used in {tt defineimage}
        and {tt selectvis} refers to the same channel. So if a channel is not
        selected in {tt selectvis} but is selected in {tt defineimage}, then
        blank channels image are made. The example below will result in the
        having the first 6 (0-5) channels in the image to be blank.
        
        
        im.selectvis(nchan=50, start=6, step=1) #selected chan 6-55
        im.defineimage(mode='channel', nchan=50, start=0, step=1);
        
        # will try to image channel 1-50. But as previously only channel 6-55
        # was selected only channel 6-50 will have data; images of channels
        # 1-5 are blank
        im.clean(....)
        
        
        For multi-spectral window cube imaging the selection of the data can
        be done as follows
        
        
        im.selectvis(nchan=[50,60], start=[0,0], step=[1,1],
        spw=[0,1])
        im.defineimage(mode='channel', nchan=110, start=0, step=1, spw=[0,1]);
        
        
        
        The above means that you would make a data selection of 50 channels
        (starting from 0 steping 1) from the first spectral window and 60
        channels (starting from 1 steping 1). The defineimage defines the image
        to be a cube of 110 channels. The caveat is the step size in the
        frequency direction is the step size of the first spectral window. If
        the step size of channels of the two spectral windows are different
        then one is better off defining the image cube in velocities (e.g. as below).
        
        
        
        im.selectvis(nchan=[50,60], start=[0,0], step=[1,1],
        spw=[1,2])
        im.defineimage(mode='velocity', nchan=200, mstart='20km/s',
        mstep='-100m/s');
        
        """
        schema = {'vis': {'type': 'cStr'}, 'nchan': {'type': 'cIntVec', 'coerce': [_coerce.to_list,_coerce.to_intvec]}, 'start': {'type': 'cIntVec', 'coerce': [_coerce.to_list,_coerce.to_intvec]}, 'step': {'type': 'cIntVec', 'coerce': [_coerce.to_list,_coerce.to_intvec]}, 'spw': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'field': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'baseline': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'time': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'scan': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'intent': {'type': 'cStr'}, 'observation': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'uvrange': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'taql': {'type': 'cStr'}, 'usescratch': {'type': 'cBool'}, 'datainmemory': {'type': 'cBool'}, 'writeaccess': {'type': 'cBool'}}
        doc = {'vis': vis, 'nchan': nchan, 'start': start, 'step': step, 'spw': spw, 'field': field, 'baseline': baseline, 'time': time, 'scan': scan, 'intent': intent, 'observation': observation, 'uvrange': uvrange, 'taql': taql, 'usescratch': usescratch, 'datainmemory': datainmemory, 'writeaccess': writeaccess}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _selectvis_result = self._swigobj.selectvis(_str_ec(_pc.document['vis']), _pc.document['nchan'], _pc.document['start'], _pc.document['step'], _any_ec(_pc.document['spw']), _any_ec(_pc.document['field']), _any_ec(_pc.document['baseline']), _any_ec(_pc.document['time']), _any_ec(_pc.document['scan']), _str_ec(_pc.document['intent']), _any_ec(_pc.document['observation']), _any_ec(_pc.document['uvrange']), _str_ec(_pc.document['taql']), _pc.document['usescratch'], _pc.document['datainmemory'], _pc.document['writeaccess'])
        return _selectvis_result

    def setjy(self, field=[ ], spw=[ ], modimage='', fluxdensity=[ float(0.0),float(0.0),float(0.0),float(0.0) ], standard='SOURCE', scalebychan=False, spix=[ float(0.0) ], reffreq=[ ], polindex=[ float(0.0) ], polangle=[ float(0.0) ], rotmeas=float(0.0), time='', scan='', intent='', observation='', interpolation='nearest'):
        """Compute the model visibility for a specified source flux density, and
        insert into the MODEL_DATA column. The source flux density for
        a set of standard flux density reference sources may optionally
        be pre-computed, by setting the input flux density to -1 (the default).
        At present, these include 3C286, 3C48, 3C147, 3C138, and 1934-638.
        In this case, if the source is not in this set, an unpolarized
        flux density of 1 Jy will be assumed.  Users may also specify
        {tt standard='SOURCE'} to use the model(s) in the SOURCE_MODEL column of the
        SOURCE subtable.
        
        Users may also specify a model image that will be scaled to the
        specified total flux density (or that computed for reference sources).
        When a model image is specified, setjy will only permit processing
        one field, and will currently only process Stokes I.
        """
        schema = {'field': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'spw': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'modimage': {'type': 'cStr'}, 'fluxdensity': {'type': 'cFloatVec', 'coerce': [_coerce.to_list,_coerce.to_floatvec]}, 'standard': {'type': 'cStr'}, 'scalebychan': {'type': 'cBool'}, 'spix': {'type': 'cFloatVec', 'coerce': [_coerce.to_list,_coerce.to_floatvec]}, 'reffreq': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'polindex': {'type': 'cFloatVec', 'coerce': [_coerce.to_list,_coerce.to_floatvec]}, 'polangle': {'type': 'cFloatVec', 'coerce': [_coerce.to_list,_coerce.to_floatvec]}, 'rotmeas': {'type': 'cFloat', 'coerce': _coerce.to_float}, 'time': {'type': 'cStr'}, 'scan': {'type': 'cStr'}, 'intent': {'type': 'cStr'}, 'observation': {'type': 'cStr'}, 'interpolation': {'type': 'cStr'}}
        doc = {'field': field, 'spw': spw, 'modimage': modimage, 'fluxdensity': fluxdensity, 'standard': standard, 'scalebychan': scalebychan, 'spix': spix, 'reffreq': reffreq, 'polindex': polindex, 'polangle': polangle, 'rotmeas': rotmeas, 'time': time, 'scan': scan, 'intent': intent, 'observation': observation, 'interpolation': interpolation}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _setjy_result = _dict_dc(self._swigobj.setjy(_any_ec(_pc.document['field']), _any_ec(_pc.document['spw']), _str_ec(_pc.document['modimage']), _pc.document['fluxdensity'], _str_ec(_pc.document['standard']), _pc.document['scalebychan'], _pc.document['spix'], _any_ec(_pc.document['reffreq']), _pc.document['polindex'], _pc.document['polangle'], _pc.document['rotmeas'], _str_ec(_pc.document['time']), _str_ec(_pc.document['scan']), _str_ec(_pc.document['intent']), _str_ec(_pc.document['observation']), _str_ec(_pc.document['interpolation'])))
        return _setjy_result

    def ssoflux(self):
        """*This was an experimental clone of setjy while flux calibration with Solar
        System objects was being tested.  It has been merged back into setjy.*
        """
        _ssoflux_result = self._swigobj.ssoflux()
        return _ssoflux_result

    def setmfcontrol(self, cyclefactor=float(1.5), cyclespeedup=float(-1), cyclemaxpsffraction=float(0.8), stoplargenegatives=int(2), stoppointmode=int(-1), minpb=float(0.1), scaletype='NONE', constpb=float(0.4), fluxscale=[  ], flatnoise=True):
        """Control parameters for mosaicing or wide-field imaging which are not
        required in single field deconvolution are set here to streamline the
        user interface.  As multifield and widefield imaging is accomplished
        by deconvolution in cycles, many of these parameters control how the
        deconvolution cycles are ended.
        
        begin{description}
        item cyclefactor: this parameter helps in lowering or increasing the
        threshold at which the deconvolution cycle will stop  and degrid and
        subtract from the visibilities. For very bad PSFs you may want to
        reconcile with the visibilties often, thus a larger number is
        required here...(4 to 5). For very well behaved data you may want to
        deconvolve deep before reconciling: a lower number is used (1.5 to 2.0).
        item cyclespeedup: this is used if the PSF is not well behaved and
        you want clean to raise by 2 the threshold if it has not reached the
        threshold in this number of iteration
        item cyclemaxpsffraction: similar to cyclefactor, but this is an
        explicit fraction of the PSF peak. The final threshold is computed
        using  min( cyclemaxpsffraction, cyclefactor * maxPSFsidelobe).
        Valid values are between 0.0 and 1.0.
        item stoplargenegatives: This parameter is exclusively for when using
        multiscale clean. This is used to stop the component
        search when the largest scale has found this number of negative
        components. -1 here means that continue component search even if the
        largest component is negative.
        item stoppointmode: Again exclusively for when using multiscale
        clean. The clean will stop if the smallest scale receives this
        number of consecutive components.
        item minpb: This is to defined up to what level the voltage pattern
        is going to applied when  using
        setvp. The default is 0.1 of the
        primary beam or the voltage pattern defined for the antenna.
        item scaletype: This parameter cab be NONE or SAULT. If NONE the
        image is not scaled, if SAULT is used the image is weighted so that
        the noise is kept uniform across the image. The next two parameters
        defines how the SAULT weighting is limited. Obviously then the flux
        scale is not uniform across the image. To get the right flux
        multiply the image with the fluxscale image.
        item constpb: this parameter defines up to what amplitude of the
        Primary beam the noise floor is kept uniform, when using SAULT as scaletype.
        item fluxscale: use this to give a filename to store the factor image
        to apply to the image to get the fluxscale right.
        item flatnoise: (default true) Set to false if you want clean components for mosaic  to be searched in the residual image that is effectively multiplied by the $beam^2$. This means when the noise is determined after the antenna, searching in the optimum domain of $signal/(sigma^2)$. For meter wavelengths where noise is determined by the sky, it is no longer optimal.
        end{description}
        """
        schema = {'cyclefactor': {'type': 'cFloat', 'coerce': _coerce.to_float}, 'cyclespeedup': {'type': 'cFloat', 'coerce': _coerce.to_float}, 'cyclemaxpsffraction': {'type': 'cFloat', 'coerce': _coerce.to_float}, 'stoplargenegatives': {'type': 'cInt'}, 'stoppointmode': {'type': 'cInt'}, 'minpb': {'type': 'cFloat', 'coerce': _coerce.to_float}, 'scaletype': {'type': 'cStr'}, 'constpb': {'type': 'cFloat', 'coerce': _coerce.to_float}, 'fluxscale': {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}, 'flatnoise': {'type': 'cBool'}}
        doc = {'cyclefactor': cyclefactor, 'cyclespeedup': cyclespeedup, 'cyclemaxpsffraction': cyclemaxpsffraction, 'stoplargenegatives': stoplargenegatives, 'stoppointmode': stoppointmode, 'minpb': minpb, 'scaletype': scaletype, 'constpb': constpb, 'fluxscale': fluxscale, 'flatnoise': flatnoise}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _setmfcontrol_result = self._swigobj.setmfcontrol(_pc.document['cyclefactor'], _pc.document['cyclespeedup'], _pc.document['cyclemaxpsffraction'], _pc.document['stoplargenegatives'], _pc.document['stoppointmode'], _pc.document['minpb'], _str_ec(_pc.document['scaletype']), _pc.document['constpb'], [_str_ec(_x) for _x in _pc.document['fluxscale']], _pc.document['flatnoise'])
        return _setmfcontrol_result

    def setoptions(self, ftmachine='ft', cache=int(-1), tile=int(16), gridfunction='SF', location=[ ], padding=float(1.0), freqinterp='nearest', wprojplanes=int(-1), epjtablename='', applypointingoffsets=False, dopbgriddingcorrections=True, cfcachedirname='', rotpastep=float(5.0), pastep=float(360.0), pblimit=float(0.05), imagetilevol=int(0), singleprecisiononly=False, numthreads=int(-1), psterm=True, aterm=True, mterm=True, wbawp=False, conjbeams=True):
        """This function is for setting different gridding and memory options
        
        begin{description}
        item[ftmachine] The options for ftmachine are:
        begin{description}
        item[ft] Standard interferometric gridding
        item[sd] Standard single dish gridding
        item[both] ft and sd as appropriate.
        item[wproject] option for using the wproject algorithm for wide-field
        imaging; when this option is used the parameter {tt wprojplanes}
        define the number of convolution functions to be used
        item[mosaic] option to use the gridder that uses the primary beam as
        the convolution function in gridding
        
        end{description}
        item[cache] The size of the cache used (in complex pixels) during the
        gridding process. The default is to use half the physical memory of
        the machine as specified by the aipsrc variable system.resources.memory.
        item[tile] The side of the tile (in complex pixels) during the
        gridding process.
        item[gridfunction] The gridding function used. Currently only
        Box-car ('BOX') and Prolate Spheriodal Wave Function ('SF')
        are supported.  In the case of Single-Dish imaging the Primary Beam ('PB'),
        Gaussian ('GAUSS'), and Gaussian * Jinc ('GJINC') also can be used.
        item[location] For some unusual types of image, one needs to know the
        location to be used in calculating phase rotations. For example,
        one can specify images to be constructed in azel, in which
        case, an antenna position must be chosen. One can use functions of
        measures: either
        observatory to
        get the position of a named observatory ({em e.g.}
        me.observatory('ATCA')) or
        position to set
        the position ({em e.g.}me.position('wgs84','30deg','40deg','10m')).
        Although this information is available from the MeasurementSet, what
        location is ambiguous in some cases {em e.g.} VLBI.
        item[padding] When gridding and transforming, the array may be
        padded by this factor in the image plane. This reduces aliasing,
        especially in wide-field cleaning.
        item[usemodelcol] if this is false it tells imager to create and use the model
        visibility on the fly and in memory as far as possible...otherwise
        if it is True then imager will use the MODEL_DATA column to do this.
        item[wprojplanes] this parameter is is used only of {tt ftmachine}
        is set to {tt wproject}. This defines how many convolution functions
        is used in the Wprojection gridder (a -1 implies an automatic determination).
        end{description}
        """
        schema = {'ftmachine': {'type': 'cStr'}, 'cache': {'type': 'cInt'}, 'tile': {'type': 'cInt'}, 'gridfunction': {'type': 'cStr'}, 'location': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'padding': {'type': 'cFloat', 'coerce': _coerce.to_float}, 'freqinterp': {'type': 'cStr'}, 'wprojplanes': {'type': 'cInt'}, 'epjtablename': {'type': 'cStr'}, 'applypointingoffsets': {'type': 'cBool'}, 'dopbgriddingcorrections': {'type': 'cBool'}, 'cfcachedirname': {'type': 'cStr'}, 'rotpastep': {'type': 'cFloat', 'coerce': _coerce.to_float}, 'pastep': {'type': 'cFloat', 'coerce': _coerce.to_float}, 'pblimit': {'type': 'cFloat', 'coerce': _coerce.to_float}, 'imagetilevol': {'type': 'cInt'}, 'singleprecisiononly': {'type': 'cBool'}, 'numthreads': {'type': 'cInt'}, 'psterm': {'type': 'cBool'}, 'aterm': {'type': 'cBool'}, 'mterm': {'type': 'cBool'}, 'wbawp': {'type': 'cBool'}, 'conjbeams': {'type': 'cBool'}}
        doc = {'ftmachine': ftmachine, 'cache': cache, 'tile': tile, 'gridfunction': gridfunction, 'location': location, 'padding': padding, 'freqinterp': freqinterp, 'wprojplanes': wprojplanes, 'epjtablename': epjtablename, 'applypointingoffsets': applypointingoffsets, 'dopbgriddingcorrections': dopbgriddingcorrections, 'cfcachedirname': cfcachedirname, 'rotpastep': rotpastep, 'pastep': pastep, 'pblimit': pblimit, 'imagetilevol': imagetilevol, 'singleprecisiononly': singleprecisiononly, 'numthreads': numthreads, 'psterm': psterm, 'aterm': aterm, 'mterm': mterm, 'wbawp': wbawp, 'conjbeams': conjbeams}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _setoptions_result = self._swigobj.setoptions(_str_ec(_pc.document['ftmachine']), _pc.document['cache'], _pc.document['tile'], _str_ec(_pc.document['gridfunction']), _any_ec(_pc.document['location']), _pc.document['padding'], _str_ec(_pc.document['freqinterp']), _pc.document['wprojplanes'], _str_ec(_pc.document['epjtablename']), _pc.document['applypointingoffsets'], _pc.document['dopbgriddingcorrections'], _str_ec(_pc.document['cfcachedirname']), _pc.document['rotpastep'], _pc.document['pastep'], _pc.document['pblimit'], _pc.document['imagetilevol'], _pc.document['singleprecisiononly'], _pc.document['numthreads'], _pc.document['psterm'], _pc.document['aterm'], _pc.document['mterm'], _pc.document['wbawp'], _pc.document['conjbeams'])
        return _setoptions_result

    def setscales(self, scalemethod='nscales', nscales=int(5), uservector=[ float(0.0),float(3.0),float(10.0) ]):
        """The multiscale clean algorithm cleans an image on a number of
        different scales, decomposing the image into Gaussians of these scale sizes.
        This function allows the user to set the number
        of scales used (using the nscales method), or to directly control the
        sizes of the scales in pixels (using the uservector method).  When using the
        nscales method, the scales are calculated using the following formula:
        begin{equation}
        theta_{minor}  10.0 ^{(i- N_{scales}/2)/2.0}
        end{equation}
        where $theta_{min}$ is the fitted minor axis of the clean beam. The
        first value is zero.
        """
        schema = {'scalemethod': {'type': 'cStr'}, 'nscales': {'type': 'cInt'}, 'uservector': {'type': 'cFloatVec', 'coerce': [_coerce.to_list,_coerce.to_floatvec]}}
        doc = {'scalemethod': scalemethod, 'nscales': nscales, 'uservector': uservector}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _setscales_result = self._swigobj.setscales(_str_ec(_pc.document['scalemethod']), _pc.document['nscales'], _pc.document['uservector'])
        return _setscales_result

    def setsmallscalebias(self, inbias=float(0.6)):
        """
        """
        schema = {'inbias': {'type': 'cFloat', 'coerce': _coerce.to_float}}
        doc = {'inbias': inbias}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _setsmallscalebias_result = self._swigobj.setsmallscalebias(_pc.document['inbias'])
        return _setsmallscalebias_result

    def settaylorterms(self, ntaylorterms=int(2), reffreq=float(0.0)):
        """The multi-frequency clean algorithm cleans an image by approximating its spectra
        by a Taylor series expansion. This function allows the user to set the number of
        Taylor terms to be used. Options are 1,2,3.
        """
        schema = {'ntaylorterms': {'type': 'cInt'}, 'reffreq': {'type': 'cFloat', 'coerce': _coerce.to_float}}
        doc = {'ntaylorterms': ntaylorterms, 'reffreq': reffreq}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _settaylorterms_result = self._swigobj.settaylorterms(_pc.document['ntaylorterms'], _pc.document['reffreq'])
        return _settaylorterms_result

    def setsdoptions(self, scale=float(1.0), weight=float(1.0), convsupport=int(-1), pointingcolumntouse='DIRECTION', truncate=[ ], gwidth=[ ], jwidth=[ ], minweight=float(0.), clipminmax=False):
        """Various less-often-used options for single dish processing can be set.
        
        begin{description}
        item[scale] The overall scale of the single dish data is multiplied by this
        factor.
        item[weight] The weight given to the single dish data in the imaging
        is multiplied by this factor.
        item[convsupport] This parameter can be used to change the support used in gridding single dish data in imaging. If 'PB' or 'pb' is used as the 'convtype' in
        setoptions this parameter is ignored as the support is defined by the primary beam. The deafult of -1 mans 1 as convsupport is used for 'box' convolution function and 3 is used for 'SF' convolution function.
        item[pointingcolumntouse] This parameter is NOT to be changed under normal circumstances. This is to be used by those who know what they are doing and want to try to use different columns in the POINTING table especially if they believe their dish direction is wrong. And if any of the {tt _OFFSET} columns is used do not expect to be able to use a different frame in the image setup in defineimage. Possible values are {tt DIRECTION, TARGET, ENCODER, POINTING_OFFSET, SOURCE_OFFSET}
        item[truncate] The truncation radius as a quantity or a float value. This parameter is effective only when 'GAUSS' or 'GJINC' is used as the 'convtype' in setoptions. You can use an unit 'pixel' to specify truncation radius as pixel value. If float value is set, or quantity without unit is set, its unit will be 'pixel'.
        item[gwidth] The width of the gaussian beam as a radius of half maximum. This parameter is effective only when 'GAUSS' or 'GJINC' is used as the 'convtype' in setoptions. You can use an unit 'pixel' to specify truncation radius as pixel value. If float value is set, or quantity without unit is set, its unit will be 'pixel'. Note that, when 'GJINC' is used as the 'convtype', gwidth doesn't directry specify width of the convolution function.
        item[jwidth] The witdh of the jinc beam as a parameter c, where jinc = J_1(pi*x/c)/(pi*x/c). This parameter is effective only when 'GJINC' is used as the 'convtype' in setoptions. You can use an unit 'pixel' to specify truncation radius as pixel value. If float value is set, or quantity without unit is set, its unit will be 'pixel'. Note that jwidth doesn't directly specify width of the convolution function.
        end{description}
        """
        schema = {'scale': {'type': 'cFloat', 'coerce': _coerce.to_float}, 'weight': {'type': 'cFloat', 'coerce': _coerce.to_float}, 'convsupport': {'type': 'cInt'}, 'pointingcolumntouse': {'type': 'cStr'}, 'truncate': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'gwidth': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'jwidth': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'minweight': {'type': 'cFloat', 'coerce': _coerce.to_float}, 'clipminmax': {'type': 'cBool'}}
        doc = {'scale': scale, 'weight': weight, 'convsupport': convsupport, 'pointingcolumntouse': pointingcolumntouse, 'truncate': truncate, 'gwidth': gwidth, 'jwidth': jwidth, 'minweight': minweight, 'clipminmax': clipminmax}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _setsdoptions_result = self._swigobj.setsdoptions(_pc.document['scale'], _pc.document['weight'], _pc.document['convsupport'], _str_ec(_pc.document['pointingcolumntouse']), _any_ec(_pc.document['truncate']), _any_ec(_pc.document['gwidth']), _any_ec(_pc.document['jwidth']), _pc.document['minweight'], _pc.document['clipminmax'])
        return _setsdoptions_result

    def setvp(self, dovp=False, usedefaultvp=True, vptable='', dosquint=False, parangleinc=[ ], skyposthreshold=[ ], telescope='', verbose=True):
        """Set the voltage pattern model (and hence, the primary beam) used for a
        telescope.  There are currently two ways to set the voltage pattern: by using
        the extensive list of defaults which the system knows about, or by creating a
        voltage pattern description with the vpmanager.  The default voltage patterns
        include both a high and a low frequency VP for the WSRT, a VP for each
        observing band at the AT, several VP's for the VLA, including the appropriate
        beam squint for each observing band, and Gaussian for the BIMA dishes.  Due to
        temporary limitations in the internal structure of the visibility buffer, only
        one telescope's voltage pattern can be applied to a particular MeasurementSet.
        This will be corrected shortly.
        """
        schema = {'dovp': {'type': 'cBool'}, 'usedefaultvp': {'type': 'cBool'}, 'vptable': {'type': 'cStr'}, 'dosquint': {'type': 'cBool'}, 'parangleinc': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'skyposthreshold': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'telescope': {'type': 'cStr'}, 'verbose': {'type': 'cBool'}}
        doc = {'dovp': dovp, 'usedefaultvp': usedefaultvp, 'vptable': vptable, 'dosquint': dosquint, 'parangleinc': parangleinc, 'skyposthreshold': skyposthreshold, 'telescope': telescope, 'verbose': verbose}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _setvp_result = self._swigobj.setvp(_pc.document['dovp'], _pc.document['usedefaultvp'], _str_ec(_pc.document['vptable']), _pc.document['dosquint'], _any_ec(_pc.document['parangleinc']), _any_ec(_pc.document['skyposthreshold']), _str_ec(_pc.document['telescope']), _pc.document['verbose'])
        return _setvp_result

    def setweightgrid(self, weight=[ ], type='imaging'):
        """This is a utility function when running multi imager processes in parallel on subsection of an ms/data independently
        One would wish to weight the dirty image before averaging or set the imaging weight density (when using unform or
        Brigg's style weighting) to account for all the data being used. This is {bf NOT} for the general user but for people who
        are parallelizing at the scripting level.
        """
        schema = {'weight': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'type': {'type': 'cStr'}}
        doc = {'weight': weight, 'type': type}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _setweightgrid_result = self._swigobj.setweightgrid(_any_ec(_pc.document['weight']), _str_ec(_pc.document['type']))
        return _setweightgrid_result

    def smooth(self, model=[  ], image=[  ], usefit=True, bmaj=[ ], bmin=[ ], bpa=[ ], normalize=True, async=False):
        """The model images are convolved with the specified Gaussian beam.  By
        default (normalize=T), the beam volume is normalized to unity so that
        the smoothing is flux preserving. The smoothing used in restoration is
        not normalized.
        """
        schema = {'model': {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}, 'image': {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}, 'usefit': {'type': 'cBool'}, 'bmaj': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'bmin': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'bpa': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'normalize': {'type': 'cBool'}, 'async': {'type': 'cBool'}}
        doc = {'model': model, 'image': image, 'usefit': usefit, 'bmaj': bmaj, 'bmin': bmin, 'bpa': bpa, 'normalize': normalize, 'async': async}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _smooth_result = self._swigobj.smooth([_str_ec(_x) for _x in _pc.document['model']], [_str_ec(_x) for _x in _pc.document['image']], _pc.document['usefit'], _any_ec(_pc.document['bmaj']), _any_ec(_pc.document['bmin']), _any_ec(_pc.document['bpa']), _pc.document['normalize'], _pc.document['async'])
        return _smooth_result

    def stop(self):
        """Stop the currently executing function as soon as possible. Note that
        it is not always possible to stop a function.
        """
        _stop_result = self._swigobj.stop()
        return _stop_result

    def summary(self):
        """Writes a summary of the properties of the imager to the
        default logger. This includes:
        begin{itemize}
        item The name of the MeasurementSet (set in construction or via the
        open function.
        item The parameters of the image (set via defineimage)
        item The current beam (set by fitpsf
        or setbeam.
        item The selection of an ms (set via selectvis)
        item The general processing options (set via setoptions)
        end{itemize}
        """
        _summary_result = self._swigobj.summary()
        return _summary_result

    def uvrange(self, uvmin=float(0.0), uvmax=float(0.0)):
        """Apply a uvrange so that only points within a given uvrange are selected for further usage.  To be noted selectvis if used after uvrange will reset the selected range. So selectvis should be used prior to uvrange or can be used
        
        to reset it if one changes one's mind. The points are not flagged! Further point to be noted for spectral line data the uv distance is calculated using the mean of the wavelengths of the different spectral channels selected.
        """
        schema = {'uvmin': {'type': 'cFloat', 'coerce': _coerce.to_float}, 'uvmax': {'type': 'cFloat', 'coerce': _coerce.to_float}}
        doc = {'uvmin': uvmin, 'uvmax': uvmax}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _uvrange_result = self._swigobj.uvrange(_pc.document['uvmin'], _pc.document['uvmax'])
        return _uvrange_result

    def weight(self, type='natural', rmode='none', noise=[ ], robust=float(0.0), fieldofview=[ ], npixels=int(0), mosaic=False, async=False):
        """Apply visibility weighting to correct for the local density of
        sampling in the uv plane. The imaging weights are calculated on the fly
        when processing the data and can be viewed by
        plotweights.
        
        To correct for visibility sampling effects, natural, uniform, radial, and Briggs weighting are supported.  These work as
        follows. Then:
        begin{description}
        item[natural]: minimizes the noise in the dirty image. The weight of
        the $i$-th sample is set to the inverse variance:
        begin{equation}
        w_i={1over{sigma_i^2}}
        end{equation}
        where $sigma_i$ is the noise of the $i$'th sample.
        item[radial]: approximately minimizes rms sidelobes for an east-west synthesis
        array. The weight of the $i$-th sample is multiplied
        by the radial distance from the center of the $u,v$ plane:
        begin{equation}
        w_i=w_i sqrt{u_i^2+v_i^2}
        end{equation}
        item[uniform]: For Briggs and uniform weighting, we first grid the inverse
        variance $w_i$ for all selected data onto a grid of size given by the
        argument npixels (default to nx) and u,v cell-size given by
        $2/$fieldofview where fieldofview is the specified field of view
        (defaults to the image field of view).  This forms the gridded weights
        $W_k$. The weight of the $i$-th sample is then changed:
        begin{equation}
        w_i={w_iover{W_k}}
        end{equation}
        where $W_k$ is the gridded weight of the relevant cell.
        It may be shown that this minimizes rms sidelobes over
        the field of view. By changing the field of view, one may suppress
        the sidelobes over a region different (usually smaller) than the
        image size.
        item[briggs: rmode='norm']: The weights are changed:
        begin{equation}
        w_i={w_iover{1 + W_k f^2}}
        end{equation}
        where:
        begin{equation}
        f^2={{(5*10^{-R})^2}over{{sum_k W_k^2}over{sum_i w_i}}}
        end{equation}
        and $R$ is the robust parameter. The scaling of $R$ is such that
        $R=0$ gives a good tradeoff between resolution and sensitivity.
        $R$ takes value between -2.0 (close to uniform weighting) to 2.0
        (close to natural).
        item[briggs: rmode='abs']: The weights are changed:
        begin{equation}
        w_i={w_iover{W_k*R^2+2*sigma_R^2}}
        end{equation}
        where $R$ is the robust parameter and $sigma_R$ is the noise
        parameter.
        end{description}
        For more details about Briggs (aka robust) weighting, see the htmladdnormallink{Briggs thesis}
        {briggsURL}.
        
        Note that this weighting is {em not} cumulative since the imaging weights are
        calculated from the specified weight (function of noise; usually $1/sigma^2$) per visibility
        (actually stored in the  WEIGHT column).
        """
        schema = {'type': {'type': 'cStr'}, 'rmode': {'type': 'cStr'}, 'noise': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'robust': {'type': 'cFloat', 'coerce': _coerce.to_float}, 'fieldofview': {'type': 'cVariant', 'coerce': [_coerce.to_variant]}, 'npixels': {'type': 'cInt'}, 'mosaic': {'type': 'cBool'}, 'async': {'type': 'cBool'}}
        doc = {'type': type, 'rmode': rmode, 'noise': noise, 'robust': robust, 'fieldofview': fieldofview, 'npixels': npixels, 'mosaic': mosaic, 'async': async}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _weight_result = self._swigobj.weight(_str_ec(_pc.document['type']), _str_ec(_pc.document['rmode']), _any_ec(_pc.document['noise']), _pc.document['robust'], _any_ec(_pc.document['fieldofview']), _pc.document['npixels'], _pc.document['mosaic'], _pc.document['async'])
        return _weight_result

    def mapextent(self, ref='J2000', movingsource='', pointingcolumntouse='DIRECTION'):
        """TODO: description must be filled
        """
        schema = {'ref': {'type': 'cStr'}, 'movingsource': {'type': 'cStr'}, 'pointingcolumntouse': {'type': 'cStr'}}
        doc = {'ref': ref, 'movingsource': movingsource, 'pointingcolumntouse': pointingcolumntouse}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _mapextent_result = _dict_dc(self._swigobj.mapextent(_str_ec(_pc.document['ref']), _str_ec(_pc.document['movingsource']), _str_ec(_pc.document['pointingcolumntouse'])))
        return _mapextent_result

    def pointingsampling(self, pattern='raster', ref='J2000', movingsource='', pointingcolumntouse='DIRECTION', antenna=''):
        """Calculate sampling interval of an MS.
        """
        schema = {'pattern': {'type': 'cStr'}, 'ref': {'type': 'cStr'}, 'movingsource': {'type': 'cStr'}, 'pointingcolumntouse': {'type': 'cStr'}, 'antenna': {'type': 'cStr'}}
        doc = {'pattern': pattern, 'ref': ref, 'movingsource': movingsource, 'pointingcolumntouse': pointingcolumntouse, 'antenna': antenna}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _pointingsampling_result = _dict_dc(self._swigobj.pointingsampling(_str_ec(_pc.document['pattern']), _str_ec(_pc.document['ref']), _str_ec(_pc.document['movingsource']), _str_ec(_pc.document['pointingcolumntouse']), _str_ec(_pc.document['antenna'])))
        return _pointingsampling_result

