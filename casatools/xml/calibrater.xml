<casaxml xsi:schemaLocation="http://casa.nrao.edu/schema/casa.xsd file:///opt/casa/code/tools/xml/casa.xsd" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://casa.nrao.edu/schema/psetTypes.html">


 
	<tool module="calibrater" name="calibrater">
        <shortdescription>Synthesis calibration (self- and cross-)</shortdescription>
       
<description>
The {\tt calibrater} tool (cb) provides for synthesis calibration 
operations within CASA.  
</description>
<code>
	<include>calibrater_forward.h</include>
<private>
	<include>calibrater_private.h</include>
</private>
</code>


<method name="calibrater" type="constructor">
<shortdescription>Construct a calibrater tool</shortdescription>

<returns type="calibrater"/>

<description>

Create a {\tt calibrater} tool.  The casapy environment provides
a standard calibrater tool for general use (cb), but additional calibrater
tools may be created if needed.  Calibrater tools created in this way
are independent of the standard calibrater tool.

</description>

<example>

cb2=calibrater.create()

</example>
</method>


<method name="open" type="function">
<shortdescription>Attach MeasurementSet to the calibrater tool</shortdescription>

<input>
     <param name="filename" direction="in" type="string">
     <description>MeasurementSet file name.  No default</description>
     </param>
     <param name="compress" direction="in" type="bool">
     <description>Compress calibration columns?</description>
     <value>false</value>
     </param>
     <param name="addcorr" direction="in" type="bool">
     <description>Add scratch columns?</description>
     <value>true</value>
     </param>
     <param name="addmodel" direction="in" type="bool">
     <description>Add MODEL\_DATA column along with CORRECTED\_DATA ?</description>
     <value>true</value>
     </param>
</input>
<returns type="bool"/>

<description>
Attaches a MeasurementSet to the {\tt calibrater} tool for further processing with
other methods.

</description>

<example>

cb.open('ngc5921.ms');

</example>
</method>



<method name="selectvis" type="function">
<shortdescription>Set the data selection for subsequent processing</shortdescription>

<input>

     <param name="time" direction="in" type="any">
     <description>Select on time</description>
     <any type="variant"/>
     <value/>
     </param>

     <param name="spw" direction="in" type="any">
     <description>Select on spectral window</description>
     <any type="variant"/>
     <value/>
     </param>

     <param name="scan" direction="in" type="any">
     <description>Select on scan</description>
     <any type="variant"/>
     <value/>
     </param>

     <param name="field" direction="in" type="any">
     <description>Select on field</description>
     <any type="variant"/>
     <value/>
     </param>

     <param name="intent" direction="in" type="any">
     <description>Select on intent or state</description>
     <any type="variant"/>
     <value/>
     </param>

     <param name="observation" direction="in" type="any">
     <description>Select by observation ID(s)</description>
     <any type="variant"/>
     <value/>
     </param>

     <param name="baseline" direction="in" type="any">
     <description>Select on antennas/baselines</description>
     <any type="variant"/>
     <value/>
     </param>

     <param name="uvrange" direction="in" type="any">
     <description>Select by uvrange </description>
     <any type="variant"/>
     <value/>
     </param>

     <param name="chanmode" direction="in" type="string">
     <description>Type of data selection: channel or velocity</description>
     <value>channel</value>
     <value>velocity</value>
     <value>none</value>
     </param>

     <param name="nchan" direction="in" type="int">
     <description>Number of channels to select (mode='channel')</description>
     <value>1</value>
     </param>

     <param name="start" direction="in" type="int">
     <description>Start channel (0-relative) (mode='channel')</description>
     <value>0</value>
     </param>

     <param name="step" direction="in" type="int">
     <description>Step in channel number (mode='channel')</description>
     <value>1</value>
     </param>

     <param units="km/s" name="mstart" direction="in" type="double">
     <description>Start velocity (e.g. '20Km/s')</description>
     <value>0.0</value>
     </param>

     <param units="km/s" name="mstep" direction="in" type="double">
     <description>Step in velocity (e.g. '100m/s')</description>
     <value>0.0</value>
     </param>

     <param name="msselect" direction="in" type="string">
     <description>TAQL selection string.  Default (empty) is no specific selection.</description>
     <value/>
     </param>
</input>
<returns type="bool"/>

<description>

This function provids for selection of the visibility data from the MS 
which will be treated by subsequent execution of the {\stfaf solve} and 
{\stfaf correct} functions.  Note that data selection is not cumulative, i.e., 
any selection made in a previous call to {\stfaf selectvis} will be overridden
by the the current call.

Most of the {\stfaf selectvis} parameters use the standardized MS Selection
syntax.

The parameters are described below.  The selected data will satisfy the
logical AND of all non-trivially specified parameters.  Note that the
old-fashioned strided channel selection parameters are deprecated (and
will soon be removed); use spw instead.  Running {\stfaf selectvis} with
no specified parameters restores selection of the entire MS.


\begin{description}
\item[time] is used to specify time ranges in a stardard format

\item[spw] is used to specify spectral window and channel selection.  Currently,
only a single channel range can be specified per spw.

\item[scan] is used to specify scan numbers and ranges

\item[observation] is used to specify observation ID(s).

\item[field] is used to specify field names or indices

\item[baseline] is used to specify antenna and baseline combinations

\item[uvrange] is used to specify baseline length ranges

\item[chanmode] is deprecated (use spw)
\item[nchan] is deprecated (use spw)
\item[start] is deprecated (use spw)
\item[step] is deprecated (use spw)
\item[mstart] is deprecated (use spw)
\item[mstep] is deprecated (use spw)

\item[msselect] is used to specify a subselection of data according to
Measurement Set columns in conditional combinations not possible
with the standard parameters above.  This parameter should be specified
as a valid \htmladdnormallink{TaQL}{../../notes/199/199.html} expression.
If both msselect and the standard selection parameter are used together,
they are combined with a logical AND, i.e., the data must jointly satisfy
all {\stfaf selectvis} parameters.

\end{description}

</description>

<example>

Open and select a field:


cb.open('ngc5921.ms');
cb.selectvis(field='N5921_2');  # by complete name
cb.selectvis(field='N5921*');   # with wildcard
cb.selectvis(field='2');        # by index


Select a field and a channel range:


cb.selectvis(spw='0:10~40',field='N5921*');


Select using all MS Selection parameters (these parameters are
over-specified somewhat, i.e., scan 6 contains only field N5921_2,
etc.):


cb.selectvis(time='&gt;1995/04/13/10:40:00',   # times greater than this
             spw='0:20~40',                 # channels 20-40 in spw 0
             scan='6',                      # scan 6 only
             field='N59*',                  # fields matching N59*
             baseline='1 \&amp; *',              # baselines to antenna 1
             uvrange='&gt;0.0klambda')         # baselines greater than zero length



Reset selection to the entire dataset


cb.selectvis()


</example>

</method>


 
<method name="setmodel" type="function">
   <shortdescription>Set the sky model used to compute the model visibilities</shortdescription>

<input>
   <param name="modelimage" direction="in" type="string">
   <description>Name of the model image.</description>
   </param>
</input>
<returns type="bool"/>

<description>
Name of the model image to be used as a sky model for model visibility
computations.  For now, this is used only by EP-Jones solver.
</description>

<example>
cb.setmodel(&quot;mymodel&quot;);
</example>

</method>

<method name="setptmodel" type="function">
   <shortdescription>Set the point source model Stokes parameters to be used to compute the model visibilities</shortdescription>

<input>
   <param name="stokes" direction="in" type="doubleVec">
   <description>Vector of Stokes parameters.</description>
   <value type="vector">
     <value>0.0</value>
     <value>0.0</value>
     <value>0.0</value>
     <value>0.0</value>
   </value>
   </param>
</input>
<returns type="bool"/>

<description>
Set a global point source model Stokes parameters to use in solving operations.
</description>

<example>
cb.setmodel([1,1,0,0]);
</example>

</method>


<method name="setapply" type="function">
   <shortdescription>Arrange to apply calibration</shortdescription>

<input>

     <param name="type" direction="in" type="string">
     <description>Component type</description>
     <value>B</value>
     <value>BPOLY</value>
     <value>G</value>
     <value>GSPLINE</value>
     <value>D</value>
     <value>P</value>
     <value>T</value>
     <value>TOPAC</value>
     <value>GAINCURVE</value>
     <value/>
     </param>

     <param name="t" direction="in" type="double">
     <description>Interpolation interval (seconds)</description>
     <value>0.0</value>
     </param>

     <param name="table" direction="in" type="string">
     <description>Calibration table name</description>
     <value/>
     </param>

     <param name="field" direction="in" type="any">
     <description>Select on field</description>
     <any type="variant"/>
     <value/>
     </param>

     <param name="interp" direction="in" type="string">
     <description>Interpolation type (in time)</description>
     <value>aipslin</value>
     <value>nearest</value>
     <value>linear</value>
     </param>

     <param name="select" direction="in" type="string">
     <description>TAQL selection string.  Default is no selection.</description>
     <value/>
     </param>

     <param name="calwt" direction="in" type="bool">
     <description>Calibrate weights?</description>
     <value>false</value>
     </param>

     <param name="spwmap" direction="in" type="intVec">
     <description>Spectral windows to apply</description>
     <value><value>-1</value></value>
     </param>

     <param name="opacity" direction="in" type="doubleVec">
     <description>Array-wide zenith opacity per antenna (for type='TOPAC')</description>
     <value><value>0.0</value></value>
     </param>

</input>
<returns type="bool"/>

<description>

This function is used to specify the calibration components which should be
applied during subsequent execution of the {\stfaf solve} and 
{\stfaf correct} functions.  This function should be executed as many
times as necessary to specify all desired calibration components.

Each calibration component represents a separate calibration matrix
correction included in the measurement equation. The different types
correspond to different instrumental and atmospheric effects.
Calibration components are available as calibration tables generated
by previous {\stfaf solve} executions (types 'B','BPOLY','G','GSPLINE',
'D','DF','T','M','MF','X'), or are calculated analytically on
the fly (types 'P', 'TOPAC', 'GAINCURVE').  Upon execution
of {\stfaf solve} or {\stfaf correct}, the group of specified 
calibration components will be applied in the order prescribed
by the Measurement Equation formalism.  

The parameters are as follows:

\begin{description}

\item[type] The calibration type being specified.  This is only required
for analytic types ('P','TOPAC','GAINCURVE').  When specifying an existing 
pre-solved calibration table, it is not necessary to explicitly specify the 
{\stfaf type}; this will be discerned from the table.  (Specifying the 
{\stfaf type} as well as the {\stfaf table} will force a check that the 
table contains solutions of the specified type.

For {\stfaf type='GAINCURVE'}, an elevation-dependent correction
will be applied using parameters read from the data repository.
Currently, this is only supported for the VLA.

\item[t] This parameter will be used in a future release to control
the range of applicability of the specified calibration.  Currently,
it is ignored.

\item[table] For pre-solved calibration, the file name of the table
to apply.

\item[field] The fields to select from the specified table, using
MS Selection syntax (as in selectvis).

\item[interp] The desired type of time-dependent interpolation.  Use 
{\stfaf interp='nearest'} to calibrate each datum with the calibration 
value nearest in time.  Use {\stfaf interp='linear'} to calibrate each 
datum with calibration phases and amplitudes linearly interpolated 
from neighboring (in time) values.  In the case of phase, this mode 
will assume that phase jumps greater than 180 degrees between neighboring 
points indicate a cycle slip, and the interpolated value will follow 
this change in cycle accordingly (i.e., the implied rate will always
be less than 180 degrees per sample).  Use {\stfaf interp='aipslin'} 
to emulate the basic interpolation mode used in classic AIPS, i.e., 
linearly interpolated amplitudes, with phases derived from linear 
interpolation of the complex calibration values.  While this method 
avoids having to track cycle slips (which is unstable for solutions 
with very low SNR), it will yield a phase interpolation which becomes 
increasingly non-linear as the spanned phase difference increases.  The 
non-linearity mimics the behavior of {\stfaf interp='nearest'} as 
the spanned phase difference approaches 180 degrees (the phase of the 
interpolated complex calibration value initially changes very slowly, 
then rapidly jumps to the second value at the midpoint of the interval). 
If the uncalibrated phase is changing this rapidly, a 'nearest' interpolation 
is not desirable.  Usually, {\stfaf interp='linear'} is the best choice.
The {\stfaf interp} parameter is applicable to any calibration type,
as long as there are sufficient solutions available to perform the
interpolation.  Note that calibration solutions which have been
determined for only one timestamp will default to 'nearest'.  More
interpolation options (e.g., 'cubic') will be added in the future.

\item[select] Used to specify general selection of a subset of 
calibration measurements from the table to be applied to the
visibility data.  Arbitrary cross-calibration is possible by combining
this function with the {\stfaf setdata} function.  The string
specified must be a valid \htmladdnormallink{TaQL}{../../notes/199/199.html} 
expression.

\item[spwmap] This parameter is used to indicate how solutions
derived from different spectral windows should be applied to other
spectral windows.  Nominally, data in each spectral window will be
corrected by solutions derived from the same spectral window.  This is
the default behavior of {\stfaf spwmap}, i.e., if {\stfaf spwmap} is
not specified, calibrater will insist that data be corrected by
solutions from the same spw.  Otherwise, {\stfaf spwmap} takes a
vector of integers indicating which spectral window {\em solutions} to
apply to which spectral window {\em data}, such that {\tt spwmap[j]=i}
causes solutions derived from the i-th spectral window to be used to
correct the j-th spectral window.  For example, if (say) bandpass
solutions are available for spws 0 \&amp; 2, and it is desired that these
be applied to spws 1 \&amp; 3 (as well as 0 \&amp; 2), respectively, use
{\stfaf spwmap=[0,0,2,2]}.  Even if some spws do not require an
explicit {\stfaf spwmap} setting, yet one or more does, it is safest
to specify it explicitly for all, e.g., {\stfaf spwmap=[0,1,3,3]}
indicates that spw 2 will be corrected with solutions from spw 3, and
the others will behave nominally.  Note that if no solutions exist 
for any of the spws specified in {\stfaf spwmap}, an error message
will result.

\item[calwt] If set True, the data weights will be calibrated
along with the data.  This is usually desirable.

\item[opacity] For {\stfaf type='TOPAC'}, an elevation-dependent 
opacity correction will be applied according to the zenith opacity value 
supplied in the {\stfaf opacity} parameter.  Currently, only one zenith 
opacity value can be supplied, and it is used for all antennas.

\end{description}

Use the {\stfaf state} function to review the list of calibration
components that have been set for application.  

Pending improvements:

\begin{itemize}
\item Enable variety of interpolation modes and timescales
\item Allow for antenna- and time-dependent opacities
\end{itemize}

</description>

<example>

cb.open('ngc5921.ms')
cb.selectvis(field='N5921*')            
cb.setapply (type='G', table='gcal', field='1445*') 
cb.setapply (type='P')     
cb.correct();
cb.close();


In this example, we apply parallactic angle corrections and a gain
calibration derived from a field whose name matches '1445*' in a caltable
called 'gcal' to data for a field matching 'N5921*'
</example>
</method>


<method name="setcallib" type="function">
   <shortdescription>Arrange to apply calibration via a Cal Library</shortdescription>

<input>

     <param name="callib" direction="in" type="record">
     <description>A calibration library record</description>
     <value type="record"/>
     </param>

</input>
<returns type="bool"/>

<description>

TBD

</description>

<example>

TBD

</example>
</method>

<method name="validatecallib" type="function">
   <shortdescription>Validate a Cal Library record</shortdescription>

<input>

     <param name="callib" direction="in" type="record">
     <description>A calibration library record</description>
     <value type="record"/>
     </param>

</input>
<returns type="bool"/>

<description>

TBD

</description>

<example>

TBD

</example>
</method>



<method name="setsolve" type="function">
   <shortdescription>Arrange to solve for calibration</shortdescription>
   

<input>

     <param name="type" direction="in" type="string">
     <description>Component type</description>
     <value>G</value>
     <value>T</value>
     <value>B</value>
     <value>D</value>
     <value>M</value>
     <value>MF</value>
     </param>

     <param name="t" direction="in" type="any">
     <description>Solution interval (units optional)</description>
     <any type="variant"/>
     <value/>
     </param>

     <param name="table" direction="in" type="string">
     <description>Output calibration table name</description>
     <value/>
     </param>

     <param name="append" direction="in" type="bool">
     <description>Append to existing table?</description>
     <value>false</value>
     </param>

     <param name="preavg" direction="in" type="double">
     <description>Pre-averaging interval (in sec)</description>
     <value>-1.0</value>
     </param>

     <param name="phaseonly" direction="in" type="bool">
     <description>Solve only for phase?</description>
     <value>false</value>
     </param>

     <param name="apmode" direction="in" type="string">
     <description>Solve for 'AP', 'A' (amp-only) or 'P' (phase-only)</description>
     <value>AP</value>
     </param>

     <param name="refant" direction="in" type="any">
     <description>Reference antenna.  Default is none.</description>
     <any type="variant"/>
     <value/>
     </param>

     <param name="refantmode" direction="in" type="string">
     <description>Reference antenna mode</description>
     <value>flex</value>
     <value>strict</value>
     <value>flex</value>
     </param>

     <param name="minblperant" direction="in" type="int">
     <description>Minimum number of baselines per ant for solving</description>
     <value>4</value>
     </param>

     <param name="solnorm" direction="in" type="bool">
     <description>Normalize solution after solve</description>
     <value>false</value>
     </param>

     <param name="normtype" direction="in" type="string">
     <description>Solution normalization type</description>
     <value>median</value>
     <value>mean</value>
     </param>

     <param name="minsnr" direction="in" type="float">
     <description>SNR threshold for accepting solutions</description>
     <value>0.0</value>
     </param>

     <param name="combine" direction="in" type="string">
     <description>Data axes on which to combine solving (scan, spw, and/or field)</description>
     <value/>
     </param>

     <param name="fillgaps" direction="in" type="int">
     <description/>
     <value>0</value>
     </param>

     <param name="cfcache" direction="in" type="string">
     <description>Name of the directory to be used for convolution
function disk cache.  This is used when type=EP.</description>
     <value/>
     </param>

     <param name="painc" direction="in" type="float">
     <description>Parallactic Angle increment used to trigger
computation of a new convolution function.  This is used when
type=EP.  Default value implies that only one convolution function
will be computed for the entire range of observation.</description>
     <value>360.0</value>
     </param>

     <param name="fitorder" direction="in" type="int">
     <description>Order of the polynomial fit, used when type='A'.</description>
     <value>0</value>
     </param>

     <param name="fraction" direction="in" type="float">
     <description>[SINGLE-DISH SPECIFIC] Edge detection parameter
for otfraster/otf calibration. This is a number of edge points
as a fraction of total number of points.</description>
     <value>0.1</value>
     </param>

     <param name="numedge" direction="in" type="int">
     <description>[SINGLE-DISH SPECIFIC] Edge detection parameter
for otfraster calibration. This is a number of edge points. The
value specified here comes before fraction. Note that edge points
will be detected from both side of each raster row so that number
of edge points is effectively twice of the specified value in each
raster row. Default (-1) is to use fraction.</description>
     <value>-1</value>
     </param>
     
     <param name="radius" direction="in" type="string">
     <description>[SINGLE-DISH SPECIFIC] Specifies radius of the 
central region of double circle gain calibration for fast scanning data.
The value must be either empty or quantum string (numeric value with unit).
Default (&quot;&quot;) is to use a radius of primary beam.</description>
     <value/>
     </param>
     
     <param name="smooth" direction="in" type="bool">
     <description>[SINGLE-DISH SPECIFIC] Whether or not applying 
smoothing during double circle gain calibration for fast scanning data.
Default is True. </description>
     <value>true</value>
     </param>

     <param name="zerorates" direction="in" type="bool">
     <description>[FRINGE-FIT SPECIFIC] Zero delay-rates in fringe fitting solution
     tables. </description>
     <value>false</value>
     </param>

     <param name="globalsolve" direction="in" type="bool">
     <description>[FRINGE-FIT SPECIFIC] Use global least-squares solver to improve fringe-fitting
     parameter estimates </description>
     <value>true</value>
     </param>


     <param name="niter" direction="in" type="int">
     <description>[FRINGE-FIT SPECIFIC] Maximum number of iterations for global least-squares
     solver</description>
     <value>100</value>
     </param>

     
     <param name="delaywindow" direction="in" type="doubleVec">
     <description>[FRINGE-FIT SPECIFIC] Constrain FFT delay search to a
     window; a two-element list, units of nanoseconds</description>
     <value/>
     </param>

     <param name="ratewindow" direction="in" type="doubleVec">
     <description>[FRINGE-FIT SPECIFIC] Constrain FFT rate search to a
     window; a two-element list, units of seconds per second</description>
     <value/>
     </param>

     <param name="paramactive" direction="in" type="boolVec">
       <description>An array of three booleans to control whether to
       sove for delay, fringe-rate and dispersive delay</description>
       <value/>
     </param>

     <param name="solmode" direction="in" type="string">
     <description>Solving mode: '', 'L1'; add 'R' for iterative outlier excision.</description>
     <value/>
     </param>

     <param name="rmsthresh" direction="in" type="doubleVec">
     <description>RMS threshold sequence.</description>
     <value/>
     </param>


     
</input>
<returns type="bool"/>

<description>
This function specifies the calibration component that will be solved for
by the {\stff solve} function.  Currently, only one type can 
be solved for at one time.

Each calibration component represents a separate calibration matrix
correction included in the measurement equation. The different types
correspond to different instrumental and atmospheric effects.
Currently, the solvable calibration components are types 'G','T','B', 'D'
and 'DF', which are antenna-based, and, 'M' and 'MF', which are
baseline-based.  Arrange to pre-apply any existing calibration components (of
types other than the solved-for one) using the {\stfaf setapply}
function.

The parameters are:

\begin{description}
\item[type] Specify the calibration type you want to solve for, from
'G','T','B','D','DF','M','MF'.

\item[t] Specify the solution interval.  This can be specified as an
integer (units of seconds assumed) or as a string containing a value
and units (e.g., '30s', '45min', '2h') or 'inf' (infinite) or 'int'
(per data integration).  A solution interval of 0 (with or without
units) is the same as 'int' (per integration), and negative solution
intervals are treated as 'inf' (infinite).

\item[table] Specify the output calibration table name in which to
store the calibration solve result.  Existing tables will be
deleted and replaced.

\item[append] Append the solutions to an existing table.  

\item[preavg] Specify the amount of pre-average (in time) within
the solution interval.  By default, data are averaged up to
the solution interval (or up to 5 minutes for 'D' solving).  

\item[phaseonly] This parameter is deprecated, use apmode.

\item[apmode] Control generation of amplitude-only ('a'), 
phase-only ('p'), or amplitude-and-phase ('ap', the default) solutions.

\item[refant] Specify an antenna (using data selection syntax)
for referencing the solutions. 

\item[solnorm] Normalize the solutions by their mean post-solve. For
'B', and 'MF', this is a complex normalization per solution spectrum.
For other types, this is a global (per-spw) normalization of the 
amplitudes only.

\item[minsnr] Specify the SNR below which solution are rejected.

\item[combine] Specify which data axes (spw, field, scan, or some
combination) on which the data should be combined to generate
a single solution.  E.g., combine='spw' will force combination
of many spws to form a single solution (per solution interval). 
Similarly, combine='scan' with a long solution interval 
will force the combination of scans to yield individual solutions
(per field and spw).  Ordinarily, solutions are always broken
at scans boundaries.  Separate multiple combine options with 
commas.

\item[fillgaps] For 'B' solutions, specify the largest solution
channel gap (which arise due to flagged data) that will be filled 
post-solve via interpolation.  Such solution gaps remain flagged
by default.

\end{description}

Pending improvements:

\begin{itemize}
\item{Change t to solint?}
\item{Permit flexible specification of preavg (as for t)}
\end{itemize}

</description>

<example>

cb.open('ngc5921.ms');
cb.setapply (type='P');
cb.setsolve (type='G',t='300s', refant=3, table='gcal');
cb.solve();
cb.close();


In this example, analytic (non-solvable) parallactic angle corrections
are pre-applied before G solutions are obtained on a timescale of 300 
seconds.  The resulting solutions are phase-referenced to antenna 3, 
and stored in a calibration table called 'gcal'.


cb.reset();
cb.setapply (type='P',t=5.0);
cb.setapply (type='G',table='gcal');
cb.setsolve (type='D',t=86400.0, preavg=60.0, refant=3, table='dcal');
cb.solve();
cb.close();


In this example, the solve/apply state of the calibrater tool is reset
and then the P and G corrections (from above) are applied before
solving for D solutions on a diurnal timescale.  Note that the data
will be averaged only to 60 seconds before the solution.  The resulting
D solutions are stored in a table called 'dcal'.

</example>
</method>


<method name="setsolvegainspline" type="function">
   <shortdescription>Specialization of setsolve for
cubic spline G (time-dependent gain) solving</shortdescription>
   

<input>

     <param name="table" direction="in" type="string">
     <description>Output calibration table name</description>
     <value/>
     </param>

     <param name="append" direction="in" type="bool">
     <description>Append to existing table?</description>
     <value>false</value>
     </param>

     <param name="mode" direction="in" type="string">
     <description>Phase or Amplitude mode?</description>
     <value>AMP</value>
     <value>PHASAMP</value>
     <value>PHAS</value>
     </param>

     <param name="splinetime" direction="in" type="double">
     <description>Spline timescale (sec)</description>
     <value>10800</value>
     </param>

     <param name="preavg" direction="in" type="double">
     <description>Pre-averaging interval (in sec)</description>
     <value>0.0</value>
     </param>

     <param name="npointaver" direction="in" type="int">
     <description/>
     <value>10</value>
     </param>

     <param name="phasewrap" direction="in" type="double">
     <description/>
     <value>250</value>
     </param>

     <param name="refant" direction="in" type="any">
     <description>Reference antenna.  Default is none.</description>
     <any type="variant"/>
     <value/>
     </param>

</input>
<returns type="bool"/>

<description>

This function is a specialization of the {\stfaf setsolve} method which
should be used when cubic spline G solutions are desired, e.g., when
SNR on calibrators is very low.  Currently, this solving mode treats
dual polarization data on a per-polarization basis.  The option to 
obtain a joint solution (a la 'T') will be provided in the future.

The visibility data are averaged in frequency (for multi-channel data)
prior to the solution.  

This method uses many of the basic parameters as the generic
{\stfaf setsolve}.  Parameters unique to the spline solver are:

\begin{description}

\item[mode] For phase solutions only, use {\stfaf mode='PHAS'}.  For
amplitude solutions only, use {\stfaf mode='AMP'}.  If both are
desired, use {\stfaf mode='PHASAMP'}, and both will be solved for
using the same spline timescale (this mode also assumes that all
calibrators have the correct relative flux densities).  If solving for
phase and amplitude separately (usually in this order), it is usually
desirable to apply the first one when solving for the second
one. Spline solution so obtained will be stored in separate
calibration tables.  In the near future, the {\stfaf mode} parameter
will be consolidated with the generic {\stfaf apmode} parameter.

\item[splinetime] The spline timescale (time between knots) is
specified here. The default is 10800 seconds (3 hours).  In future
this parameter will be consolidated with the generic {\stfaf t}
parameter.  The {\stfaf preavg} parameter should be set to a value at
least 4X shorter than the spline time (an error will occur if there is
insufficient sampling within the {\stfaf splinetime} timescale), and
consistent with the expected coherence.  Consistent with these constraints,
use the largest possible value for {\stfaf preavg} to optimize the SNR of 
the pre-solve phase-tracking algorithm.

\item[npointaver and phasewrap] These parameters tune the
phase-unwrapping algorithm when {\stfaf mode $=$ 'PHAS'}.  Cycle slips
are detected (and removed before the spline solve) when the median
phase a sequence of length {\stfaf npointaver} (in integrations)
differs by more than {\stfaf phasewrap} degrees from the previous
sequence.

\end{description}

Pending improvements:

\begin{itemize}
\item Consolidate more parameters with the generic {\stfaf setsolve}
\item Introduce the generic combine options
\item Improve phase-tracking algorithm
\end{itemize}

</description>

<example>

cb.open('ngc5921.ms')
cb.selectvis(field='1445*')
cb.setsolvegainspline (table='gcalph',mode='PHAS',splinetime=3600.0,preavg=60.0)cb.solve()

cb.setsolvegainspline (table='gcalamp',mode='AMP',splinetime=10800.0);
cb.solve();
cb.close();


In this example, a spline solution is first found for phase on a hourly timescale, then for amplitude on a three-hour timescale.
</example>
</method>

 
<method name="setsolvebandpoly" type="function">
   <shortdescription>Specialization of setsolve for
polynomial B (bandpass) solving</shortdescription>
   

<input>

     <param name="table" direction="in" type="string">
     <description>Output calibration table name</description>
     <value/>
     </param>

     <param name="append" direction="in" type="bool">
     <description>Append to existing table?</description>
     <value>false</value>
     </param>

     <param name="t" direction="in" type="any">
     <description>Solution interval (units optional)</description>
     <any type="variant"/>
     <value/>
     </param>

     <param name="combine" direction="in" type="string">
     <description>Data axes on which to combine solving (scan, spw, and/or field)</description>
     <value/>
     </param>

     <param name="degamp" direction="in" type="int">
     <description>Polynomial degree for amplitude solution</description>
     <value>3</value>
     </param>

     <param name="degphase" direction="in" type="int">
     <description>Polynomial degree for phase solution</description>
     <value>3</value>
     </param>

     <param name="visnorm" direction="in" type="bool">
     <description>Normalize data prior to solution</description>
     <value>false</value>
     </param>

     <param name="solnorm" direction="in" type="bool">
     <description>Normalize result?</description>
     <value>true</value>
     </param>

     <param name="maskcenter" direction="in" type="int">
     <description>Number of channels to avoid in center of each band</description>
     <value>0</value>
     </param>

     <param name="maskedge" direction="in" type="double">
     <description>Fraction of channels to avoid at each band edge (in \%)</description>
     <value>5.0</value>
     </param> 

     <param name="refant" direction="in" type="any">
     <description>Reference antenna</description>
     <any type="variant"/>
     <value/>
     </param>

</input>
<returns type="bool"/>

<description>

This function is a specialization of the {\stfaf setsolve} method
which should be used to arrange for bandpass solving when polynomial
solutions for B are desired, e.g., when per-channel SNR on calibrators
is too low to obtain a useful sampled bandpass. 

Prior to the solution, the visibility data are averaged in time, 
and the solution is performed for both phase and amplitude.

This method uses most of the same parameters as the generic 
{\stfaf setsolve}, with a few unique additions:

\begin{description}

\item[degamp and degphase] The parameters permit specification
of the polynomial order to use in amp and phase.  Specifying
0 (zero) yields constant solutions.

\item[visnorm] This parameter is used to normalize the assembled
spectral data, in a per baseline manner.  If set True, this will have
the effect of removing any non-frequency-dependent closure errors
(e.g., as caused by source structure, or introduced by the instrument)
from the data, and should be used with caution.  The resulting
solutions will be effectively normalized as well.  When {\stfaf
visnorm=F} is used, closure errors in the data (as supplied to the
solver) may be visible in the form of offsets between the data and
solutions.  For bandpass calibration, this is usually ok, as the {\em
shape} of the bandpass is the most important aspect of the solution.
In future this parameter will be generalized and made available
for other solve types. (NB: Use of {\stfaf solnorm=True} still
provides for post-solve normalization of the solutions.)

\item[maskcenter and maskedge] These parameters control how many
channels are ignored on-the-fly, at the center and edges of each input
spectral window, respectively.  To avoid edge channels, it is almost
always better to flag these channels directly, or select against them
in {\stfaf setdata}.  Aggressive use of maskedge (large values), will
yield polynomial solutions which will tend to diverge at the edges
(especially when the polynomial degree is also high), because maskedge
does not change the frequency domain of the solutions.  Such solutions
should be used with caution in subsequent operations.  (It is best to
avoid use of maskedge.)
\end{description}

The BPOLY solution is performed for both phase and amplitude, and the
result will be stored in the same table.  The frequency domain of the
solutions is limited to only the range of frequencies selected in
{\stfaf selectvis}.  When correcting data with these solutions (for
other solves or with {\stfaf correct}), only data within this domain
will be corrected.  Data outside (e.g., edge channels avoided in
{\stfaf setdata} for the solve), will not be corrected.  Therefore,
the same (or narrower) channel selection is recommended for all
operations using solutions produced by this function and {\stfaf
solve()}.

Note that the {\stfaf combine} parmaeter can be used meaningfully with
the BPOLY solver.  When combine='spw', the data from multiple spws
will be combined on a common frequency axis, and a single polynomial
will be determined spanning them all.  This is different than for
ordinary sampled 'B' solutions, for which combine='spw' causes the
bandpass to be combined on a common channel axis, effectively yielding
a mean bandpass for the set of spws.

</description>

<example>

cb.open('ngc5921.ms');
cb.selectvis(field='1331*')
cb.setsolvebandpoly(table='bpoly',degamp=5,degphase=7);
cb.solve();
cb.close();


In this example, amplitude (degree 5) and phase (degree 7) Chebychev
polynomial bandpasses are determined using the default parameters.
</example>
</method>


<method name="returndict" type="function">
   <shortdescription>Return a dictionary describing the current calibrater state</shortdescription>

<description>

Return a dictionary containing information about the current calibrater tool state.
This dictionary contains the following keys: 'antennas', 'apply tables', 'field', 'intents', 'observation', 'scan', 'solve table', 'spw'.

Each of these keys will show which values for each of these parameters are selected. By default all of the MS is selected when opened by the calibrater tool.

The values of each of these keys is an array of either strings or integers.
  
</description>

<input>
</input>

<returns type="record"/>

<example>

cb.open('gaincaltest2.ms')
cb.selectvis(field='1')
cb.returndict()

This would return a dictionary that looks like this:

{'antennas': array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]),
 'apply tables': array([], dtype='U16'),
'field': array([1]),
 'intents': array(['CALIBRATE_AMPLI#ON_SOURCE', 'CALIBRATE_DELAY#ON_SOURCE',
       'CALIBRATE_PHASE#ON_SOURCE', 'CALIBRATE_WVR#ON_SOURCE'],
      dtype='U26'),
 'observation': array([0]),
 'scan': array([ 3,  5,  8, 10, 12, 15, 17, 20, 22, 24]),
 'solve table': array([], dtype='U16'),
 'spw': array([0, 1, 2, 3])}

</example>
</method>



 
<method name="state" type="function">
   <shortdescription>Request the apply/solve state of the calibrater tool</shortdescription>
   
<returns type="bool"/>

<description>

Request the apply/solve state of the calibrater tool.  A listing of
all calibration components that have been set for application or
solving is written to the logger.

</description>

<example>

cb.open('ngc5921.ms');
cb.setapply ('P', 5.0);
cb.setsolve ('G', 300.0, F, 3, 'gcal_1', T);
cb.state();

</example>
</method>



 
<method name="reset" type="function">
   <shortdescription>Reset the selected apply and/or solve components</shortdescription>
   

<input>

     <param name="apply" direction="in" type="bool">
     <description>If true, unset all apply settings</description>
     <value>true</value>
     </param>

     <param name="solve" direction="in" type="bool">
     <description>If true, unset all solve settings</description>
     <value>true</value>
     </param>
</input>
<returns type="bool"/>

<description>

Resets the apply and/or solve components previously set by setapply and
setsolve.

</description>

<example>

cb.open('ngc5921.ms')
cb.setapply ('P', 5.0)
cb.setsolve ('G', 300.0, F, 3, 'gcal_1', T)
cb.state()
cb.reset(apply=T,solve=F);
cb.state()
cb.reset()


</example>
</method>


<method name="initcalset" type="function">
   <shortdescription>Re-initialize the calibration scratch columns.</shortdescription>
   
<input>

     <param name="calset" direction="in" type="int">
     <description>if it set to 1 the model saved in the header is removed</description>
     <value>0</value>
     </param>
</input>
<returns type="bool">true</returns>

<description>

This function re-initializes the calibration scratch columns:
MODEL\_DATA to unity (in total intensity, and unpolarized), and
CORRECTED\_DATA to (observed) DATA.  
Optionally if calset is set to 1 any model saved in the MS header to for calibration
purposes is deleted

</description>

<example>

cb.open('ngc5921.ms');
cb.initcalset();
cb.solve();



</example>
</method>

<method name="delmod" type="function">
   <shortdescription>Delete model data representations in the MS.</shortdescription>
   
<input>

     <param name="otf" direction="in" type="bool">
     <description>If T, delete the otf model data keywords</description>
     <value>false</value>
     </param>

     <param name="field" direction="in" type="any">
     <description>Select on field</description>
     <any type="variant"/>
     <value/>
     </param>

     <param name="spw" direction="in" type="any">
     <description>Select on spw only if field is defined</description>
     <any type="variant"/>
     <value/>
     </param>

     <param name="scr" direction="in" type="bool">
     <description>If T, delete the MODEL\_DATA column</description>
     <value>false</value>
     </param>
</input>
<returns type="bool">true</returns>

<description>

This method can be used to delete the model visibility
data representations in the MS.  The 'otf' representation is
the new (as of v3.4) 'scratch-less' model data, stored as
keywords in the MS header containing model data formation
instructions.  It is generated by the im tool (setjy, ft, and clean
methods; usescratch=F in im.open), and if present, overrides the
old-fashioned MODEL\_DATA column (if present).  If a user
wishes to use the MODEL\_DATA column \_after\_ having operated
with the 'otf' representation, this method can be used
to delete the 'otf' represenatation to make the MODEL\_DATA
column visible.  (Create the MODEL\_DATA column by using
usescratch=T in the im tool, or by running the cb.open
with addmodel=T.)

If otf=T, the user may selectively remove only a selection of fields model from the MS by specifying the field parameter. Similarly if the field parameter is specified, selected spws model for those fields may be deleted by specifying the spw. 


For convenience, this method also provides a means for
deleting the MODEL\_DATA column by setting scr=T.

</description>

<example>

cb.open('ngc5921.ms');
cb.delmod(otf=T,scr=F);   # delete only the otf model for all fields
cb.solve();

cb.open('n4826.ms')
cb.delmod(otf=T, field='1') 
#delete otf model of field 1 only, all other fields model are untouched
#if present
cb.open('n4826.ms')
cb.delmod(otf=T, field='1', spw='2') 
#delete otf model of field 1 and spectralwindow 2  only.

####NOTE doing:
cb.delmod(otf=T, field='', spw='2')

#will delete all otf models and spw will be ignored 

</example>
</method>



 
<method name="solve" type="function">
   <shortdescription>Solve for the selected calibration components</shortdescription>
   
<returns type="bool"/>

<description>
Execution of this function initiates a solve for the calibration component
specified in a previous {\stfaf setsolve} execution.  Existing calibration
components (as specified in one or more {\stfaf setapply} executions) will
be appropriately applied to the observed and model data according to their
position in the Measurement Equation, and their commutation properties.  

</description>

<example>

cb.open('ngc5921.ms');
cb.setapply ('P', t=10)
cb.setsolve ('G', 300.0, F, 3, 'gcal_1', T);
cb.solve();
cb.close();

</example>
</method>



<method name="correct" type="function">
<shortdescription>Apply calibration information</shortdescription>
   
<input>
     <param name="applymode" direction="in" type="string">
     <description>Correction cal/flag mode: ''='calflag','cal','flag','trial'</description>
     <value/>
     </param>
</input>

<returns type="bool"/>

<description> 

This function applies the calibration components specified via one or
more invocations of the {\stff setapply} function to the observed 
visibility data and writes the result to the CORRECTED\_DATA column 
of the Measurement Set.

</description>

<example>

cb.open('ngc5921.ms');
cb.selectvis(field='1445*')
cb.setapply ('G', 10.0, 'gcal_1')
cb.correct();
cb.close();

</example>
</method>


<method name="corrupt" type="function">
   <shortdescription>Corrupt model with calibration tables</shortdescription>
   
<returns type="bool"/>

<description> 

This function applies the calibration components specified via one or
more invocations of the {\stff setapply} function to the model
visibility data and (over-)writes the result to the MODEL\_DATA column of the
Measurement Set.

</description>

<example>

cb.open('ngc5921.ms')
cb.selectvis(field='1445*')
cb.setapply ('G', 10.0, 'gcal_1')
cb.corrupt()
cb.close()

</example>
</method>

<method name="initweights" type="function">
   <shortdescription>Initialize MS weight info in various ways.</shortdescription>

<input>
     <param name="wtmode" direction="in" type="string">
     <description>Initialization mode</description>
     <value>nyq</value>
     <allowed kind="enum">
          <value>nyq</value>
          <value>sigma</value>
          <value>weight</value>
          <value>ones</value>
          <value>delwtsp</value>
          <value>delsigsp</value>
     </allowed>
     </param>
     <param name="dowtsp" direction="in" type="bool">
     <description>Initialize WEIGHT_SPECTRUM column</description>
     <value>false</value>
     </param>
	<param name="tsystable" direction="in" type="string">
		<description>Tsys calibration table to apply on the fly</description>
		<value/>
	</param>

	<param name="gainfield" direction="in" type="string">
		<description>Select a subset of calibrators from Tsys caltable</description>
		<value/>
	</param>

	<param name="interp" direction="in" type="string">
		<description>Interp type in time[,freq]. default==linear,linear</description>
		<value/>
	</param>

	<param name="spwmap" direction="in" type="intVec">
		<description>Spectral windows combinations to form for gaintables(s)</description>
		<value/>
	</param>

</input>


<returns type="bool"/>

<description>

This function initializes the MS weight info in various ways.  

If wtmode='ones', SIGMA and WEIGHT will be initialized with 1.0,
globally.

If wtmode='nyq' (the default), SIGMA and WEIGHT will be initialized
according to bandwidth and integration time.  This is the
theoretically correct mode for raw normalized visibilities.

If wtmode='sigma', WEIGHT will be initialized according to the
existing SIGMA column.  

If mode='weight', WEIGHT_SPECTRUM will be initialized according to the
existing WEIGHT column; dowtspec=T must be specified in this case. 

For the above wtmodes, if dowtspec=T (or if the WEIGHT_SPECTRUM column
already exists), the WEIGHT_SPECTRUM column will be initialized
(uniformly in channel), in a manner consistent with the WEIGHT column.
If the WEIGHT_SPECTRUM column does not exist, dowtsp=T will force its
creation.

The follow modes should be used with extreme care: If
wtmode='delwtsp', the WEIGHT_SPECTRUM column will be deleted (if it
exists).  If wtmode='delsigsp', the SIGMA_SPECTRUM column will be
deleted (if it exists).  Note that creation of SIGMA_SPECTRUM is not 
supported via this method.

Note that this method does not support any prior selection.
Intialization of the weight information must currently be done
globally or not at all.  This is to maintain consistency.

</description>

<example>

cb.open('ngc5921.ms')
cb.initweights()
cb.close()

</example>
</method>



<method name="fluxscale" type="function">
   <shortdescription>Bootstrap the flux density scale from standard calibrators</shortdescription>
   

<input>
     <param name="tablein" direction="in" type="string">
     <description>Input calibration table name</description>
     </param>

     <param name="reference" direction="in" type="any">
     <description>Reference calibrator field names (comma-separated)</description>
     <any type="variant"/>
     <value/>
     </param>

     <param name="tableout" direction="in" type="string">
     <description>Output calibration table name.  Default is input calibration table name.</description>
     <value/>
     </param>

     <param name="transfer" direction="in" type="any">
     <description>Transfer source field names (comma-separated).  Default is all other fields.</description>
     <any type="variant"/>
     <value/>
     </param>

     <param name="listfile" direction="in" type="string">
     <description>Name of listfile that contains the fit information.  Default is '' (no file).</description>
     <value/>
     </param>

     <param name="append" direction="in" type="bool">
     <description>Append to existing table?</description>
     <value>false</value>
     </param>

     <param name="refspwmap" direction="in" type="intVec">
     <description>List of alternate spw for referencing</description>
     <value><value>-1</value></value>
     </param>

     <param name="gainthreshold" direction="in" type="float">
     <description>Threshold of gain amplitudes with respect to the median value to be used in 
     flux scale calculation. Default: -1.0 (no threshold) </description>
     <value>-1.0</value>
     </param>

     <param name="antenna" direction="in" type="string">
     <description>antenna selection/de-selection in
     flux scale calculation. Default: &quot;&quot;(include all antennas) </description>
     <value/>
     </param>

     <param name="timerange" direction="in" type="string">
     <description>timerage sub-selection with antenna selection in
     flux scale calculation. Default: &quot;&quot;(include all) </description>
     <value/>
     </param>

     <param name="scan" direction="in" type="string">
     <description>scan sub-selection with antenna selection in
     flux scale calculation. Default: &quot;&quot;(include all) </description>
     <value/>
     </param>

     <param name="incremental" direction="in" type="bool">
     <description>create a incremental caltable</description>
     <value>false</value>
     </param>

     <param name="fitorder" direction="in" type="int">
     <description>order for spectral fitting for multiple spws</description>
     <value>1</value>
     </param>
     
     <param name="display" direction="in" type="bool">
     <description>display statistics of the flux ratios</description>
     <value>false</value>
     </param>
</input>

<returns type="record">
   <description>
     The record keys are the field IDs.  Each field ID points to records whose
     keys are spectral window IDs.  Each of those keys points to a flux value.
   </description>
</returns>

<description>

This function is used to bootstrap the amplitude scale the
calibration solutions according to specified reference calibrator(s)
of known flux density.  This is necessary when the flux densities
of some of your calibrators were unknown (and thus were assumed
to be 1 Jy) during G solving.

The bootstrapping is achieved by comparing the median gain norm of the
calibration solutions derived for the calibrators specified in {\stfaf
reference} (one or more sources with known flux densities at the time
of G solving) with that of the calibrators specified in {\stfaf
transfer}, and enforcing the assumption that the antenna gains are
constant, on average.  The gain solutions for the transfer sources are
then re-scaled accordingly.   The {\stfaf reference} and {\stfaf transfer}
parameters may be specified using the general field selection syntax
(as in {\stfaf field} in {\stfaf selectvis}).

If no {\tt transfer} fields are specified, then the solutions for
all non-reference fields in {\tt tablein} will be re-scaled.  

If no {\tt tableout} is specified the input table will be overwritten
with the scaled solutions.  Note that the resulting table will only
contain solutions for those fields implicit in the {\tt reference} and
{\tt transfer} specifications.     Use {\tt append=T} to append the scaled
solutions to an existing table.  

Use the {\stfaf refspwmap} parameter to indicate how data for
different spectral windows should be matched in calculating the flux
density scale factor for {\stfaf transfer} fields. The default
behavior for {\tt refspwmap} is to insist on precisely matching
spectral windows for {\tt reference} and {\tt transfer} fields.  When
specified, the {\stfaf refspwmap} parameter takes a vector of integers
indicating which spectral window solutions to use as the reference for
others, such that {\tt refspwmap[j]=i} causes solutions (from reference
fields) observed in the i-th spectral window to be used to reference
solutions (from transfer fields) observed in the j-th spectral window.
For example, for the case of a total of 4 spectral windows: if the
{\tt reference} fields were observed only in spw=2 \&amp; 4, and the {\tt
transfer} fields were observed variously in all 4 spws, specify {\tt
refspwmap=[2,2,4,4]}.  This will ensure that {\tt transfer} fields
observed in spws 1,2,3,4 will be referenced to {\tt reference} field
data from spws 2,2,4,4, respectively.  Note that if the {\tt transfer}
fields were observed only in spws 1 \&amp; 3, the same specification would
work, but {\tt refspwmap=[2,2,4]} would suffice.  In this case,
nothing need be specified for the 4th spw (there are no transfer
fields there), and specifying 2 for the 2nd spw is actually
inconsequential (though required so that the specification of 4 for spw 3
is properly interpretted).

The  gain values used in the flux scaling determination skewed by 
outliers. The parameters, {\tt gainthreshold} and {\tt antenna} can be used
to limit the input gain solutions to be included in the flux scale determination.
Use the {\tt gainthreshold} is a threshold in \% from the median values of the 
gain solutions to be used. Use the {\tt antenna} to select or de-selesect (using the
MSSelection syntax) antenna(s). Futher refinements on the selection based on 
timerange and scan are possible.
 
The derived flux densities for the transfer fields will be reported in
the logger, and returned to the Python dictionary specified in {\tt
fluxd}.  This will be an 2D array of shape [number-of-spectral-windows
X number-of-fields]. When mulitple spectral windows are involved the spectral
index will also be reported by fitting the determined flux densities across
the freuquencies. The order of a polynomcial to be fitted can be specified with 
{\tt fitorder}.

Note that elevation-dependent gain effects may render the basic
assumption used here invalid, and so should be corrected for prior to
solving for G, using types 'TOPAC' or 'GAINCURVE' in {\tt setapply}.

Note that the visibility data itself is not used directly by this
function.

Pending improvements:

\begin{itemize}
\item Allow antenna and uv-distance selection to improve results for 
resolved calibrators
\item Set the visibility model according to the flux density results
\item An option to use the data to derive the relative flux densities
\end{itemize}

</description>

<example>

cb.open('ngc5921.ms')
cb.selectvis(field='1331*,1445*')
cb.setsolve(type='G',table='gcal',t='inf')
cb.solve()
cb.fluxscale (tablein='gcal', tableout='flxcal', 
              reference='1331*', transfer='1445*');
cb.close();


This example generates a calibration table containing {\tt G}
solutuions ('gcal') and then writes a re-scaled version, using
1335+305 as the reference calibrator, to derive properly scaled
amplitude calibration for the transfer source, 1445+099.  We have
assumed that 1331+305 has already had its MODEL\_DATA set to
the correct flux density.

</example>
</method>



 
<method name="accumulate" type="function">
   <shortdescription>Accumulate incremental calibration
solutions into a cumulative calibration table</shortdescription>
   

<input>

     <param name="tablein" direction="in" type="string">
     <description>Input cumulative calibration table name</description>
     <value/>
     </param>

     <param name="incrtable" direction="in" type="string">
     <description>Input incremental calibration table name</description>
     <value/>
     </param>

     <param name="tableout" direction="in" type="string">
     <description>Output cumulative calibration table name.  Default is input table name.</description>
     <value/>
     </param>

     <param name="field" direction="in" type="any">
     <description>List of fields (names) to update in input cumulative table.  Default is all.</description>
     <any type="variant"/>
     <value/>
     </param>

     <param name="calfield" direction="in" type="any">
     <description>List of fields (names) in incremental table to use.  Default is use all.</description>
     <any type="variant"/>
     <value/>
     </param>

     <param name="interp" direction="in" type="string">
     <description>Interpolation mode to use on incremental solutions</description>
     <value>linear</value>
     </param>

     <param name="t" direction="in" type="double">
     <description>Cumulative table timescale when creating from scratch</description>
     <value>-1.0</value>
     </param>

     <param name="spwmap" direction="in" type="intVec">
     <description>Spectral windows to apply</description>
     <value><value>-1</value></value>
     </param>

</input>
<returns type="bool"/>

<description>

This function enables cumulative calibration using {\tt calibrater}.
It is the analog of the task ``CLCAL'' in classic AIPS.

The {\tt accumulate} function is useful when:

\begin{itemize}
\item a calibration solution of a particular type already exists,
\item an incremental calibration solution {\em of the same type} is desired
(an incremental solution in this context means derived independently
from, or determined with respect to, the first)
\item the first calibration cannot be implicitly recovered in the course 
of obtaining the incremental solution
\end{itemize}

For example, a phase-only ``G'' self-calibration on a target source
may be desired to tweak the full amplitude and phase ``G'' calibration
already obtained from a calibrator.  The initial calibration (from the
calibrator) contains amplitude information, and so must be carried
forward, yet the phase-only solution itself cannot (by definition)
recover this information, as a full amplitude and phase
self-calibration would.  In this case, the initial solution must be
applied while solving for the phase-only solution, then the two
solutions combined to form a {\em cumulative} calibration embodying
the net effect of both. In terms of the Measaurement Equation, the net
calibration is the {\em product} of the initial and incremental
solutions.  

The analog of {\tt accumulate} in classic AIPS is the use of CLCAL to
combine a series of (incremental) SN calibration tables to form
successive (cumulative) CL calibration tables.

Cumulative calibration tables also provide a means of generating
carefully interpolated calibration, on variable user-defined
timescales, that can be examined prior to application to the data with
{\tt setapply} and {\tt correct}.  The solutions for different fields
and/or spectral windows can be interpolated in different ways, with
all solutions stored in the same table.

The only difference between incremental and cumulative calibration
tables is that incremental tables are generated directly from the data
via {\tt solve} or (in the near future) from other ancilliary data
(e.g. weather information), and cumulative tables are generated from
other cumulative and incremental tables via {\tt accumulate}.  In all
other respects (internal format, application to data via {\tt
setapply} and {\tt correct}, plotting with {\tt plotcal}, etc.), they
are the same, and therefore interchangable.  Thus, {\tt accumulate} and 
cumulative calibration tables need only be used when circumstances
require it.

The {\tt accumulate} function represents a generalization on the
classic AIPS CLCAL model of cumulative calibration in that its
application is not limited to accumulation of ``G'' solutions (SN/CL
tables classic AIPS are the analog of ``G'' (and, implicitly, ``T'')
in {\tt aips++}).  In principle, any basic calibration type can be
accumulated (onto itself), as long as the result of the accumulation
(matrix product) is of the same type.  This is true of all the basic
types, except ``D''.  Accumulation is currently supported for ``B'',
``G'', and ``T'', and, in future, ``F'' (ionospheric Faraday
rotation), ``J'' (generic full-polarization calibration),
fringe-fitting, and perhaps others.  Accumulation of certain
specialized types (e.g., ``GSPLINE'', ``TOPAC'', etc.) onto the basic
types will be supported in the near future.  The treatment of various
calibration from ancilliary data (e.g., system temperatures, weather
data, WVR, etc.), as they become available, will also make use of {\tt
accumulate} to achieve the net calibration.

Note that accumulation only makes sense if treatment of a uniquely
incremental solution is required (as described above), or if a careful
interpolation or sampling of a solution is desired.  In all other
cases, re-solving for the type in question will suffice to form
the net calibration of that type.  For example, the product of
an existing ``G'' solution and an amplitude and phase ``G'' self-cal 
(solved with the existing solution applied), is equivalent to full
amplitude and phase ``G'' selfcal (with no prior solution applied),
as long as the timescale of this solution is at least as short as
that of the existing solution.  

Use of {\tt accumulate} is straightforward:

The {\tt tablein} parameter is used to specify the existing cumulative
calibration table to which an incremental table is to be applied.
Initially, no such table exists, and {\tt accumulate} will generate
one from scratch (on-the-fly), using the timescale (in seconds)
specified by the parameter {\tt t}.  These nominal solutions will
be unit-amplitude, zero-phase (i.e., unit matrix) calibration,
ready to be adjusted by accumulation.  When {\tt t} is negative (the
default), the table name specified in {\tt tablein} must exist and
will be used.

The {\tt incrtable} parameter is used to specify the incremental table
that should be applied to {\tt tablein}.  The calibration type of
{\tt incrtable} sets the type assumed in the operation, so {\tt
tablein} must be of the same type.  If it is not, {\tt accumulate}
will exit with an error message.  (Certain combinations of types
and subtypes will be supported by accumulate in the future.)

The {\tt tableout} parameter is used to specify the name of the output
table to write.  If un-specified (or ``''), then {\tt tablein} will be
overwritten.  Use this feature with care, since an error here will 
require building up the cumulative table from the most recent distinct
version (if any).

The {\tt field} parameter specifies those field names (standard
selection syntax) in {\tt tablein} to which the incremental solution
should be applied.  The solutions for other fields will be passed to
{\tt tableout} unaltered.  If the cumulative table was created from
scratch in this run of {\tt accumulate}, then these solutions will be
unit-amplitude, zero-phase, as described above.

The {\tt calfield} parameter is used to specify the fields (standard
selection syntax) to select from {\tt incrtable} to use when applying
to {\tt tablein}.  Together, use of {\tt field} and {\tt calfield}
permit completely flexible combinations of calibration accumulation
with respect to fields.  Multiple runs of {\tt accumulate} can be used
to generate a single table with many combinations.  In future, a
``self'' mode will be enabled that will simplify the accumulation of
field-specific solutions.

The {\tt interp} parameter is used to specify the interpolation type
to use on the incremental solutions, as in {\tt setapply}.  The
currently available interpolation types are ``nearest'', ``linear'',
and ``aipslin''.  See the {\tt setapply} URM documentation for more
details.

The {\tt spwmap} parameter enables accumulating solutions from
differing spectral windows.  See {\tt setapply} for details
on how spwmap works.

Pending improvements:

\begin{itemize}
\item Implement a ``self'' mode (independent of interpolation type), 
to simplify or eliminate use of the {\tt field} and {\tt calfield} 
parameters in some contexts (e.g., self-cal)
\item More interpolation modes, e.g., ``cubic'', and interpolation
timescale (timerange to permit interpolation)
\item Handle propogation (or not) of bad/flagged solutions 
\item Support of specialized types (e.g., TOPAC) onto the basic
types
\item Smoothing (probably a separate function)
\end{itemize}

</description>

<example>

cb.open('ap366.sim');

# obtain G solutions from calibrator
cb.selectvis(msselect='FIELD_ID IN [9,11]');
cb.setsolve(type='G',table='cal.G0',t=300);
cb.solve()

# obtain proper flux density scale
cb.fluxscale (tablein='cal.G0', tableout='cal.G1',
             reference='1328+307', transfer=&quot;0917+624&quot;);

# generate cumulative table for target source on 20s timescale
cb.accumulate(tablein='',incrtable='cal.G1',tableout='cal.cG0',
             field='0957+561',calfield='0917+624',
             interp='linear',t=20);

# apply this calibration to target
cb.selectvis(msselect='FIELD_ID==10');
cb.setapply(type='G',table='cal.cG0',interp='linear')
cb.correct();

#    (image target with imager tool)

# phase-selfcal target on 60s timescale 
cb.selectvis(msselect='FIELD_ID==10');
cb.setapply(type='G',table='cal.cG0',interp='linear')
cb.setsolve(type='G',table='cal.G2',t=60,phaseonly=T);
cb.solve();

# accumulate new solution onto existing one
cb.accumulate(tablein='cal.cG0',incrtable='cal.G2',tableout='cal.cG1',
             field='0957+561',calfield='0957+561',
             interp='linear');

# apply new cumulative solution to data
cb.setapply(type='G',table='cal.cG1',interp='linear')
cb.correct();

#   (another round of imaging, etc.)

cb.close();


</example>
</method>


<method name="activityrec" type="function">
   <shortdescription>Returns a record containing properties of recent activity</shortdescription>
   
<returns type="record">
   <description>
     The record key is the name of the Calibrator method that formed
the record.  The contents depend on the activity.
   </description>
</returns>

<description>

This funtion enables returning generic information about recent activity.


Pending improvements:

\begin{itemize}
\item ??
\end{itemize}

</description>

<example>

TBD

</example>
</method>




<method name="specifycal" type="function">
   <shortdescription>Externally specify calibration
of various types</shortdescription>
   
<input>

     <param name="caltable" direction="in" type="string">
     <description>The calibration table name</description>
     <value/>
     </param>

     <param name="time" direction="in" type="string">
     <description>Calibration timestamp</description>
     <value/>
     </param>
     <param name="spw" direction="in" type="string">
     <description>Calibration spw(s)</description>
     <value/>
     </param>
     <param name="antenna" direction="in" type="string">
     <description>Calibration antenna(s)</description>
     <value/>
     </param>
     <param name="pol" direction="in" type="string">
     <description>Calibration polarization</description>
     <value/>
     </param>

     <param name="caltype" direction="in" type="string">
     <description>Calibration timestamp</description>
     <value/>
     </param>

     <param name="parameter" direction="in" type="doubleVec">
     <description>Calibration parameters</description>
     <value><value>1.0</value></value>
     </param>

     <param name="infile" direction="in" type="string">
     <description>Ancillary input file</description>
     <value/>
     </param>

     <param name="uniform" direction="in" type="bool">
     <description>Assume uniform calibration values across the array</description>
     <value>true</value>
     </param>

</input>
<returns type="bool"/>

<description>

This function enables specifying calibration parameters externally.


</description>

<example>

cb.open('ap366.sim');

(TBD)

cb.close();


</example>
</method>

 
<method name="smooth" type="function">
   <shortdescription>Produce a smoothed calibration table</shortdescription>
   

<input>

     <param name="tablein" direction="in" type="string">
     <description>Input calibration table</description>
     </param>

     <param name="tableout" direction="in" type="string">
     <description>Output calibration table</description>
     </param>

     <param name="field" direction="in" type="any">
     <description>Limit smoothing to these fields (default is all fields)</description>
     <any type="variant"/>
     <value/>
     </param>

     <param name="smoothtype" direction="in" type="string">
     <description>The smoothing type: 'mean' or 'median'</description>
     <value>mean</value>
     <value>median</value>
     </param>

     <param name="smoothtime" direction="in" type="double">
     <description>Smoothing filter time constant (sec)</description>
     <value>60.0</value>
     </param>

</input>
<returns type="bool"/>

<description>

This function provides for time-dependent smoothing of sampled
calibration solutions.  Currently supported types are 'G', 'B', and 'T'.
(Smoothing on the frequency axis for 'B' will be supported in the near
future.)

Two (sliding) smoothing types are currenlty supported: 'median' or
'mean', one of these options should be specified in {\stfaf
smoothtype}.  The full width (in seconds) of the smoothing filter
should be specified in {\stfaf smoothtime}.   Amplitude and
(ambiguity-corrected) phase are smoothed separately.

Use {\stfaf field} to limit the smoothing operation to a subset of the
fields (standard selection syntax) found in the calibration table
(other fields will pass to the output table unsmoothed).  If {\stfaf
field} is left blank, all fields in the table will be smoothed.

The smoothing is always done independently for each field, but 
scan boundaries are not observed.  Thus, if the {\stfaf smoothtime} 
is large enough, smoothing may occur over many boundaries. 

Flagged solutions in the input table will not participate in the
smoothing calculation, but will be replaced with smoothed values
if the smoothing window covers one or more unflagged solutions when
centered on the flagged point.

Pending improvements:

\begin{itemize}
\item Add other smoothtypes?
\item Add spw and other selection on input table
\item Add A/P toggle
\end{itemize}

</description>

<example>

cb.open('ngc5921.ms');
cb.smooth(tablein='in.gcal',tableout='out.gcal',
         smoothtype='median',smoothtime=60);
cb.close();


In this example, 'G' solutions for all fields in the table 'in.gcal' are 
smoothed using a median filter with a full-width of 60 seconds,
and the result written to 'out.gcal'.

</example>

</method>

<method name="rerefant" type="function">
   <shortdescription>Apply a new reference antenna</shortdescription>
   

<input>

     <param name="tablein" direction="in" type="string">
     <description>Input calibration table</description>
     </param>

     <param name="tableout" direction="in" type="string">
     <description>Output calibration table</description>
     </param>

     <param name="refantmode" direction="in" type="string">
     <description>The refant application mode</description>
     <value>strict</value>
     <value>flexible</value>
     </param>

     <param name="refant" direction="in" type="any">
     <description>Reference antenna.  Default is none.</description>
     <any type="variant"/>
     <value/>
     </param>


</input>
<returns type="bool"/>

<description>

TBD

Pending improvements:

\begin{itemize}
\item TBD
\end{itemize}

</description>

<example>

cb.open('ngc5921.ms');
cb.rerefant(tablein='in.gcal',tableout='out.gcal',
            refantmode='median',refant='4')
cb.close();

</example>
</method>

<method name="listcal" type="function">
   <shortdescription> List the contents of a calibration table
   </shortdescription>

<input>

     <param name="caltable" direction="in" type="string">
     <description>Calibration table to list</description>
     </param>

     <param name="field" direction="in" type="any">
     <description>Field names or indices to list: ''==\&gt;all</description>
     <any type="variant"/>
     <value/>
     </param>

     <param name="antenna" direction="in" type="any">
     <description>Antenna/Baseline to list: ''==\&gt;all</description>
     <any type="variant"/>
     <value/>
     </param>

     <param name="spw" direction="in" type="any">
     <description>Spectral windows and channels: ''==\&gt;all, spw='10:8~20'</description>
     <any type="variant"/>
     <value/>
     </param>

     <param name="listfile" direction="in" type="string">
     <description>Send output to file: ''==\&gt;send to terminal)</description>
     <value/>
     </param>

     <param name="pagerows" direction="in" type="int">
     <description>Rows per page</description>
     <value>50</value>
     </param>



</input>
<returns type="bool"/>

<description>

calibrater.listcal() lists antenna gain solutions in tabular
form.  The table is organized as follows.  Solutions are output by 
\begin{enumerate}
\item Spectral window,
\item Antenna,
\item Time,
\item Channel,
\item and Polarization.
\end{enumerate}
The inner-most loop is over polarization.
A ``Spw Header'' row is printed each time the spectral window changes.  
In addition  to listing the spectral window ID (SpwID), the Spw Header
also lists the date of observation (Date), the calibration table name (CalTable), and the measurement
set name (MS name).  A lower-level ``antenna header'' is printed each time the antenna
names change or every `pagerows' of output, whichever comes first.
The antenna header column are described here:

\begin{tabular}{ll}
\hline \hline 
Column Name   &amp; Description \\
\hline
Ant           &amp; Antenna name \\
Time          &amp; Visibility timestamp corresponding to gain solution \\
Field         &amp; Field name \\
Chn           &amp; Channel number \\
Amp           &amp; Complex solution amplitude \\
Phs           &amp; Complex solution  phase \\
F             &amp; Flag \\
\hline \hline
\end{tabular}

Elements of the ``F'' column contain an `F' when the datum is flagged, 
and ` ' (whitespace) when the datum is not flagged.

Presently, the polarization mode names (for example: R, L) 
are not given, but the ordering of the polrization modes (left-to-right) is 
equivalent to the order output by task listobs (see ``Feeds'' in listobs output).

</description>

<example>


Input:

The following example imports a UVFITS file, performs a bandpass calibration, 
and displays a subset of the resulting calibration table.

pathname=os.environ.get('CASAPATH').split()[0] # Get path to CASA home dir
fitsdata=pathname+'/data/demo/NGC5921.fits' # Select uv-data (FITS) file
msdata='NGC5921.ms' # MS name; write to current directory
importuvfits(fitsfile=fitsdata, vis=msdata) # import FITS data to MS
setjy(vis=msdata) # Create model data for flux calibrator
caldata=msdata+'.bcal' # Calibration table name
bandpass(vis=msdata, caltable=caldata) # Bandpass calibration
cb.open(msdata) # Open MS in cb
cb.listcal(caltable=caldata, field='N5921_2, 0, 1', antenna='1~5;10~13;20~22', spw='0:4~6', pagerows=0) # List a subset of calibration factors

Output:

SpwID = 0, Date = 1995/04/13,  CalTable = NGC5921.ms.bcal (B Jones), MS name = /users/jcrossle/NRAO/casa/NGC5921.ms                                    
-------------------------------------------------------------------------------------------------------------------------------------------------------
                              | Ant = 1                     | Ant = 2                     | Ant = 3                     | Ant = 4                     |
Time       Field           Chn|  Amp    Phs F   Amp    Phs F|  Amp    Phs F   Amp    Phs F|  Amp    Phs F   Amp    Phs F|  Amp    Phs F   Amp    Phs F|
----------|---------------|---|--------------|--------------|--------------|--------------|--------------|--------------|--------------|--------------|
09:21:46.0 1331+30500002_0   4|0.294    5.3   0.264    3.5   0.296  105.9   0.287 -111.9   0.276  -66.0   0.264  -24.5   0.269  165.8   0.281 -108.6   
09:21:46.0 1331+30500002_0   5|0.303    5.3   0.279    0.6   0.305  107.0   0.298 -111.6   0.283  -64.2   0.274  -23.3   0.280  166.8   0.291 -108.9   
09:21:46.0 1331+30500002_0   6|0.307    5.6   0.287   -1.6   0.309  107.5   0.303 -111.5   0.287  -63.2   0.280  -22.6   0.284  167.8   0.296 -108.8   
10:05:27.9 1445+09900002_0   4|0.467    7.6   0.419    2.7   0.473  107.7   0.455 -112.3   0.437  -63.5   0.413  -24.8   0.427  168.2   0.446 -108.8   
10:05:27.9 1445+09900002_0   5|0.472    7.3   0.440    0.0   0.486  109.1   0.471 -111.8   0.451  -62.6   0.436  -23.1   0.435  169.4   0.453 -108.5   
10:05:27.9 1445+09900002_0   6|0.486    8.4   0.453   -2.4   0.482  110.0   0.478 -111.4   0.452  -60.7   0.443  -23.1   0.446  169.6   0.468 -108.6   
10:09:05.3         N5921_2   4|0.082   50.0   0.074   34.7   0.097  -74.5   0.083   54.4   0.070  131.3   0.080  150.7   0.085   81.0   0.095  150.6   
10:09:05.3         N5921_2   5|0.074   62.7   0.084   24.3   0.114  -73.1   0.093   47.3   0.066  119.9   0.069  154.9   0.099   81.2   0.085  147.4   
10:09:05.3         N5921_2   6|0.079   44.4   0.081   21.7   0.092  -66.3   0.101   48.0   0.089  125.6   0.060  154.0   0.099   83.1   0.097  152.7   
                              | Ant = 5                     | Ant = 10                    | Ant = 11                    | Ant = 12                    |
Time       Field           Chn|  Amp    Phs F   Amp    Phs F|  Amp    Phs F   Amp    Phs F|  Amp    Phs F   Amp    Phs F|  Amp    Phs F   Amp    Phs F|
----------|---------------|---|--------------|--------------|--------------|--------------|--------------|--------------|--------------|--------------|
09:21:46.0 1331+30500002_0   4|0.261  -26.0   0.285 -107.1   0.279 -149.5   0.263    2.9   0.274 -102.5   0.257   -7.0   0.289  174.3   0.309 -139.2   
09:21:46.0 1331+30500002_0   5|0.269  -26.1   0.295 -107.2   0.288 -148.8   0.274    2.3   0.283 -100.9   0.271   -6.8   0.307  173.1   0.319 -138.2   
09:21:46.0 1331+30500002_0   6|0.272  -26.1   0.300 -107.0   0.293 -148.7   0.281    2.0   0.287  -99.7   0.280   -6.7   0.312  171.2   0.326 -137.2   
10:05:27.9 1445+09900002_0   4|0.416  -24.0   0.450 -106.4   0.437 -147.3   0.414    3.2   0.433  -99.6   0.412   -6.8   0.456  175.9   0.477 -140.0   
10:05:27.9 1445+09900002_0   5|0.421  -22.6   0.478 -106.1   0.453 -147.4   0.433    2.0   0.453  -98.1   0.433   -6.7   0.481  174.4   0.491 -138.9   
10:05:27.9 1445+09900002_0   6|0.436  -22.7   0.478 -106.7   0.459 -146.6   0.443    2.4   0.457  -97.1   0.450   -7.0   0.486  173.5   0.510 -137.7   
10:09:05.3         N5921_2   4|0.074   95.0   0.085   -4.2   0.083  109.6   0.084 -116.6   0.081   63.2   0.071  131.2   0.050  -55.4   0.083  -27.4   
10:09:05.3         N5921_2   5|0.071   96.8   0.084  -13.7   0.086  104.3   0.100 -116.4   0.099   61.7   0.084  145.1   0.091  -76.1   0.087  -33.6   
10:09:05.3         N5921_2   6|0.082   84.9   0.078   -5.3   0.101  109.1   0.102 -109.9   0.087   60.1   0.107  130.4   0.085  -75.5   0.080  -31.2   
                              | Ant = 13                    | Ant = 20                    | Ant = 21                    | Ant = 22                    |
Time       Field           Chn|  Amp    Phs F   Amp    Phs F|  Amp    Phs F   Amp    Phs F|  Amp    Phs F   Amp    Phs F|  Amp    Phs F   Amp    Phs F|
----------|---------------|---|--------------|--------------|--------------|--------------|--------------|--------------|--------------|--------------|
09:21:46.0 1331+30500002_0   4|0.285 -169.5   0.277  -90.4   0.254  -36.0   0.290   70.9   0.286  -97.8   0.305  108.8   0.273  -84.6   0.224 -124.2   
09:21:46.0 1331+30500002_0   5|0.296 -168.9   0.287  -90.5   0.269  -38.6   0.300   71.0   0.296  -97.8   0.317  108.2   0.284  -85.8   0.243 -127.6   
09:21:46.0 1331+30500002_0   6|0.301 -168.7   0.291  -90.3   0.278  -39.9   0.306   70.9   0.302  -97.8   0.326  107.2   0.289  -86.6   0.255 -129.7   
10:05:27.9 1445+09900002_0   4|0.448 -167.2   0.434  -90.7   0.401  -34.4   0.456   70.8   0.457  -95.5   0.485  108.9   0.431  -82.1   0.361 -123.9   
10:05:27.9 1445+09900002_0   5|0.466 -166.5   0.457  -91.1   0.423  -36.6   0.470   70.8   0.471  -96.6   0.506  108.1   0.448  -83.2   0.393 -126.7   
10:05:27.9 1445+09900002_0   6|0.473 -166.9   0.464  -91.1   0.436  -37.8   0.485   70.2   0.476  -96.6   0.521  108.0   0.447  -83.2   0.410 -130.0   
10:09:05.3         N5921_2   4|0.097   83.0   0.087  143.5   0.080   43.1   0.094  144.2   0.087  168.7   0.092    1.4   0.111   76.1   0.079   18.9   
10:09:05.3         N5921_2   5|0.100   87.4   0.094  137.0   0.061   54.7   0.098  153.3   0.094  178.6   0.096   -3.7   0.101   64.6   0.091    9.5   
10:09:05.3         N5921_2   6|0.099   93.3   0.122  140.5   0.077   51.3   0.090  151.7   0.083 -179.6   0.100    2.2   0.095   61.3   0.108    0.4   

Listed 108 antenna solutions.



</example>
</method>

 
<method name="posangcal" type="function">
   <shortdescription>Apply position angle calibration to an existing cal table</shortdescription>
   

<input>
     <param name="posangcor" type="doubleVec">
     <description>Position angle corrections (degrees)</description>

     </param>

     <param name="tablein" type="string">
     <description>Input calibration table name</description>
     </param>

     <param name="tableout" type="string">
     <description>Output calibration table name.  Default is input table name.</description>
     <value/>
     </param>
</input>
<returns type="bool"/>

<description>

This function is used to apply position angle calibration for
observations made using circularly polarized feeds.  According to the
Measurement Equation formalism, this correction should be applied to a
{\tt D} (instrumental polarization) calibration table.

If no {\tt D} calibration is performed (and thus no such table is
available), the correction can be applied to a {\tt G} table, but it
should NEVER be applied to both, and always applied to a {\tt D} table
if one is available.  An input table must be specified.  If no output
table is specified, then the input table will be modified in place.

Specify, as a vector of values, a position angle adjustment (in degrees)
for each spectral window.  If only one value is specified, it will be
duplicated to all spectral windows; otherwise, the number of values
specified must match the number of spectral windows.  The sign
convention for the position angle adjustment is such that the specified
value is the that which, when added to the position angle implied by the
data, will yield the correct position angle.  For example, if {\tt G-},
{\tt D-}, and {\tt P-}calibrated data for 3c286 suggests a position
angle of 45 degrees, the posangcor value should be -12 degrees as this
will yield the correct position angle of 33 degrees when added.  In
general, posangcor equals correct position angle minus observed position
angle. 

A future version of this function will have an option to recognize
standard position angle calibrators and determine the correction
automatically. 

(NB: It may be desirable to use solutions for 'X' to handle
position angle calibration, rather than this method.)


</description>

<example>

cb.open('polcal.ms');
cb.posangcal(tablein='3C286.dcal', tableout='3C286.dpacal', 
             posangcor=[-12.0, 54.0]);
cb.close();


This example takes an existing calibration table containing {\tt D}
Jones matrices, and applies a position angle calibration of 45 and 54
degrees to spectral windows 1 \&amp; 2, respectively, writing the result
to a new table.  The observed position angles for 3C286 must have been
45 and -21 degrees; the corrections specified yield the correct value
of 33 degrees when added to the observed values.
</example>
</method>

<method name="linpolcor" type="function">
   <shortdescription>Correct the gain table for linear polarization of the calibrator</shortdescription>
   

<input>

     <param name="tablein" type="string">
     <description>Input calibration table name</description>
     <value/>
     </param>

     <param name="tableout" type="string">
     <description>Output calibration table name</description>
     <value/>
     </param>

     <param name="fields" type="stringVec">
     <description>Calibrator field names</description>
     <value/>
     </param>
</input>
<returns type="bool"/>

<description>

THIS METHOD IS CURRENTLY DISABLED.

This function can be used to correct the gains derived from secondary
calibrators with unknown or variable polarization.  It should only be
used for arrays with linear (X/Y) feeds and an Alt-Az mount for which
the observed polarization varies with feed position angle on the sky. 

The function fits the gains with a sine and cosine term in feed position
angle and extracts the Q and U components of the secondary calibrator. 
This is only possible if there is sufficient range in the position angle
(i.e., minimum of about 6 scans spanning at least 90 degrees in position
angle).  Check the error of the fit to judge if the fit was succesfull,
it should generally be smaller than 0.5\%.  

Use the {\stfaf fields} argument to select calibrator fields to be
fitted.  The function takes a calibration table as input, and can write
the adjusted gain solutions to the same table on output, or create a new
table containing these results.  The function also prints the derived
polarization for each field for each spectral window. 

</description>

<example>

cb.open('atca.ms');
cb.linpolcor(tablein='atca.gcal', tableout='atca.gcal2', 
             fields='2254-367');
cb.close();


This example takes an existing calibration table containing {\tt G}
Jones matrices, and writes a corrected output table, correcting only
gains derived from 2254-367 for linear polarization.

</example>
</method>



 
<method name="plotcal" type="function">
   <shortdescription>Plot a calibration table</shortdescription>
   

<input>

     <param name="antennas" direction="in" type="intVec">
     <description>Antennas to plot.  Default is none.</description>

     </param>

     <param name="fields" direction="in" type="intVec">
     <description>Fields to plot.  Default is none.</description>

     </param>

     <param name="spwids" direction="in" type="intVec">
     <description>Spectral windows id.'s to plot.  Default is none.</description>

     </param>

     <param name="plottype" direction="in" type="string">
     <description>Plot type</description>
     <value>1/AMP</value>
     <value>PHASE</value>
     <value>RLPHASE</value>
     <value>XYPHASE</value>
     <value>RI</value>
     <value>DAMP</value>
     <value>DPHASE</value>
     <value>DRI</value>
     <value>FIT</value>
     <value>FITWGT</value>
     <value>TOTALFIT</value>
     <value>AMP</value>
     </param>

     <param name="tablename" direction="in" type="string">
     <description>Calibration table name</description>
     <value/>
     </param>

     <param name="polarization" direction="in" type="int">
     <description>Polarization to plot</description>
     <value>1</value>
     </param>

     <param name="multiplot" direction="in" type="bool">
     <description>Turn on separate antenna plots</description>
     <value>false</value>
     </param>

     <param name="nx" direction="in" type="int">
     <description>If multiplot=T, number of plots on horizontal axis</description>
     <value>1</value>
     </param>

     <param name="ny" direction="in" type="int">
     <description>If multiplot=T, number of plots on vertical axis</description>
     <value>1</value>
     </param>

     <param name="psfile" direction="in" type="string">
     <description>Name of output PostScript file to write plot
to.  Default is to send plot to the screen.</description>
     <value/>
     </param>
</input>
<returns type="bool"/>

<description>

This function plots a calibration table either to a plotter or 
to a file.  

The argument {\stfaf plottype} can take the following values
for all types of solutions: 
\begin{description}
\item[AMP] Gain Amplitude vs. Time
\item[1/AMP] Inverse Gain Amplitude vs. Time (useful for 
comparing with classic AIPS)
\item[PHASE] Gain Phase vs. Time
\item[RI] Gain Real vs. Imaginary
\item[RLPHASE] Right/Left Gain phase difference (if polarizations are R,L)
\item[XYPHASE] X/Y Gain phase difference (if polarizations are X,Y)
\end{description}

The argument {\stfaf plottype} can take the following values
for D tables

\begin{description}
\item[DAMP] Cross-polarized Gain Amplitude vs. Time
\item[DPHASE] Cross-polarized Gain Phase vs. Time
\item[DRI] Cross-polarized Gain Real vs. Imaginary
\end{description}

The quality of the solutions can be examined with the following 
{\stfaf plottype} choices:
\begin{description}
\item[FIT] Fit per spectral window
\item[FITWGT] Fit weight per spectral window
\item[TOTALFIT] Total fit
\end{description}

By default, all antennas (as specified in the antennas argument) will
appear on the same plot. Separate plots (all with the same scale) 
for each antenna can be activated by setting multiplot=T.  The multiplot
argument only separates plots by antenna (not, e.g., by the field\_id(s)
specified in the fields argument).  If multiplot=T, the nx and ny 
arguments can be used to specify the number of plots per page.

At the moment, only one polarization can be plotted per execution.
This restriction will be relaxed in the near future.

For B solutions, the plotting will loop over timestamps (if more than
one).  

A hardcopy plot can be created by specifying the \texttt{psfile}
argument (which is especially useful for batch processing when a
display screen is not available).  This will cause the plot to be
written to a PostScript file which can be subsequently sent to a
printer.  

</description>

<example>

cb.open('ngc5921.ms');
cb.plotcal(plottype='PHASE', tablename=&quot;gcal&quot;, antennas=[1,3], polarization=2);
cb.close();

</example>
</method>

<method name="modelfit" type="function">
   <shortdescription> Model fitting</shortdescription>
<input>
   <param name="vary" type="boolVec">
   <description>If specified where T, let this parameter (in par) vary in fit</description>
   </param>
   <param name="niter" type="int">
   <description>Number of non-linear fitting iterations</description>
   <value>0</value>
   </param>
   <param name="compshape" type="string">
   <description>Component shape, P=point G=gaussian</description>
   <value>P</value>
   </param>
   <param name="par" type="doubleVec">
   <description>Initial guess for fit parameters (default is for &quot;P)&quot;I flux, rel RA, rel Dec, 1,0, 0.0, 0.0 are defaults</description>
   <value type="vector">
   <value>1.0</value>
   <value>0.0</value>
   <value>0.0</value>
   </value>
   </param>
   <param name="file" type="string">
   <description>If specified, output componentslist file name,
		if empty don't write componentslist file</description>
   <value/>
   </param>
   </input>

   <returns type="doubleVec"/>

<description>

This method fits single-component models (points, elliptical Gaussians or elliptical Disks\_
to the CORRECTED\_DATA of the selected field.  A first guess for the component
parameters may be specified in the {\stfaf par} parameter. 

</description>

<example>

cb.open('ngc5921.ms');
cb.selectvis(field='1331*')
cb.modelfit(compshape='P',par=[15.0,0.0,0.0]) 
cb.close();


This example fits a point source mode using 15.0 Jy at the origin (phase center)
as a first guess.



cb.open('ngc5921.ms');
cb.selectvis(field='1331*')
cb.modelfit(compshape='G',par=[15.0,0.0,0.0,2.0,1.0,0.0]) 
cb.close();


This example fits a Guassian model with a starting
guess of 15 Jy at the phase center (0,0), with 2.0 arcsec major axis,
1.0 axial ratio, at position angle 0.0 deg.

</example>

</method>


<method name="createcaltable" type="function">
  <shortdescription>Create an empty calibration table</shortdescription>

<input>
     <param name="caltable" direction="in" type="string">
     <description>Calibration table name</description>
     <allowed kind="enum">
          <value>Real</value>
	  <value>Complex</value>
     </allowed>
     </param>
     <param name="partype" direction="in" type="string">
     <description>Parameter type name</description>
     </param>
     <param name="caltype" direction="in" type="string">
     <description>Calibration type name</description>
     </param>
     <param name="singlechan" direction="in" type="bool">
     <description>Create a calibration table with frequency-independent parameters?</description>
     </param>
</input>

<returns type="bool"/>

<description>
Creates an empty calibration table that can subsequently be filled
with by using the table tool.
</description>

<example>
cb.open('ngc5921.ms',F,F,F)   # don't add MODEL_DATA, etc.
cb.createcaltable('ngc5921.gcal', 'Complex', 'G Jones', True)
cb.close()
</example>

</method>


<method name="updatecaltable" type="function">
   <shortdescription>Caltable modernizer.</shortdescription>

<input>
   <param name="caltable" direction="in" type="string">
   <description>Name of the caltable.</description>
   </param>
</input>
<returns type="bool"/>

<description>
This method can be used to update a caltable (from v3.4 or later)
to the current version of CASA.

The following updates are currently supported.

o At CASA v4.1.0, the OBSERVATION subtable and OBSERVATION\_ID column
were added to caltables.  This method adds trivial versions of
these elements to pre-v4.1 caltables.

</description>

<example>
cb.updatecaltable(&quot;mycaltable&quot;);
</example>

</method>



 
<method name="close" type="function">
   <shortdescription>Close the calibrater tool</shortdescription>
   
<returns type="bool"/>

<description>
Close the {\tt calibrater} tool, which is hardly ever necessary.

</description>

<example>

cb.open('ngc5921.ms');
cb.close();

</example>
</method>

 
<method name="done" type="function">
   <shortdescription>Destroy the calibrater tool</shortdescription>
   
<returns type="bool"/>

<description>
This function is redundant with the {\stfaf close} method.

</description>

<example>

cb.open('ngc5921.ms');
cb.done();

</example>
</method>


<method name="parsecallibfile" type="function">
   <shortdescription>Bootstrap the flux density scale from standard calibrators</shortdescription>
   
<input>
     <param name="filein" direction="in" type="string">
     <description>Input cal library file name</description>
     </param>
</input>

<returns type="record">
   <description>
   </description>
</returns>

<description>

TBD

</description>

<example>

TBD

</example>
</method>


<method name="setcorrdepflags" type="function">
   <shortdescription>Control use of correlation-dependent flags</shortdescription>
   
<input>
     <param name="corrdepflags" direction="in" type="bool">
     <description>Turn correlation dependent flags on/off (true/false)</description>
     </param>
</input>

<returns type="bool">
   <description>
   </description>
</returns>

<description>

TBD

</description>

<example>

TBD

</example>
</method>



<method name="setvi" type="function">
<shortdescription>TEMPORARY method to control use of new VI2 regime</shortdescription>

<input>
     <param name="old" direction="in" type="bool">
     <description>Use old-style VI, if old=True, else use new VI2</description>
     <value>false</value>
     </param>
     <param name="quiet" direction="in" type="bool">
     <description>Warn in logger, if quiet=False</description>
     <value>false</value>
     </param>
</input>
<returns type="bool"/>

<description>
Use this method to control whether the modern (old=False) or old-style (old=True)
VisibilityIterator is used by the calibration application.  General users should 
avoid use of this function unless they understand what this means. 

This method will be removed from the calibrater tool in v5.1.

</description>

<example>

cb.setvi(True)   
cb.open('ngc5921.ms')


</example>
</method>



</tool>




</casaxml>
