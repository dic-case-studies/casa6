##################### generated by xml-casa (v2) from imagepol.xml ##################
##################### 3b7437629b45930681a8977ca52048f2 ##############################
from __future__ import absolute_import 
from .__casac__ import imagepol as _imagepol
from .platform import str_encode as _str_ec
from .platform import str_decode as _str_dc
from .platform import dict_encode as _dict_ec
from .platform import dict_decode as _dict_dc
from .platform import dict_encode as _quant_ec
from .platform import dict_decode as _quant_dc
from .platform import encode as _any_ec
from .platform import decode as _any_dc
from .typecheck import validator as _pc
from .coercetype import coerce as _coerce
from .image import image as _wrap_image

class imagepol:
    ### self
    def __init__(self, *args, **kwargs):
        """The constructor takes an image as its input.  This can be specified as
        either the name of a disk file, or you can give a pre-existing Image
        tool.   If you give a disk file name, the disk image file may
        be in casa, fits or Miriad format.
        
        The input image must have a Stokes axis.  The exact collection of Stokes
        that the image has, determines what the Imagepol tool can compute.
        Stokes I, Q, U, and V refer to total intensity, two components of linear
        polarization, and circular polatization, respectively.  Therefore, if
        you ask for linear polarization and the image only has Stokes I and V,
        you will get an error.
        
        The input image may contain data at many frequencies.  For example, the
        image may be a 4D image with axes RA, DEC, Stokes and Frequency (order
        not important) where the Frequency axis is regularly sampled.  However,
        the image may also contain many frequencies at irregular intervals.
        Such an image may be created with the Image tool constructor called
        imageconcat.  It enables you to concatenate
        images along an axis, and it allows irregular coordinate values along that
        axis.
        """
        self._swigobj = kwargs.get('swig_object',None)
        if self._swigobj is None:
            self._swigobj = _imagepol()

    def imagepoltestimage(self, outfile='imagepol.iquv', rm=[ float(0.0) ], pa0=float(0.0), sigma=float(0.01), nx=int(32), ny=int(32), nf=int(32), f0=float(1.4e9), bw=float(128.0e6)):
        """This function can be used to generate a test image and then
        attach the Imagepol tool to it.
        
        The test image is 4-dimensional (RA, DEC, Stokes and Frequency).  The
        Stokes axis holds I,Q,U and V.  The source is just a constant I (if you
        don't add noise all spatial pixels will be identical) and V.  Q and U
        vary with frequency according to the specified Rotation Measure
        components (no attempt to handle bandwidth smearing within channels is
        made).  The actual values of I,Q,U, and V are chosen arbitrarily
        otherwise (could be added as arguments if desired).
        
        You can use this image, in particular, to explore the Rotation Measure
        algorithms in functions rotationmeasure and
        fourierrotationmeasure.
        
        If you don't specify the Rotation Measure, then it is chosen for you so
        that there is no position angle ambiguity between adjacent channels
        (the value will be sent to the Logger).
        
        The noise added to the image is specified as a fraction of the total
        intensity (constant).  Gaussian noise with a standard deviation of
        {stfaf sigma * $I_{max}$} is then added to the image.
        """
        schema = {'outfile': {'type': 'cStr'}, 'rm': {'type': 'cFloatVec', 'coerce': [_coerce.to_list,_coerce.to_floatvec]}, 'pa0': {'type': 'cFloat', 'coerce': _coerce.to_float}, 'sigma': {'type': 'cFloat', 'coerce': _coerce.to_float}, 'nx': {'type': 'cInt'}, 'ny': {'type': 'cInt'}, 'nf': {'type': 'cInt'}, 'f0': {'type': 'cFloat', 'coerce': _coerce.to_float}, 'bw': {'type': 'cFloat', 'coerce': _coerce.to_float}}
        doc = {'outfile': outfile, 'rm': rm, 'pa0': pa0, 'sigma': sigma, 'nx': nx, 'ny': ny, 'nf': nf, 'f0': f0, 'bw': bw}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _imagepoltestimage_result = self._swigobj.imagepoltestimage(_str_ec(_pc.document['outfile']), _pc.document['rm'], _pc.document['pa0'], _pc.document['sigma'], _pc.document['nx'], _pc.document['ny'], _pc.document['nf'], _pc.document['f0'], _pc.document['bw'])
        return _imagepoltestimage_result

    def complexlinpol(self, outfile):
        """This function  produces
        the complex linear polarization; $Q+iU$ and writes
        it to a disk image file.
        
        The Image tool cannot yet handle Complex
        images.  You must therefore write the Complex image to disk.  The
        Viewer can display Complex images. Also the
        Table tool can access Complex images.
        """
        schema = {'outfile': {'type': 'cStr'}}
        doc = {'outfile': outfile}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _complexlinpol_result = self._swigobj.complexlinpol(_str_ec(_pc.document['outfile']))
        return _complexlinpol_result

    def complexfraclinpol(self, outfile):
        """This function produces
        the complex fractional linear polarization; $(Q+iU)/I$ and writes
        it to a disk image file.
        
        The Image tool cannot yet handle Complex
        images.  You must therefore write the Complex image to disk.  The
        Viewer can display Complex images. Also the
        Table tool can access Complex images.
        """
        schema = {'outfile': {'type': 'cStr'}}
        doc = {'outfile': outfile}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _complexfraclinpol_result = self._swigobj.complexfraclinpol(_str_ec(_pc.document['outfile']))
        return _complexfraclinpol_result

    def depolratio(self, infile, debias=False, clip=float(10.0), sigma=float(-1), outfile=''):
        """This function  returns the linear
        depolarization ratio computed from two frequencies; this is the ratio of
        the fractional linear polarization at the two frequencies.  Generally
        this is done when you have generated two images, each at a different frequency
        (continuum work). Thus if the fractional linear polarization images are
        $m_{nu 1}$ and $m_{nu 2}$ then the depolarization ratio is
        $m_{nu 1}/ m_{nu 2}$.
        
        This function operates with two images; the first (at frequency $nu 1$)
        is the one attached to your Imagepol tool.  The second (at
        frequency $nu 2$) is supplied via the argument {stfaf infile}, which
        is  a String holding the name of the
        imagefile.
        
        In generating the depolarization ratio, you may optionally debias the
        linearly polarized intensity.  This requires the standard deviation of
        the thermal noise.  You can either supply it if you know it, or it will
        be worked out for you with outliers from the mean clipped at the
        specified level.
        
        You can get the depolarization ratio error image with function
        sigmadepolratio.
        """
        schema = {'infile': {'type': 'cReqPath', 'coerce': _coerce.expand_path}, 'debias': {'type': 'cBool'}, 'clip': {'type': 'cFloat', 'coerce': _coerce.to_float}, 'sigma': {'type': 'cFloat', 'coerce': _coerce.to_float}, 'outfile': {'type': 'cStr'}}
        doc = {'infile': infile, 'debias': debias, 'clip': clip, 'sigma': sigma, 'outfile': outfile}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _depolratio_result = _wrap_image(swig_object=self._swigobj.depolratio(_str_ec(_pc.document['infile']), _pc.document['debias'], _pc.document['clip'], _pc.document['sigma'], _str_ec(_pc.document['outfile'])))
        return _depolratio_result

    def close(self):
        """This function closes the imagepol tool.  This means that it detaches
        the tool from its imagefile (flushing all the changes first).  The
        imagepol tool is ``null'' after this change (it is not destroyed) and
        calling any toolfunction other than open will result in an
        error.
        """
        _close_result = self._swigobj.close()
        return _close_result

    def done(self):
        """This function is the same as close().
        """
        _done_result = self._swigobj.done()
        return _done_result

    def fourierrotationmeasure(self, complex='', amp='', pa='', real='', imag='', zerolag0=False):
        """This function  will only work if
        you attach the Imagepol tool (using open) to an image containing
        Stokes Q and U, and a regular frequency axis.  It Fourier transforms
        the complex linear polarization (Q+iU) over the spectral axis to the
        rotation measure axis.  Thus, if your input image contained
        RA/DEC/Stokes/Frequency, the output image would be
        RA/DEC/RotationMeasure.  The Rotation Measure axis has as many pixels
        as the spectral axis.
        
        This method enables you to see the polarization as a function of
        Rotation Meausure.  Its main use is when searching for large RMs.  See
        Killeen, Fluke, Zhao and Ekers (1999, preprint) for a description of
        this method (or http://www.atnf.csiro.au/verb+~+nkilleen/rm.ps) and its
        advantages over the traditional method
        (rotationmeasure) of
        extracting the Rotation Measure.
        
        Although you can write out the complex polarization image with the
        argument {stfaf complex}, you can't do much with it because Image
        tools cannot handle complex images.  Hence you can
        also write out the complex linear polarization image in any or all of
        the other forms.
        
        The argument {stfaf zerolag0} allows you to force the zero lag (or
        central bin) of the Rotation Measure spectrum to zero (effectively by
        subtracting the mean of Q and U from the Q and U images).  This may
        avoid Gibbs phenomena from any strong low Rotation Measure signal which
        would normally fall into the central bin.
        """
        schema = {'complex': {'type': 'cStr'}, 'amp': {'type': 'cStr'}, 'pa': {'type': 'cStr'}, 'real': {'type': 'cStr'}, 'imag': {'type': 'cStr'}, 'zerolag0': {'type': 'cBool'}}
        doc = {'complex': complex, 'amp': amp, 'pa': pa, 'real': real, 'imag': imag, 'zerolag0': zerolag0}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _fourierrotationmeasure_result = self._swigobj.fourierrotationmeasure(_str_ec(_pc.document['complex']), _str_ec(_pc.document['amp']), _str_ec(_pc.document['pa']), _str_ec(_pc.document['real']), _str_ec(_pc.document['imag']), _pc.document['zerolag0'])
        return _fourierrotationmeasure_result

    def fraclinpol(self, debias=False, clip=float(10.0), sigma=float(-1), outfile=''):
        """This function
        returns the fractional linear polarization; $sqrt{(Q^2+U^2)}/I$.
        
        You may optionally debias the polarized intensity.  This requires the
        standard deviation of the thermal noise.  You can either supply it if
        you know it, or it will be worked out for you with outliers from the
        mean clipped at the specified level.
        """
        schema = {'debias': {'type': 'cBool'}, 'clip': {'type': 'cFloat', 'coerce': _coerce.to_float}, 'sigma': {'type': 'cFloat', 'coerce': _coerce.to_float}, 'outfile': {'type': 'cStr'}}
        doc = {'debias': debias, 'clip': clip, 'sigma': sigma, 'outfile': outfile}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _fraclinpol_result = _wrap_image(swig_object=self._swigobj.fraclinpol(_pc.document['debias'], _pc.document['clip'], _pc.document['sigma'], _str_ec(_pc.document['outfile'])))
        return _fraclinpol_result

    def fractotpol(self, debias=False, clip=float(10.0), sigma=float(-1), outfile=''):
        """This function
        returns the fractional linear polarization; $sqrt{(Q^2+U^2+V^2)}/I$.
        
        You may optionally debias the polarized intensity.  This requires the
        standard deviation of the thermal noise.  You can either supply it if
        you know it, or it will be worked out for you with outliers from the
        mean clipped at the specified level.
        
        If your image contains only Q and U, or only V, then just
        those components contribute to the total polarized intensity.
        """
        schema = {'debias': {'type': 'cBool'}, 'clip': {'type': 'cFloat', 'coerce': _coerce.to_float}, 'sigma': {'type': 'cFloat', 'coerce': _coerce.to_float}, 'outfile': {'type': 'cStr'}}
        doc = {'debias': debias, 'clip': clip, 'sigma': sigma, 'outfile': outfile}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _fractotpol_result = _wrap_image(swig_object=self._swigobj.fractotpol(_pc.document['debias'], _pc.document['clip'], _pc.document['sigma'], _str_ec(_pc.document['outfile'])))
        return _fractotpol_result

    def linpolint(self, debias=False, clip=float(10.0), sigma=float(-1), outfile='', region='', mask='', stretch=False):
        """This application returns the linearly polarized intensity; $sqrt{(Q^2+U^2)}$.
        
        The linearly polarized intensity may optionally be debiased (if debias=True).
        This requires an estimate of the thermal noise level (sigma). The resulting
        image will be computed using
        
        $sqrt{(Q^2 + U^2 - sigma^2)}$
        
        If the specified value of sigma is positive, that is the value that will
        be used for debiasing. If it is not, the value used for sigma is computed
        using the following algorithm:
        
        1. First, a stokes plane(s) is chosen on which the sigma computation is performed.
        If the V plane exists, that is used to compute sigma. If not, then the value of
        sigma is computed to be the average of the sigma values of the Q and U planes.
        
        2. For the relevant plane(s), the sigma value is computed for unmasked pixel values
        which lie within +/- (clip * stddev) values of the mean for that plane, where the mean
        and stddev (the standard deviation) are computed by using all unmasked pixel values
        in the relevant plane. In this way, outliers (eg pixels due to possible
        astronomical signals) are excluded in the computation of sigma.
        
        In the output image, pixels for which the expression inside the square root is
        negative are masked, and their values are set to zero.
        
        If a region and/or mask is specified, debias=True and sigma is not positive so
        that the value of sigma is determined using the algorithm above, the region and mask
        are applied first to the plane(s) from which the value of sigma is determined and
        then sigma is computed.
        """
        schema = {'debias': {'type': 'cBool'}, 'clip': {'type': 'cFloat', 'coerce': _coerce.to_float}, 'sigma': {'type': 'cFloat', 'coerce': _coerce.to_float}, 'outfile': {'type': 'cStr'}, 'region': {'anyof': [{'type': 'cStr'}, {'type': 'cDict'}]}, 'mask': {'type': 'cStr'}, 'stretch': {'type': 'cBool'}}
        doc = {'debias': debias, 'clip': clip, 'sigma': sigma, 'outfile': outfile, 'region': region, 'mask': mask, 'stretch': stretch}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _linpolint_result = _wrap_image(swig_object=self._swigobj.linpolint(_pc.document['debias'], _pc.document['clip'], _pc.document['sigma'], _str_ec(_pc.document['outfile']), _any_ec(_pc.document['region']), _str_ec(_pc.document['mask']), _pc.document['stretch']))
        return _linpolint_result

    def linpolposang(self, outfile='', region='', mask='', stretch=False):
        """This function returns the linearly polarized position angle image 0.5*arctan(U/Q) in degrees.
        The output image will not have a restoring beam, even if the input image does.
        """
        schema = {'outfile': {'type': 'cStr'}, 'region': {'anyof': [{'type': 'cStr'}, {'type': 'cDict'}]}, 'mask': {'type': 'cStr'}, 'stretch': {'type': 'cBool'}}
        doc = {'outfile': outfile, 'region': region, 'mask': mask, 'stretch': stretch}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _linpolposang_result = _wrap_image(swig_object=self._swigobj.linpolposang(_str_ec(_pc.document['outfile']), _any_ec(_pc.document['region']), _str_ec(_pc.document['mask']), _pc.document['stretch']))
        return _linpolposang_result

    def makecomplex(self, complex, real='', imag='', amp='', phase=''):
        """This function generates a Complex imagefile from either
        a real and imaginary, or an amplitude and phase pair of images.
        If you give a linear position angle image for the phase,
        it will be multipled by two before the real and imaginary
        parts are formed.
        """
        schema = {'complex': {'type': 'cStr'}, 'real': {'type': 'cStr'}, 'imag': {'type': 'cStr'}, 'amp': {'type': 'cStr'}, 'phase': {'type': 'cStr'}}
        doc = {'complex': complex, 'real': real, 'imag': imag, 'amp': amp, 'phase': phase}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _makecomplex_result = self._swigobj.makecomplex(_str_ec(_pc.document['complex']), _str_ec(_pc.document['real']), _str_ec(_pc.document['imag']), _str_ec(_pc.document['amp']), _str_ec(_pc.document['phase']))
        return _makecomplex_result

    def open(self, image={ }):
        """Before polarimetric analysis can commence, an imagefile must be
        attached to the imagepol tool using the open function.  Also, use this
        function when you are finished analyzing the current imagefile and
        want to attach to another one.  This function detaches the imagetool
        from the current imagefile, if one exists, and reattaches it (opens)
        to the new imagefile.
        
        The input image file may be in native casa, fits, or Miriad
        format.  Look htmlref{here}{IMAGES:FOREIGNIMAGES}  for more
        information on foreign images.
        
        The input image must have a Stokes axis. The exact collection of
        Stokes that the image has, determines what the Imagepol tool can
        compute. Stokes I, Q, U, and V refer to total intensity, two
        components of linear polarization, and circular polatization,
        respectively. Therefore, if you ask for linear polarization and the
        image only has Stokes I and V, you will get an error.
        
        The input image may contain data at many frequencies. For example, the
        image may be a 4D image with axes RA, DEC, Stokes and Frequency (order
        not important) where the Frequency axis is regularly sampled. However,
        the image may also contain many frequencies at irregular
        intervals. Such an image may be created with the Image tool function
        imageconcat. It enables you to concatenate images along an axis, and
        it allows irregular coordinate values along that axis.
        """
        schema = {'image': {'anyof': [{'type': 'cReqPath', 'coerce': _coerce.expand_path}, {'type': 'cDict'}]}}
        doc = {'image': image}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _open_result = self._swigobj.open(_any_ec(_pc.document['image']))
        return _open_result

    def pol(self, which, debias=False, clip=float(10.0), sigma=float(-1), outfile=''):
        """This function just packages the other specific polarization
        functions into one where you specify an operation with the
        argument {stfaf which} (can be useful for scripts).
        This argument can take the values:
        
        begin{itemize}
        item 'lpi' - linearly polarized intensity (function
        linpolint)
        
        item 'tpi' - total polarized intensity (function
        totpolint)
        
        item 'lppa' linearly polarized position angle (function
        linpolposang)
        
        item 'flp' - fractional linear polarization (function
        fraclinpol)
        
        item 'ftp' - fractional total polarized intensity (function
        fractotpol)
        
        end{itemize}
        """
        schema = {'which': {'type': 'cStr'}, 'debias': {'type': 'cBool'}, 'clip': {'type': 'cFloat', 'coerce': _coerce.to_float}, 'sigma': {'type': 'cFloat', 'coerce': _coerce.to_float}, 'outfile': {'type': 'cStr'}}
        doc = {'which': which, 'debias': debias, 'clip': clip, 'sigma': sigma, 'outfile': outfile}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _pol_result = _wrap_image(swig_object=self._swigobj.pol(_str_ec(_pc.document['which']), _pc.document['debias'], _pc.document['clip'], _pc.document['sigma'], _str_ec(_pc.document['outfile'])))
        return _pol_result

    def rotationmeasure(self, rm='', rmerr='', pa0='', pa0err='', nturns='', chisq='', sigma=float(-1), rmfg=float(0.0), rmmax=float(0.0), maxpaerr=float(1e30), plotter='', nx=int(5), ny=int(5)):
        """This function generates the rotation
        measure image from a collection of different frequencies.  It will only
        work if the Imagepol tool is attached to an image containing
        Stokes $Q$ and $U$, and a frequency axis (regular or irregular) with at
        least 2 pixels.  It will work out the position angle images for you.
        
        See also the fourierrotationmeasure
        function for a new Fourier-based approach.
        
        Rotation Measure algorithms that work robustly are not common.  The main
        problem is in trying to account for the $n- pi$ ambiguity (see Leahy et
        al, Astronomy & Astrophysics, 156, 234 or Killeen et al;
        http://www.atnf.csiro.au/verb+~+nkilleen/rm.ps).
        
        The algorithm that this function uses is that of Leahy et al. (see Appendix A.1).  But as in all
        these algorithms, the basic process is that for each spatial pixel, a
        vector of position angles (i.e.  at the different frequencies) is fit to
        determine the rotation measure and the position angle at zero wavelength
        (and their errors).   An image containing
        the number of $n- pi$ turns that were added to the data
        at each spatial pixel and for which the best fit was found can be written.
        The reduced chi-squared image for the fits can also be written.
        
        Note that no assessment of curvature (i.e. deviation
        from the simple linear position angle - $lambda^2$ functional form)
        is made.
        
        Any combination of output images can be written.
        
        The argument {stfaf sigma} gives the thermal noise in Stokes Q and U.
        By default it is determined automatically using the image data.  But if it proves
        to be inaccurate (maybe not many signal-free pixels), it may be specified.
        This is used for calculating the error in the
        position angles (propagation of Gaussian errors).
        
        The argument {stfaf maxpaerr} specifies the maximum allowable error in
        the position angle that is acceptable.  The default is an infinite
        value.  From the standard propagation of errors, the error in the
        linearly polarized position angle is determined from the Stokes $Q$ and
        $U$ images (at each spatial pixel for each frequency).  At each spatial
        pixel we do a fit to the position angle vector (i.e.  at the different
        frequencies) to determine the rotation measure.  If the position angle
        error for any pixel in the vector exceeds the specified value, it is
        dropped from the fit.     The process generates an error for the
        fit and this is used to compute the errors in the output
        images.
        
        Note that {stfaf maxpaerr} is {it not} used to specify that any pixel
        for which the output position angle error exceeds this value
        should be masked out.
        
        The argument {stfaf rmfg} is used to specify a foreground RM value.  For
        example, you may know the mean RM in some direction out of the Galaxy,
        then including this can aid the algorithm by reducing ambiguity.
        
        The argument {stfaf rmmax} specifies the maximum absolute RM that
        should be solved for.  This quite an important parameter.  If you leave
        it at the default, zero, no ambiguity handling will be
        used.  So some apriori information should be supplied; this
        is the basic problem with rotation measure algorithms.
        """
        schema = {'rm': {'type': 'cStr'}, 'rmerr': {'type': 'cStr'}, 'pa0': {'type': 'cStr'}, 'pa0err': {'type': 'cStr'}, 'nturns': {'type': 'cStr'}, 'chisq': {'type': 'cStr'}, 'sigma': {'type': 'cFloat', 'coerce': _coerce.to_float}, 'rmfg': {'type': 'cFloat', 'coerce': _coerce.to_float}, 'rmmax': {'type': 'cFloat', 'coerce': _coerce.to_float}, 'maxpaerr': {'type': 'cFloat', 'coerce': _coerce.to_float}, 'plotter': {'type': 'cStr'}, 'nx': {'type': 'cInt'}, 'ny': {'type': 'cInt'}}
        doc = {'rm': rm, 'rmerr': rmerr, 'pa0': pa0, 'pa0err': pa0err, 'nturns': nturns, 'chisq': chisq, 'sigma': sigma, 'rmfg': rmfg, 'rmmax': rmmax, 'maxpaerr': maxpaerr, 'plotter': plotter, 'nx': nx, 'ny': ny}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _rotationmeasure_result = self._swigobj.rotationmeasure(_str_ec(_pc.document['rm']), _str_ec(_pc.document['rmerr']), _str_ec(_pc.document['pa0']), _str_ec(_pc.document['pa0err']), _str_ec(_pc.document['nturns']), _str_ec(_pc.document['chisq']), _pc.document['sigma'], _pc.document['rmfg'], _pc.document['rmmax'], _pc.document['maxpaerr'], _str_ec(_pc.document['plotter']), _pc.document['nx'], _pc.document['ny'])
        return _rotationmeasure_result

    def sigma(self, clip=float(10.0)):
        """This function returns the standard deviation from V, Q&U or I in that
        order of precedence.  It is attempting to give you the best estimate of
        the thermal noise it can from the data.  Outliers from the mean are
        clipped at the specified level.
        """
        schema = {'clip': {'type': 'cFloat', 'coerce': _coerce.to_float}}
        doc = {'clip': clip}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _sigma_result = self._swigobj.sigma(_pc.document['clip'])
        return _sigma_result

    def sigmadepolratio(self, infile, debias=False, clip=float(10.0), sigma=float(-1), outfile=''):
        """This function  returns the error
        in the linear depolarization ratio computed from two frequencies; this
        is the ratio of the fractional linear polarization at the two
        frequencies.  Generally this is done when you have generated two
        images, each at a different frequency (continuum work). Thus if the
        fractional linear polarzation images are $m1$ and $m2$ then the
        depolarization ratio is $m1/m2$.
        
        This function operates with two images; the first is attached
        to the Imagepol tool.  The second is supplied via the
        argument {stfaf infile}, which is  a String
        holding the name of the imagefile.
        
        In generating the depolarization ratio, and hence its error, you may
        optionally debias the  linearly polarized intensity.  This requires the
        standard deviation of the thermal noise.  You can either supply it if
        you know it, or it will be worked out for you with outliers from the
        mean clipped at the specified level.
        
        You can get the depolarization ratio image with function
        depolratio.
        """
        schema = {'infile': {'type': 'cReqPath', 'coerce': _coerce.expand_path}, 'debias': {'type': 'cBool'}, 'clip': {'type': 'cFloat', 'coerce': _coerce.to_float}, 'sigma': {'type': 'cFloat', 'coerce': _coerce.to_float}, 'outfile': {'type': 'cStr'}}
        doc = {'infile': infile, 'debias': debias, 'clip': clip, 'sigma': sigma, 'outfile': outfile}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _sigmadepolratio_result = _wrap_image(swig_object=self._swigobj.sigmadepolratio(_str_ec(_pc.document['infile']), _pc.document['debias'], _pc.document['clip'], _pc.document['sigma'], _str_ec(_pc.document['outfile'])))
        return _sigmadepolratio_result

    def sigmafraclinpol(self, clip=float(10.0), sigma=float(-1), outfile=''):
        """This function  returns the
        error (standard deviation) of the fractional linear polarization.
        This result comes from standard propagation of errors.  The result is
        an on-the-fly Image tool as the error is signal-to-noise ratio
        dependent.
        
        This function requires the standard deviation of the thermal noise.  You
        can either supply it if you know it, or it will be worked out for you
        with outliers from the mean clipped at the specified level.
        """
        schema = {'clip': {'type': 'cFloat', 'coerce': _coerce.to_float}, 'sigma': {'type': 'cFloat', 'coerce': _coerce.to_float}, 'outfile': {'type': 'cStr'}}
        doc = {'clip': clip, 'sigma': sigma, 'outfile': outfile}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _sigmafraclinpol_result = _wrap_image(swig_object=self._swigobj.sigmafraclinpol(_pc.document['clip'], _pc.document['sigma'], _str_ec(_pc.document['outfile'])))
        return _sigmafraclinpol_result

    def sigmafractotpol(self, clip=float(10.0), sigma=float(-1), outfile=''):
        """This function  returns the
        error (standard deviation) of the fractional total polarization.  This
        result comes from standard propagation of errors.  The result is an
        on-the-fly Image tool as the error is signal-to-noise ratio dependent.
        
        This function requires the standard deviation of the thermal noise.  You
        can either supply it if you know it, or it will be worked out for you
        with outliers from the mean clipped at the specified level.
        """
        schema = {'clip': {'type': 'cFloat', 'coerce': _coerce.to_float}, 'sigma': {'type': 'cFloat', 'coerce': _coerce.to_float}, 'outfile': {'type': 'cStr'}}
        doc = {'clip': clip, 'sigma': sigma, 'outfile': outfile}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _sigmafractotpol_result = _wrap_image(swig_object=self._swigobj.sigmafractotpol(_pc.document['clip'], _pc.document['sigma'], _str_ec(_pc.document['outfile'])))
        return _sigmafractotpol_result

    def sigmalinpolint(self, clip=float(10.0), sigma=float(-1), outfile=''):
        """This function  returns the error (standard
        deviation) of the linearly polarized intensity; $sqrt{(Q^2+U^2)}$.
        This result comes from standard propagation of statistical errors.
        The result is a float as the error is not signal-to-noise
        ratio dependent
        
        This function requires the standard deviation of the thermal noise.  You
        can either supply it if you know it, or it will be worked out for you
        with outliers from the mean clipped at the specified level.
        """
        schema = {'clip': {'type': 'cFloat', 'coerce': _coerce.to_float}, 'sigma': {'type': 'cFloat', 'coerce': _coerce.to_float}, 'outfile': {'type': 'cStr'}}
        doc = {'clip': clip, 'sigma': sigma, 'outfile': outfile}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _sigmalinpolint_result = self._swigobj.sigmalinpolint(_pc.document['clip'], _pc.document['sigma'], _str_ec(_pc.document['outfile']))
        return _sigmalinpolint_result

    def sigmalinpolposang(self, clip=float(10.0), sigma=float(-1), outfile=''):
        """This function  returns the
        error (standard deviation) of the linearly polarized position angle
        ($0.5 tan^{-1}(U/Q)$$sqrt{(Q^2+U^2)}$) in degrees.  This result
        comes from standard propagation of errors.  The result is an
        on-the-fly Image tool as the error is signal-to-noise ratio dependent.
        
        This function requires the standard deviation of the thermal noise.  You
        can either supply it if you know it, or it will be worked out for you
        with outliers from the mean clipped at the specified level.
        """
        schema = {'clip': {'type': 'cFloat', 'coerce': _coerce.to_float}, 'sigma': {'type': 'cFloat', 'coerce': _coerce.to_float}, 'outfile': {'type': 'cStr'}}
        doc = {'clip': clip, 'sigma': sigma, 'outfile': outfile}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _sigmalinpolposang_result = _wrap_image(swig_object=self._swigobj.sigmalinpolposang(_pc.document['clip'], _pc.document['sigma'], _str_ec(_pc.document['outfile'])))
        return _sigmalinpolposang_result

    def sigmastokes(self, which, clip=float(10.0)):
        """This function  returns the standard
        deviation of the noise for the specified Stokes.  Outliers from the mean
        are clipped at the specified level.
        """
        schema = {'which': {'type': 'cStr'}, 'clip': {'type': 'cFloat', 'coerce': _coerce.to_float}}
        doc = {'which': which, 'clip': clip}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _sigmastokes_result = self._swigobj.sigmastokes(_str_ec(_pc.document['which']), _pc.document['clip'])
        return _sigmastokes_result

    def sigmastokesi(self, clip=float(10.0)):
        """This function  returns the standard deviation of the noise for the
        Stokes I data.  Outliers from the mean are clipped at the specified
        level.
        """
        schema = {'clip': {'type': 'cFloat', 'coerce': _coerce.to_float}}
        doc = {'clip': clip}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _sigmastokesi_result = self._swigobj.sigmastokesi(_pc.document['clip'])
        return _sigmastokesi_result

    def sigmastokesq(self, clip=float(10.0)):
        """This function  returns the standard deviation of the noise for the
        Stokes Q data.  Outliers from the mean are clipped at the specified
        level.
        """
        schema = {'clip': {'type': 'cFloat', 'coerce': _coerce.to_float}}
        doc = {'clip': clip}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _sigmastokesq_result = self._swigobj.sigmastokesq(_pc.document['clip'])
        return _sigmastokesq_result

    def sigmastokesu(self, clip=float(10.0)):
        """This function  returns the standard
        deviation of the noise for the Stokes U data.  Outliers from the mean
        are clipped at the specified level.
        """
        schema = {'clip': {'type': 'cFloat', 'coerce': _coerce.to_float}}
        doc = {'clip': clip}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _sigmastokesu_result = self._swigobj.sigmastokesu(_pc.document['clip'])
        return _sigmastokesu_result

    def sigmastokesv(self, clip=float(10.0)):
        """This function  returns the standard
        deviation of the noise for the Stokes V data.  Outliers from the mean
        are clipped at the specified level.
        """
        schema = {'clip': {'type': 'cFloat', 'coerce': _coerce.to_float}}
        doc = {'clip': clip}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _sigmastokesv_result = self._swigobj.sigmastokesv(_pc.document['clip'])
        return _sigmastokesv_result

    def sigmatotpolint(self, clip=float(10.0), sigma=float(-1)):
        """This function  returns the error (standard
        deviation) of the total polarized intensity; $sqrt{(Q^2+U^2+V^2)}$.
        This result comes from standard propagation of statistical errors.
        The result is a float as the error is not signal-to-noise
        ratio dependent
        
        This function requires the standard deviation of the thermal noise.  You
        can either supply it if you know it, or it will be worked out for you
        with outliers from the mean clipped at the specified level.
        """
        schema = {'clip': {'type': 'cFloat', 'coerce': _coerce.to_float}, 'sigma': {'type': 'cFloat', 'coerce': _coerce.to_float}}
        doc = {'clip': clip, 'sigma': sigma}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _sigmatotpolint_result = self._swigobj.sigmatotpolint(_pc.document['clip'], _pc.document['sigma'])
        return _sigmatotpolint_result

    def stokes(self, which, outfile=''):
        """This function returns an on-the-fly image tool containing the
        specified Stokes only.  This interface can be useful for scripts.
        """
        schema = {'which': {'type': 'cStr'}, 'outfile': {'type': 'cStr'}}
        doc = {'which': which, 'outfile': outfile}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _stokes_result = _wrap_image(swig_object=self._swigobj.stokes(_str_ec(_pc.document['which']), _str_ec(_pc.document['outfile'])))
        return _stokes_result

    def stokesi(self, outfile=''):
        """This function returns an on-the-fly image tool containing Stokes I only.
        """
        schema = {'outfile': {'type': 'cStr'}}
        doc = {'outfile': outfile}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _stokesi_result = _wrap_image(swig_object=self._swigobj.stokesi(_str_ec(_pc.document['outfile'])))
        return _stokesi_result

    def stokesq(self, outfile=''):
        """This function returns an on-the-fly image tool containing Stokes Q only.
        """
        schema = {'outfile': {'type': 'cStr'}}
        doc = {'outfile': outfile}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _stokesq_result = _wrap_image(swig_object=self._swigobj.stokesq(_str_ec(_pc.document['outfile'])))
        return _stokesq_result

    def stokesu(self, outfile=''):
        """This function returns an on-the-fly image tool containing Stokes U only.
        """
        schema = {'outfile': {'type': 'cStr'}}
        doc = {'outfile': outfile}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _stokesu_result = _wrap_image(swig_object=self._swigobj.stokesu(_str_ec(_pc.document['outfile'])))
        return _stokesu_result

    def stokesv(self, outfile=''):
        """This function returns an on-the-fly image tool containing Stokes V only.
        """
        schema = {'outfile': {'type': 'cStr'}}
        doc = {'outfile': outfile}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _stokesv_result = _wrap_image(swig_object=self._swigobj.stokesv(_str_ec(_pc.document['outfile'])))
        return _stokesv_result

    def summary(self):
        """This function just lists a summary of the Imagepol tool to the logger.
        Currently it just summarizes the image to which the tool is attached.
        """
        _summary_result = self._swigobj.summary()
        return _summary_result

    def totpolint(self, debias=False, clip=float(10.0), sigma=float(-1), outfile='', region='', mask='', stretch=False):
        """This application returns the total polarized intensity;
        
        $sqrt{( Q^2+ U^2+ V^2)}$.
        
        If the image contains only Q and U, or only V, then just
        those components contribute to the total polarized intensity.
        
        The polarized intensity may optionally be debiased (if debias=True).
        This requires an estimate of the thermal noise level (sigma).
        The resulting image will be computed using
        
        $sqrt{(Q^2 + U^2 + V^2 - sigma^2)}$
        
        If the specified value of sigma is positive, that is the value that will
        be used for debiasing. If it is not, the value used for sigma is computed
        using the following algorithm:
        
        1. First, a stokes plane(s) is chosen on which the sigma computation is performed.
        If the V plane exists, that is used to compute sigma. If not, then the value of
        sigma is computed to be the average of the sigma values of the Q and U planes.
        
        2. For the relevant plane(s), the sigma value is computed for unmasked pixel values
        which lie within +/- (clip * stddev) values of the mean for that plane, where the mean
        and stddev (the standard deviation) are computed by using all unmasked pixel values
        in the relevant plane. In this way, outliers (eg pixels due to possible
        astronomical signals) are excluded in the computation of sigma.
        
        In the output image, pixels for which the expression inside the square root is
        negative are masked, and their values are set to zero.
        
        If a region and/or mask is specified, debias=True and sigma is not positive so
        that the value of sigma is determined using the algorithm above, the region and mask
        are applied first to the plane(s) from which the value of sigma is determined and
        then sigma is computed.
        """
        schema = {'debias': {'type': 'cBool'}, 'clip': {'type': 'cFloat', 'coerce': _coerce.to_float}, 'sigma': {'type': 'cFloat', 'coerce': _coerce.to_float}, 'outfile': {'type': 'cStr'}, 'region': {'anyof': [{'type': 'cStr'}, {'type': 'cDict'}]}, 'mask': {'type': 'cStr'}, 'stretch': {'type': 'cBool'}}
        doc = {'debias': debias, 'clip': clip, 'sigma': sigma, 'outfile': outfile, 'region': region, 'mask': mask, 'stretch': stretch}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _totpolint_result = _wrap_image(swig_object=self._swigobj.totpolint(_pc.document['debias'], _pc.document['clip'], _pc.document['sigma'], _str_ec(_pc.document['outfile']), _any_ec(_pc.document['region']), _str_ec(_pc.document['mask']), _pc.document['stretch']))
        return _totpolint_result

