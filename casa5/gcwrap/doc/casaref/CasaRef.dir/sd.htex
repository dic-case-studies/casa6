
\newpage
\ahtool{sd}{Single-dish data analysis package}
Requires:
Synopsis

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

  The sd tool provides data reduction functions for single-dish 
  (auto-correlation) data. It is actually a standalone 
  software that is called ASAP (ATNF Spectral Analysis Package). 
  For more information about ASAP, 
  visit \htmladdnormallink{here}{http://svn.atnf.csiro.au/trac/asap}.

  The sd tool is a top level object and it contains various 
  sub tools as well as a number of functions.

  \medskip\noindent\textbf{Important note}

   In the latest release, single dish package is loaded at the start-up 
   of CASA. Therefore, it is not necessary to load ASAP explicitly anymore.

%    {\bf To access sd tool from \casa, the user must execute asap\_init()} 
%    from the command-line interface of \casa. 
%    This command imports ASAP package as sd tool and makes single-dish 
%    tasks available.
%
%    As described above, the sd tool is originally a standalone software package, 
%    and it is actually an independent Python module named 'asap'. 
%    Thus, you can import sd tool without executing asap\_init().
%    It can be imported as usual Python module such as 
%
%    \begin{verbatim}
%    import asap as sd
%    \end{verbatim}
%
%    from command line interface of \casa.

  \medskip\noindent\textbf{Data format}

    There are various types of data format for single-dish data.
    Currently, sd tool supports the following data formats for 
    reading and writing.

\begin{itemize}
\item reading: Scantable, Measurement Set, SDFITS (GBT, ATNF), NRO
\item writing: Scantable, Measurement Set, SDFITS (ATNF), image FITS, CLASS, ASCII
\end{itemize}

    An internal data format for sd tool is Scantable.
    The Scantable is defined as \casa\ table and is specially 
    designed for single-dish data. The data is converted to Scantable  
    during the processing whatever its original data format is.
    The result of the processing can be stored in other data format 
    than Scantable. 
    The Scantable is implemented as \ahlink{sd.scantable}{sd:sd.scantable}
    object in sd tool. 
    See \ahlink{sd.scantable}{sd:sd.scantable} for details. 

  \medskip\noindent\textbf{Selecting data}

    The Scantable can contain data with various types of frequency setting, 
    multiple polarization components, and so on. In case you want 
    to select data by some conditions, \ahlink{sd.selector}{sd:sd.selector} 
    is available for that. The \ahlink{sd.selector}{sd:sd.selector} provides 
    various functions to select and/or to sort data as well as it provides 
    an interface to select data by  
    \htmladdnormallink{TaQL}{http://aips2.nrao.edu/docs/notes/199/199.html}.
    See \ahlink{sd.selector}{sd:sd.selector} for details.

  \medskip\noindent\textbf{Fitting}

    The \ahlink{sd.fitter}{sd:sd.fitter} is an object to perform fitting data. 
    Both baseline and line fitting for spectral data can be done by this 
    object if appropriate fitting function and masked region are set.
    Currently, Gaussian and Lorentzian are supported for line fitting, 
    while polynomials with arbitrary order are available for baseline 
    fitting. Masking should be applied in the form of Bool array.
    See \ahlink{sd.fitter}{sd:sd.fitter} for details.  

  \medskip\noindent\textbf{Line finding}

    The sd tool provides automatic line finding functionality that is 
    called \ahlink{sd.linefinder}{sd:sd.linefinder}. 
    The \ahlink{sd.linefinder}{sd:sd.linefinder} has a few control parameter 
    for line finding. The user is able to customize a behavior of line finding 
    process by changing these parameters. 
    Simplified line finding tool \ahlink{sd.simplelinefinder}{sd:sd.simplelinefinder} 
    is also available.  
    See \ahlink{sd.linefinder}{sd:sd.linefinder} and 
    \ahlink{sd.simplelinefinder}{sd:sd.simplelinefinder} for details.

  \medskip\noindent\textbf{Line catalog}

    The \ahlink{sd.linecatalog}{sd:sd.linecatalog} object is an interface for 
    line catalog. The input data should be provided from the user.
    Supported format is ASCII table or specific format for 
    \ahlink{sd.linecatalog}{sd:sd.linecatalog}.
    \casa\ package contains a default line catalog that is a part of 
    JPL line catalog and is specific table format for the sd tool (ASAP). 
    Benefit of this object is that it provides an interface to the 
    catalog such as selecting lines by frequency and/or line intensity.
    It also enables an interaction between 
    spectral data on the \ahlink{sd.plotter}{sd:sd.plotter} such as 
    overlaying line catalog on the plotted spectra.
    See \ahlink{sd.linecatalog}{sd:sd.linecatalog} for details.

  \medskip\noindent\textbf{Plotter}

    The \ahlink{sd.plotter}{sd:sd.plotter} is a plotter object that is 
    exclusively designed for sd tool. That provides plotting functionalities 
    for spectral data, time variation of azimuth and elevation, and 
    pointing information. For plotting spectral data, it supports 
    multi-panel and multi-page plot.
    See \ahlink{sd.plotter}{sd:sd.plotter} for details.   

  \medskip\noindent\textbf{Coordinate system}

    The \ahlink{sd.coordinate}{sd:sd.coordinate} is a representation of 
    spectral coordinate of the data (frequency axis). It provides functions 
    for conversion between pixel (channel), frequency, and velocity.
    See \ahlink{sd.coordinate}{sd:sd.coordinate} for details. 
		
  \medskip\noindent\textbf{Opacity model}

    In the sd tool, MIRIAD like atmospheric opacity model is implemented 
    as \ahlink{sd.opacity\_model}{sd:sd.opacity_model}. It calculates opacities from 
    given atmospheric conditions (temperature, pressure, and humidity) 
    and elevation.
    See \ahlink{sd.opacity\_model}{sd:sd.opacity_model} for details.
		
  \medskip\noindent\textbf{Gridding}

    The tool to convolve spectral data onto regularly spaced grid, 
    \ahlink{sd.asapgrid}{sd:sd.asapgrid} is available. Currently, 
    three convolution kernels, box, prolate-spheroidal, and gaussian, 
    can be used for convolution. See \ahlink{sd.asapgrid}{sd:sd.asapgrid} 
    for details.

  \medskip\noindent\textbf{Logging}

    Although logging system is integrated into \casa\ logger, sd tool has 
    own logging functions so that you can use it instead of \casa\ logging 
    functions. Log messages will be displayed in the \casa\ logger either 
    you use logging functions for \casa\ or sd tool. 
    See \ahlink{sd.asaplog}{sd:sd.asaplog} for details.
 

Methods
\begin{longtable}{ll}

	\ahlink{almacal}{sd:sd.almacal} &Calibration function specific for ALMA data \\

	\ahlink{apexcal}{sd:sd.apexcal} &Calibration function specific for APEX data \\

	\ahlink{average\_time}{sd:sd.average_time} &Averaging data in time \\

	\ahlink{calfs}{sd:sd.calfs} &Calibration function for frequency switched data \\

	\ahlink{calibrate}{sd:sd.calibrate} &High level function for calibration \\

	\ahlink{calnod}{sd:sd.calnod} &Calibration function for nodding data \\

	\ahlink{calps}{sd:sd.calps} &Calibration function for position switched data \\

	\ahlink{commands}{sd:sd.commands} &Show a list of commands and their short descriptions \\

	\ahlink{dosigref}{sd:sd.dosigref} &Equivalent function with dosigref in \htmladdnormallink{GBTIDL}{http://gbtidl.nrao.edu/} \\

	\ahlink{dototalpower}{sd:sd.dototalpower} &Equivalent function with dototalpower in \htmladdnormallink{GBTIDL}{http://gbtidl.nrao.edu/} \\

	\ahlink{fitter}{sd:sd.fitter} &Create a fitter object \\

	\ahlink{get\_revision}{sd:sd.get_revision} &Get revision of the source code for the tool \\

	\ahlink{is\_asap\_cli}{sd:sd.is_asap_cli} & Return True if the tool is launched as standalone software \\

	\ahlink{is\_casapy}{sd:sd.is_casapy} & Return True if the tool is loaded as part of \casa \\

	\ahlink{linecatalog}{sd:sd.linecatalog} &Create a linecatalog object \\

	\ahlink{linefinder}{sd:sd.linefinder} &Create a linefinder object \\

	\ahlink{list\_files}{sd:sd.list_files} &Return a list of files readable by sd tool \\

	\ahlink{list\_rcparameters}{sd:sd.list_rcparameters} &Print a list of rc parameters \\

	\ahlink{list\_scans}{sd:sd.list_scans} &Return a list of scantables created by the user \\

	\ahlink{mask\_and}{sd:sd.mask_and} &Logical operation function on array\\

	\ahlink{mask\_or}{sd:sd.mask_or} &Logical operation function on array \\

	\ahlink{mask\_not}{sd:sd.mask_not} &Logical operation function on array\\

	\ahlink{merge}{sd:sd.merge} &Merge a list of scantables into one \\

	\ahlink{opacity\_model}{sd:sd.opacity_model} &Create a opacity\_model object \\

	\ahlink{quotient}{sd:sd.quotient} &Take a quotient of a signal and reference scan \\

        \ahlink{rc}{sd:sd.rc} &Set the current rc parameters \\

	\ahlink{scantable}{sd:sd.scantable} &Create scantable object \\

	\ahlink{selector}{sd:sd.selector} &Create selector object \\

	\ahlink{skydip}{sd:sd.skydip} &Determine the opacity from a set of 'skydip' observations \\

	\ahlink{splitant}{sd:sd.splitant} &Split Measurement Set data by antenna and save them as scantable \\

	\ahlink{unique}{sd:sd.unique} &Return the unique values in a list \\

	\ahlink{welcome}{sd:sd.welcome} &Return a welcome message \\

\end{longtable}



%% sd.almacal
\newpage
\ahfunction{sd.almacal}{Calibration function specific for ALMA data}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\
  
  This method is properly defined for calibration of ALMA data.
  Input data must be a scantable object. The calibration scheme is, 

  \begin{displaymath}
  T_{\rm a}^* = T_{\rm sys} { {ON - OFF} \over OFF },
  \end{displaymath}

  where $T_{\rm a}^*$ is an antenna temperature, $T_{\rm sys}$ is a 
  system temperature, $ON$ and $OFF$ are raw (uncalibrated) spectral 
  data that correspond to on-source and off-source position, 
  respectively. The $OFF$ scan is linearly interpolated in time if it exists 
  in the vicinity of target $ON$ scan.
  The calmode argument specifies calibration mode. Supported calibration 
  modes are 'ps' (position switch) and 'fs' (frequency switch). 
  The 'ps' includes calibration for nutator switching 
  as well as classical position switching.
  The 'ps' mode also supports calibration of OTF position raster scanned 
  data that consists of on-source scans with simple scan pattern and 
  explicit off-source scans. 

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
scantab&& \multicolumn{2}{p{3.36in}|}{input data as a scantable}\\
& &allowed: & scantable\\
& &Default: & 
\\
scannos&& \multicolumn{2}{p{3.36in}|}{a list of scan numbers to be calibrated}\\
& &allowed: & (list of) integer, string \\
& &Default: & [] (all data)
\\
calmode&& \multicolumn{2}{p{3.36in}|}{Calibration mode}\\
& &allowed: & string ('ps', 'fs', 'none')\\
& &Default: & 'none'
\\
verify&& \multicolumn{2}{p{3.36in}|}{Verify calibration if True}\\
& &allowed: & bool \\
& &Default: & False
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline
scantable

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\

\begin{verbatim}
    s=sd.scantable('alma-scans.asap',average=False,getpt=True)
    scal=sd.almacal(s,calmode='ps')
\end{verbatim}


%% sd.apexcal
\newpage
\ahfunction{sd.apexcal}{Calibration function specific for APEX data}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

  This method is properly defined for calibration of APEX data.
  Input data must be a scantable object. The calibration scheme is 
  essentially same as ALMA data, 

  \begin{displaymath}
  T_{\rm a}^* = T_{\rm sys} { {ON - OFF} \over OFF },
  \end{displaymath}

  where $T_{\rm a}^*$ is an antenna temperature, $T_{\rm sys}$ is a 
  system temperature, $ON$ and $OFF$ are raw (uncalibrated) spectral 
  data that correspond to on-source and off-source position, 
  respectively. Only difference with ALMA calibration is that 
  $T_{\rm sys}$ doesn't provided. Instead, it is computed from 
  a calibration temperature and two calibration scans: a blank sky 
  and a load with known temperature.
  The $OFF$ scan is linearly interpolated in time if it exists 
  in the vicinity of target $ON$ scan.
  The calmode argument specifies calibration mode. Supported calibration 
  modes are 'ps' (position switch) and 'fs' (frequency switch). 
  The 'ps' includes calibration for nutator switching 
  as well as classical position switching.
  
\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
scantab&& \multicolumn{2}{p{3.36in}|}{input data as a scantable}\\
& &allowed: & scantable\\
& &Default: & 
\\
scannos&& \multicolumn{2}{p{3.36in}|}{a list of scan numbers to be calibrated}\\
& &allowed: & (list of) integer, string \\
& &Default: & [] (all data)
\\
calmode&& \multicolumn{2}{p{3.36in}|}{Calibration mode}\\
& &allowed: & string ('ps', 'fs', 'none')\\
& &Default: & 'none'
\\
verify&& \multicolumn{2}{p{3.36in}|}{Verify calibration if True}\\
& &allowed: & bool \\
& &Default: & False
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline
scantable

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\

\begin{verbatim}
    s=sd.scantable('alma-scans.asap',average=False,getpt=True)
    scal=sd.apexcal(s,calmode='ps')
\end{verbatim}


%% sd.average_time
\newpage
\ahsdfunction{sd.average\_time}{sd.average_time}{Averaging data in Time}

\flushleft\vspace{.20in}\textbf {Description}\\
  \hfill \\
  The function computes a weighted time average of a scantable or a 
  list of scantables. The averaging is done in channel only. 
  Supported weighting schemes are as follows:

  \begin{itemize}
  \item none --- no weighting
  \item var --- 1/var(spectrum) weighted
  \item tsys --- 1/Tsys**2 weighted
  \item tint --- integration time weighted
  \item tintsys --- Tint/Tsys**2 weighted
  \item median --- median averaging
  \end{itemize}

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
  && \multicolumn{2}{p{3.36in}|}{Input data as a scantable}\\
& &allowed: & scantable or a list of scantables\\
& &Default: & 
\\
mask && \multicolumn{2}{p{3.36in}|}{An optional mask (only used for 'var' and 'tsys' weighting)}\\
& &allowed: & bool list\\
& &Default: & none
\\
scanav && \multicolumn{2}{p{3.36in}|}{True averages each scan separately, False averages all scans together}\\
& &allowed: & bool\\
& &Default: & False
\\
weight && \multicolumn{2}{p{3.36in}|}{Weighting scheme (see description)}\\
& &allowed: & string\\
& &Default: & 'tint'
\\
align && \multicolumn{2}{p{3.36in}|}{Align the spectra in velocity before averaging. It takes the time of the first spectrum in the first scantable as reference time.}\\
& &allowed: & bool\\
& &Default: & False
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline
scantable

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\

\begin{verbatim}
        scana = sd.scantable('scana.asap')
        scanb = sd.scantable('scanb.asap')
        # return a time averaged scan from scana and scanb
        # without using a mask
        scanav = sd.average_time(scana,scanb)
        # or equivalent
        scanav = sd.average_time([scana, scanb])
        # return the (time) averaged scan, i.e. the average of
        # all correlator cycles
        scanav = sd.average_time(scan, scanav=True)
\end{verbatim}


%% sd.calfs
\newpage
\ahfunction{sd.calfs}{Calibration function for frequency switched data}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\
    Calibrate GBT frequency switched data.
    Adopted from GBTIDL getfs.
    Currently calfs identify the scans as frequency switched data if source
    type enum is fson and fsoff. The data must contains 'CAL' signal
    on/off in each integration. To identify 'CAL' on state, the source type 
    enum of foncal and foffcal need to be present.

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
scantab&& \multicolumn{2}{p{3.36in}|}{Input data as a scantable}\\
& &allowed: & scantable\\
& &Default: & 
\\
scannos&& \multicolumn{2}{p{3.36in}|}{A list of scan numbers to be calibrated}\\
& &allowed: & (list of) integer \\
& &Default: & [] (all data)
\\
smooth&& \multicolumn{2}{p{3.36in}|}{Optional box smoothing order for the reference}\\
& &allowed: & int\\
& &Default: & 1 (no smoothing)
\\
tsysval&& \multicolumn{2}{p{3.36in}|}{Optional user specified Tsys}\\
& &allowed: & float \\
& &Default: & 0.0 (use Tsys in the data)
\\
tauval&& \multicolumn{2}{p{3.36in}|}{Optional user specified optical depth}\\
& &allowed: & float \\
& &Default: & 0.0
\\
verify&& \multicolumn{2}{p{3.36in}|}{Verify calibration if True}\\
& &allowed: & bool \\
& &Default: & False
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline
scantable 

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\

\begin{verbatim}
   s=sd.scantable('FLS3a_HI.asap')                 # load in the saved ASAP dataset with FLS3a
   scanns = s.getscannos()                         # get a list of the scan numbers in the scantable
   sn=list(scanns)
   res=sd.calfs(s,sn)                              # Do a frequency switched calibration on the scans
\end{verbatim}


%% sd.calibrate
\newpage
\ahfunction{sd.calibrate}{High level function for calibration that calls appropriate calibration function depending on the data}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\
   This method is a high level function for calibration. It calls appropriate 
   calibration function depending on the origin of the data. It checks an 
   calmode argument first, and then looks antenna name in the data. 
   Calibration functions that can be called from the method are:

   \begin{itemize}
   \item \ahlink{calnod}{sd:sd.calnod} if calmode is 'nod'
   \item \ahlink{auto\_quotient}{sd:sd.scantable.auto_quotient} if calmode is 'quotient'
   \item \ahlink{calps}{sd:sd.calps} if calmode is 'ps' and antenna name is 'GBT' 
   \item \ahlink{calfs}{sd:sd.calfs} if calmode is 'fs' and antenna name is 'GBT'
   \item \ahlink{apexcal}{sd:sd.apexcal} if calmode is 'ps' or 'fs' and antenna name contains 'APEX'
   \item \ahlink{almacal}{sd:sd.almacal} if calmode is 'ps', 'fs', or 'otf' and antenna name contains 'ALMA' or 'OSF'
   \end{itemize}

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
scantab&& \multicolumn{2}{p{3.36in}|}{input data as a scantable}\\
& &allowed: & scantable\\
& &Default: & 
\\
scannos&& \multicolumn{2}{p{3.36in}|}{a list of scan numbers to be calibrated}\\
& &allowed: & (list of) integer, string \\
& &Default: & [] (all data)
\\
calmode&& \multicolumn{2}{p{3.36in}|}{Calibration mode}\\
& &allowed: & string ('ps', 'fs', 'none')\\
& &Default: & 'none'
\\
verify&& \multicolumn{2}{p{3.36in}|}{Verify calibration if True}\\
& &allowed: & bool \\
& &Default: & False
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline
scantable

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\

\begin{verbatim}
    s=sd.scantable('alma-scans.asap',average=False,getpt=True)
    scal=sd.calibrate(s,calmode='ps')
\end{verbatim}


%% sd.calnod
\newpage
\ahfunction{sd.calnod}{Calibration function for nodding data}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\
    This method performs full (but a pair of scans at time) processing of 
    GBT Nod data calibration.
    Adopted from  GBTIDL's getnod

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
scantab&& \multicolumn{2}{p{3.36in}|}{Input data as a scantable}\\
& &allowed: & scantable\\
& &Default: & 
\\
scannos&& \multicolumn{2}{p{3.36in}|}{A pair of scan numbers, or the first scan number of the pair}\\
& &allowed: & (list of) integer \\
& &Default: & [] (all data)
\\
smooth&& \multicolumn{2}{p{3.36in}|}{Box car smoothing order}\\
& &allowed: & int\\
& &Default: & 1 (no smoothing)
\\
tsysval&& \multicolumn{2}{p{3.36in}|}{Optional user specified Tsys}\\
& &allowed: & float \\
& &Default: & 0.0 (use Tsys in the data)
\\
tauval&& \multicolumn{2}{p{3.36in}|}{Optional user specified optical depth (not implemented yet)}\\
& &allowed: & float \\
& &Default: & 0.0
\\
tcalval&& \multicolumn{2}{p{3.36in}|}{Optional user specified Tcal}\\
& &allowed: & float \\
& &Default: & 0.0
\\
verify&& \multicolumn{2}{p{3.36in}|}{Verify calibration if True}\\
& &allowed: & bool \\
& &Default: & False
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline
scantable

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\

\begin{verbatim}
   s=sd.scantable('IRC+10216_rawACSmod',False)#load the data without averaging     
   scal=sd.calnod(s,[229,230])             # Calibrate CS scans 
\end{verbatim}


%% sd.calps
\newpage
\ahfunction{sd.calps}{Calibration function for position switched data}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\
    The method calibrates GBT position switched data
    Adopted from GBTIDL getps
    Currently calps identify the scans as position switched data if source
    type enum is pson or psoff. The data must contains 'CAL' signal
    on/off in each integration. To identify 'CAL' on state, the source type 
    enum of poncal and poffcal need to be present.


\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
scantab&& \multicolumn{2}{p{3.36in}|}{Input data as a scantable}\\
& &allowed: & scantable\\
& &Default: & 
\\
scannos&& \multicolumn{2}{p{3.36in}|}{A list of scan numbers to be calibrated}\\
& &allowed: & (list of) integer \\
& &Default: & [] (all data)
\\
smooth&& \multicolumn{2}{p{3.36in}|}{Optional box smoothing order for the reference}\\
& &allowed: & int\\
& &Default: & 1 (no smoothing)
\\
tsysval&& \multicolumn{2}{p{3.36in}|}{Optional user specified Tsys}\\
& &allowed: & float \\
& &Default: & 0.0 (use Tsys in the data)
\\
tauval&& \multicolumn{2}{p{3.36in}|}{Optional user specified optical depth}\\
& &allowed: & float \\
& &Default: & 0.0
\\
tcalval&& \multicolumn{2}{p{3.36in}|}{Optional user specified Tcal}\\
& &allowed: & float \\
& &Default: & 0.0 (use Tcal in the data)
\\
verify&& \multicolumn{2}{p{3.36in}|}{Verify calibration if True}\\
& &allowed: & bool \\
& &Default: & False
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline
scantable

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\

\begin{verbatim}
   s=sd.scantable('OrionS_rawACSmod',False)#load the data without averaging        
   scal=sd.calps(s,[24,25,26,27])          # Calibrate SiO scans  
\end{verbatim}


%% sd.commands
\newpage
\ahfunction{sd.commands}{Show a list of commands and their short descriptions}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\
   The method prints a list of commands and their short descriptions.
   The output is sorted by their intents and/or subtools that the commands 
   associate. 

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\flushleft\vspace{.20in}\textbf {Returns}\newline

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\

\begin{verbatim}
   sd.commands()
   # Output will be as follows
   [The scan container]
       scantable           - a container for integrations/scans
                             (can open asap/rpfits/sdfits and ms files)
           copy            - returns a copy of a scan
           get_scan        - gets a specific scan out of a scantable
                             (by name or number)
           drop_scan       - drops a specific scan out of a scantable
                             (by number)
           set_selection   - set a new subselection of the data
           get_selection   - get the current selection object
           summary         - print info about the scantable contents
           stats           - get specified statistic of the spectra in
                             the scantable
           stddev          - get the standard deviation of the spectra
                             in the scantable
           get_tsys        - get the TSys
           get_time        - get the timestamps of the integrations
           get_inttime     - get the integration time
           get_sourcename  - get the source names of the scans
           get_azimuth     - get the azimuth of the scans
           get_elevation   - get the elevation of the scans
           get_parangle    - get the parallactic angle of the scans
           get_coordinate  - get the spectral coordinate for the given row,
                             which can be used for coordinate conversions
           get_weather     - get the weather condition parameters
           get_unit        - get the current unit
           set_unit        - set the abcissa unit to be used from this
                             point on
           ...
\end{verbatim}



%% sd.dosigref
\newpage
\ahfunction{sd.dosigref}{Equivalent function with dosigref in GBTIDL}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\
    The method calculates a quotient (sig-ref/ref * Tsys).
    Adopted from GBTIDL dosigref.

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
sig&& \multicolumn{2}{p{3.36in}|}{On-source data as a scantable}\\
& &allowed: & scantable\\
& &Default: & 
\\
ref&& \multicolumn{2}{p{3.36in}|}{Reference data as a scantable}\\
& &allowed: & scantable \\
& &Default: & 
\\
smooth&& \multicolumn{2}{p{3.36in}|}{Width of box car smoothing for reference}\\
& &allowed: & int\\
& &Default: & 1 (no smoothing)
\\
tsysval&& \multicolumn{2}{p{3.36in}|}{User specified Tsys}\\
& &allowed: & float \\
& &Default: & 0.0 (use Tsys in the data)
\\
tauval&& \multicolumn{2}{p{3.36in}|}{User specified optical depth (required if tsysval is set)}\\
& &allowed: & float \\
& &Default: & 0.0
\\

\hline
\end{tabular}


\flushleft\vspace{.20in}\textbf {Returns}\newline
scantable

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\

\begin{verbatim}
   s = sd.scantable('OrionS_rawACSmod',average=False)
   sel = sd.selector()
   # calibration scans
   sel.set_types([srctype.poncal,srctype.poffcal])
   s.set_selection(sel)
   ssubon=s.copy()
   s.set_selection()
   sel.reset()
   # off-calibration scans
   sel.set_types([srctype.pson,srctype.psoff])
   s.set_selection(sel)
   ssuboff=s.copy()
   s.set_selection()
   sel.reset()
   # calibration
   cals = sd.dototalpower(ssubon,ssuboff)
   # ON scan
   sel.set_types(srctype.pson)
   cals.set_selection(sel)
   sig = cals.copy()
   cals.set_selection()
   sel.reset()
   # OFF scan
   sel.set_types(srctype.psoff)
   cals.set_selection(sel)
   ref = cals.copy()
   cals.set_selection()
   sel.reset()
   # get calibrated data
   ress = sd.dosigref(sig,ref,smooth=1)
\end{verbatim}


%% sd.dototalpower
\newpage
\ahfunction{sd.dototalpower}{Equivalent function with dototalpower in GBTIDL}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\
    The method performs calibration for CAL on,off signals.
    Adopted from GBTIDL dototalpower.

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
calon&& \multicolumn{2}{p{3.36in}|}{The 'cal on' subintegration as a scantable}\\
& &allowed: & scantable\\
& &Default: & 
\\
caloff&& \multicolumn{2}{p{3.36in}|}{The 'cal off' subintegration as a scantable}\\
& &allowed: & scantable \\
& &Default: & 
\\
tcalval&& \multicolumn{2}{p{3.36in}|}{User supplied Tsys}\\
& &allowed: & float \\
& &Default: & 0.0 (use Tcal in the data)
\\

\hline
\end{tabular}


\flushleft\vspace{.20in}\textbf {Returns}\newline
scantable

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\

\begin{verbatim}
   s = sd.scantable('OrionS_rawACSmod',average=False)
   sel = sd.selector()
   # calibration scans
   sel.set_types([srctype.poncal,srctype.poffcal])
   s.set_selection(sel)
   ssubon=s.copy()
   s.set_selection()
   sel.reset()
   # off-calibration scans
   sel.set_types([srctype.pson,srctype.psoff])
   s.set_selection(sel)
   ssuboff=s.copy()
   s.set_selection()
   sel.reset()
   # calibration
   cals = sd.dototalpower(ssubon,ssuboff)
   # ON scan
   sel.set_types(srctype.pson)
   cals.set_selection(sel)
   sig = cals.copy()
   cals.set_selection()
   sel.reset()
   # OFF scan
   sel.set_types(srctype.psoff)
   cals.set_selection(sel)
   ref = cals.copy()
   cals.set_selection()
   sel.reset()
   # get calibrated data
   ress = sd.dosigref(sig,ref,smooth=1)
\end{verbatim}



%% sd.get_revision
\newpage
\ahsdfunction{sd.get\_revision}{sd.get_revision}{Get revision of the source code for the tool}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\
   Get the revision of the software.
   Actually it returns a revision number of the source code that is managed 
   by subversion.

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\

\flushleft\vspace{.20in}\textbf {Returns}\newline
string

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\

\begin{verbatim}
   rev=sd.get_revision()
   print rev
   '13018'
\end{verbatim}


%% sd.is_asap_cli
\newpage
\ahsdfunction{sd.is\_asap\_cli}{sd.is_asap_cli}{Check if the tool is loaded as part of \casa\ or is launched as standalone software}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\
   The method checks if sd tool (ASAP) is running standalone.
   This always returns False if you use \casa.

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\

\flushleft\vspace{.20in}\textbf {Returns}\newline
bool (False)

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\

\begin{verbatim}
   isasap=sd.is_asap_cli()
   print isasap
   False
\end{verbatim}


%% sd.is_casapy
\newpage
\ahsdfunction{sd.is\_casapy}{sd.is_casapy}{Check if the tool is loaded as part of \casa\ or is launched as standalone software}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\
   The method checks if sd tool is running on \casa.
   This always returns True if you use \casa.

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\flushleft\vspace{.20in}\textbf {Returns}\newline
bool (True)

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\

\begin{verbatim}
   iscasa=sd.is_casapy()
   print iscasa
   True
\end{verbatim}


%% sd.list_files
\newpage
\ahsdfunction{sd.list\_files}{sd.list_files}{Return list of files readable by sd tool}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\
   Return a list files readable by asap, such as MS, rpf, sdfits, mbf, asap.
   The method looks a directory that is indicated by path argument, and 
   searches files with extension specified by suffix. Allowed extensions 
   are:

   \begin{itemize}
   \item rpf --- RPFITS (default)
   \item rpf.1 --- RPFITS
   \item rpf.2 --- RPFITS
   \item sdf --- SDFITS
   \item sdfits -- SDFITS
   \item mbf --- MBFITS
   \item asap --- Scantable
   \item ms --- Measurement Set
   \end{itemize}

   Note that the method just checks the extension of the file name. 
   Thus, the returned list doesn't contains files that don't have 
   the above extensions even if they are readable.

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
path&& \multicolumn{2}{p{3.36in}|}{The directory to list}\\
& &allowed: & string\\
& &Default: & './' (current directory)
\\
suffix&& \multicolumn{2}{p{3.36in}|}{The file extension}\\
& &allowed: & string \\
& &Default: & 'rpf'
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline
string array

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\

\begin{verbatim}
        files = sd.list_files("data/","sdfits")
        print files
        ['data/2001-09-01_0332_P363.sdfits',
        'data/2003-04-04_131152_t0002.sdfits',
        'data/Sgr_86p262_best_SPC.sdfits']
\end{verbatim}


%% sd.list_rcparameters
\newpage
\ahsdfunction{sd.list\_rcparameters}{sd.list_rcparameters}{Print a list of rc parameters}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\
   Print a list of rc parameters and its default values that determine 
   basic behavior of the tool.
   The user can be accessed rc parameters directory since the rc parameters 
   are available as a Python dictionary sd.rcParams. There is also a method 
   to set rc parameters called \ahlink{rc}{sd:sd.rc}.
   Contents of the rc paramters are described below.

   \begin{itemize}
   \item verbose \\ It will disable exceptions and just print the messages (only valid in standalone mode)
   \item useplotter \\ Preload a default plotter
   \item insitu \\ Apply operations on the input scantable or retuern new one
   \item plotter.gui \\ Do we want a GUI or plot to a file
   \item plotter.stacking \\ Default mode for color stacking
   \item plotter.panelling \\ Default mode for panelling
   \item plotter.ganged \\ Push panels together, to share axis labels
   \item plotter.decimate \\ Decimate the number of points plotted by a factor of nchan/1024
   \item plotter.colours \\ Default color
   \item plotter.linestyles \\ Default linestyles
   \item plotter.histogram \\ Enable/disable histogram plotting
   \item plotter.papertype \\ Postscript paper type
   \item plotter.axesformatting \\ The formatting style of the x-axis
   \item scantable.storage \\ Default storage of scantable ('memory'/'disk')
   \item scantable.history \\ Write history of each call to scantable
   \item scantable.save \\ Default output format when saving
   \item scantable.autoaverage \\ Auto averaging on read
   \item scantable.freqframe \\ Default frequency frame to set when function \ahlink{set\_freqframe}{sd:sd.scantable.set_freqframe} is called
   \item scantable.verbosesummary \\ Control the level of information printed by \ahlink{summary}{sd:sd.scantable.summary}
   \item scantable.reference \\ Control the identification of reference (off) scans (has to be regular expression)
   \item scantable.parallactify \\ Indicate whether the data was parallactified (total phase offset is 0.0)
   \end{itemize}


\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\flushleft\vspace{.20in}\textbf {Returns}\newline
string 

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\

\begin{verbatim}
   sd.list_rcparameters()
   # output will be as follows
   # general
   # only valid in asap standard mode not in scripts or casapy
   # It will disable exceptions and just print the messages
   verbose                    : True

   # preload a default plotter
   useplotter                 : True

   # apply operations on the input scantable or return new one
   insitu                     : True

   # plotting

   # do we want a GUI or plot to a file
   plotter.gui                : True

   # default mode for colour stacking
   plotter.stacking           : Pol

   # default mode for panelling
   plotter.panelling          : scan

   # push panels together, to share axis labels
   plotter.ganged             : True

   ...
\end{verbatim}


%% sd.list_scans
\newpage
\ahsdfunction{sd.list\_scans}{sd.list_scans}{Return a list of scantables created by the user}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\
   The method prints and returns a list of scantables that the user created.

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\flushleft\vspace{.20in}\textbf {Returns}\newline

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\

\begin{verbatim}
   # no scantable is created yet
   scanlist=sd.list_scans()
   print scanlist
   []
   # create scantable
   s=sd.scantable('OrionS_rawACSmod',average=False)
   # run list_scans() again
   scanlist=sd.list_scans()
   print scanlist
   ['s']
\end{verbatim}


%% sd.mask_and
\newpage
\ahsdfunction{sd.mask\_and}{sd.mask_and}{Logical operation function on array}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\
   This is an utility function that performs logical 'and' operation 
   on specified two boolean arrays in element-by-element manner.
   Input arrays should have same length.

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
a&& \multicolumn{2}{p{3.36in}|}{Input boolean array}\\
& &allowed: & bool array\\
& &Default: & 
\\
b&& \multicolumn{2}{p{3.36in}|}{Input boolean array}\\
& &allowed: & bool array \\
& &Default: & 
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline
bool array

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\

\begin{verbatim}
   a=[True,False,False]
   b=[True,True,False]
   sd.mask_and(a,b)
   [True,False,False]
\end{verbatim}



%% sd.mask_or
\newpage
\ahsdfunction{sd.mask\_or}{sd.mask_or}{Logical operation function on array}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\
   This is an utility function that performs logical 'or' operation 
   on specified two boolean arrays in element-by-element manner.
   Input arrays should have same length.

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
a&& \multicolumn{2}{p{3.36in}|}{Input boolean array}\\
& &allowed: & bool array\\
& &Default: & 
\\
b&& \multicolumn{2}{p{3.36in}|}{Input boolean array}\\
& &allowed: & bool array \\
& &Default: & 
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline
bool array

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\

\begin{verbatim}
   a=[True,False,False]
   b=[True,True,False]
   sd.mask_or(a,b)
   [True,True,False]
\end{verbatim}


%% sd.mask_not
\newpage
\ahsdfunction{sd.mask\_not}{sd.mask_not}{Logical operation function on array}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\
   This is an utility function that performs logical 'not' operation 
   on the input boolean array in element-by-element manner.

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
a&& \multicolumn{2}{p{3.36in}|}{Input boolean array}\\
& &allowed: & bool array\\
& &Default: & 
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline
bool array

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\

\begin{verbatim}
   a=[True,False,False]
   sd.mask_not(a)
   [False,True,True]
\end{verbatim}



%% sd.merge
\newpage
\ahfunction{sd.merge}{Merge a list of scantables into one}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\
   Merge a list of scanatables, or comma-sperated scantables into one scnatble.

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
 && \multicolumn{2}{p{3.36in}|}{Input scantables}\\
& &allowed: & list of scantables or comma-separated scantables\\
& &Default: & 
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline
scantable

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\

\begin{verbatim}
        scan1 = sd.scantable('scan1.asap')
        scan2 = sd.scantable('scan2.asap')
        myscans = [scan1, scan2]
        allscans = sd.merge(myscans)
        # or equivalent
        sameallscans = sd.merge(scan1, scan2)
\end{verbatim}


%% sd.quotient
\newpage
\ahfunction{sd.quotient}{Take a quotient of a signal and reference scan}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\
   Return the quotient of a 'source' (signal) scan and a 'reference' scan.
   The reference can have just one scan, even if the signal has many. Otherwise
   they must have the same number of scans.
   The cursor of the output scan is set to 0.

   The preserve argument controls if continuum is preserved or not.
   The equation used in the method depends on its value. 
   If preserve is True, the equation is,

   \begin{displaymath}
   T_{\rm a}^* = T_{\rm sys}^{\rm OFF} { ON \over OFF } - T_{\rm sys}^{\rm OFF},
   \end{displaymath}
   
   while if preserve is False, 

   \begin{displaymath}
   T_{\rm a}^* = T_{\rm sys}^{\rm OFF} { ON \over OFF } - T_{\rm sys}^{\rm ON},
   \end{displaymath}

   where $T_{\rm a}^*$ is antenna temperature, $ON$ and $OFF$ are 
   raw (uncalibrated) spectral data that correspond to on-source 
   and off-source position, $T_{\rm sys}^{\rm ON}$ and 
   $T_{\rm sys}^{\rm OFF}$ are system temperatures of $ON$ and $OFF$ scans, 
   respectively. 

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
source && \multicolumn{2}{p{3.36in}|}{The on-source scan as a scantable}\\
& &allowed: & scantable\\
& &Default: & 
\\
reference && \multicolumn{2}{p{3.36in}|}{The reference scan as a scantable}\\
& &allowed: & scantable\\
& &Default: & 
\\
preserve && \multicolumn{2}{p{3.36in}|}{Preserve the continuum or remove it}\\
& &allowed: & bool\\
& &Default: & True
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline
scantable 

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\

\begin{verbatim}
   s = sd.scantable('OrionS_rawACSmod',average=False)
   sel = sd.selector()
   # ON scan
   sel.set_types(srctype.pson)
   s.set_selection(sel)
   sig = s.copy()
   s.set_selection()
   sel.reset()
   # OFF scan
   sel.set_types(srctype.psoff)
   s.set_selection(sel)
   ref = s.copy()
   s.set_selection()
   sel.reset()
   # get quotient data
   cals = sd.quotient(source=sig,reference=ref,preserve=True)
\end{verbatim}


%% sd.rc
\newpage
\ahfunction{sd.rc}{Set the current rc parameters}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\
    Set the current rc parameters (sd.rcParams, 
    see \ahlink{list\_rcparameters}{sd:sd.list_rcparameters}).  
    The group is the grouping for the rc, eg
    for scantable.save the group is 'scantable', for plotter.stacking, the
    group is 'plotter', and so on.  kwargs is a list of attribute
    name/value pairs, eg

      \begin{verbatim}
      sd.rc('scantable', save='SDFITS')
      \end{verbatim}

    sets the current rc params and is equivalent to

      \begin{verbatim}
      sd.rcParams['scantable.save'] = 'SDFITS'
      \end{verbatim}

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
group && \multicolumn{2}{p{3.36in}|}{Grouping for the rc}\\
& &allowed: & string ('','scantable','plotter') \\
& &Default: & 
\\
 && \multicolumn{2}{p{3.36in}|}{A list of attribute name/value pairs}\\
& &allowed: & comma separated list of name/value pairs\\
& &Default: & 
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\

\begin{verbatim}
     # set scantable.save as 'SDFITS' and scantable.storage as 'disk'
     sd.rc('scantable',save='SDFITS', storage='disk')
     # set insitu as False
     sd.rc('',insitu=False)
\end{verbatim}


%% sd.skydip
\newpage
\ahfunction{sd.skydip}{Determine the opacity from a set of 'skydip' observations}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\
    Determine the opacity from a set of 'skydip' obervations.
    This can be any set of observations over a range of elevations,
    but will ususally be a dedicated (set of) scan(s).
    Return a list of 'n' opacities for 'n' IFs. In case of averagepol
    being 'False' a list of 'n*m' elements where 'm' is the number of
    polarisations, e.g.
    nIF $=$ 3, nPol $=$ 2 $\Rightarrow$ [if0pol0, if0pol1, if1pol0, if1pol1, if2pol0, if2pol1]
    
    The opacity is determined by fitting a first order polynomial to:
    
        \begin{displaymath}
        T_{\rm sys}(airmass) = p_0 + airmass * p1,
        \end{displaymath}
    
    where
        \begin{displaymath}
        airmass = {1 \over \sin(elevation)}
        \end{displaymath}
        \begin{displaymath}
        \tau =  {p_1 \over T_{\rm sky} }
        \end{displaymath}
    

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
data && \multicolumn{2}{p{3.36in}|}{File name or scantable or list of them}\\
& &allowed: & string, string array, scantable, list of scantables \\
& &Default: & 
\\
averagepol && \multicolumn{2}{p{3.36in}|}{Return opacity values per polarization or average of opacities for the polarizations}\\
& &allowed: & bool \\
& &Default: & True 
\\
tsky && \multicolumn{2}{p{3.36in}|}{The sky temperature}\\
& &allowed: & float \\
& &Default: & 300.0 
\\
plot && \multicolumn{2}{p{3.36in}|}{Plot each fit (airmass versus Tsys)}\\
& &allowed: & bool \\
& &Default: & False
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline
float array

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\

\begin{verbatim}
   s=sd.scantable('skydip.asap',average=False)
   sd.skydip(data=s,averagepol=True,plot=True)
\end{verbatim}


%% sd.splitant
\newpage
\ahfunction{sd.splitant}{Split Measurement Set data by antenna and save them as scantable}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\
    Split Measurement Set by antenna name, save data as a scantables,
    and return a list of filename.
    Notice this method can only be available from \casa.
    The outprefix argument specifies a prefix of output scantable name.
    The names of output scantables will be 'outprefix.antenna1.asap', 
    'outprefix.antenna2.asap', ... where antenna1 and antenna2 is 
    antenna name that are stored in ANTENNA subtable of input Measurement 
    Set.

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
filename && \multicolumn{2}{p{3.36in}|}{The name of Measurement Set to be read}\\
& &allowed: & string \\
& &Default: & 
\\
outprefix && \multicolumn{2}{p{3.36in}|}{The prefix of output scantable name}\\
& &allowed: & string \\
& &Default: & ''
\\
overwrite && \multicolumn{2}{p{3.36in}|}{If the file should be overwritten if it exists}\\
& &allowed: & bool \\
& &Default: & False
\\

\hline
\end{tabular}


\flushleft\vspace{.20in}\textbf {Returns}\newline
string array

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\

\begin{verbatim}
     # assume that input MS contains data from 'DV01' and 'PM03'
     outfiles=sd.splitant('osfdata.ms',outprefix='test')
     print outfiles
     ['test.DV01.asap','test.PM03.asap']
\end{verbatim}


%% sd.unique
\newpage
\ahfunction{sd.unique}{Return the unique values in a list}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\
    This is an utility function that returns the unique values in a list
 
\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
x && \multicolumn{2}{p{3.36in}|}{The list to reduce}\\
& &allowed: & array \\
& &Default: & 
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline
any array 

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\

\begin{verbatim}
   x=[1,2,3,3,4]
   y=sd.unique(x)
   print y
   [1,2,3,4]
\end{verbatim}


%% sd.welcome
\newpage
\ahfunction{sd.welcome}{Return a welcome message}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\
   Return a welcome message.
  
   Note that the message assumes the sd tool (ASAP) is used as a standalone 
   software so that some informations are not fit with \casa.
   For example, you should also report bugs on sd tool to \casa\ helpdesk, 
   and you have to run 'sd.commands() instead of 'commands()' if you want to 
   get a list of commands from \casa\ console. 

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\flushleft\vspace{.20in}\textbf {Returns}\newline
string

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\

\begin{verbatim}
   msg=sd.welcome()
   print msg
   # output will be as follows
   Welcome to ASAP vtrunk (2010-08-13) - the ATNF Spectral Analysis Package

   Please report any bugs via:
   http://svn.atnf.csiro.au/trac/asap/simpleticket

   [IMPORTANT: ASAP is 0-based]
   Type commands() to get a list of all available ASAP commands.
\end{verbatim}


%%%%%% sd.scantable
\newpage
\ahobject{sd.scantable}{Representation of single-dish data format}
%\ahfunction{sd.scantable}{Representation of single-dish data format}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

  The scantable is a representation of the Scantable, which is a data 
  format designed properly for single-dish data. 
  The scantable is implemented as \casa\ table so that it is possible 
  to access data via \ahlink{table}{table} tool. 
  On the other hand, the scantable has its own functions to get/set some data. 
  In addition to the simple setter/getter and utility functions, 
  the scantable has some data reduction function such as calibration, 
  baseline fitting, etc. 
  
  The 'insitu' option often appears in the functions. This parameter 
  controls if a certain operation is applied to this scantable 
  (true) or return another scantable that is a result of the operation 
  (false). 
  In former case, the original scantable loaded will be lost 
  although the data on disk will be kept. 
  The default value of the option depends on sd.rcParams dictionary. 
  See \ahlink{sd.list\_rcparameters}{sd:sd.list_rcparameters} for 
  details about sd.rcParams.

  The constructor takes several arguments that handles some of optional 
  behavior of it. The getpt and antenna arguments are only effective if 
  file specified by filename argument is Measurement Set format.

  \medskip\noindent\textbf{Definition}

    A documentation for detailed definition of the Scantable will be 
    prepared by ATNF.

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
filename && \multicolumn{2}{p{3.36in}|}{Name of an input file, or a reference to an existing scantable (advanced)}\\
& &allowed: & string, scantable \\
& &Default: & 
\\
average && \multicolumn{2}{p{3.36in}|}{Average all integrations within a scan on read}\\
& &allowed: & bool \\
& &Default: & None (taken from scantable.autoaverage attribute of rc parameters)\\
unit && \multicolumn{2}{p{3.36in}|}{Brightness unit. It must be consistent with K or Jy. It overrides the default value or replaces the value in existing scantables}
\\
& &allowed: & string \\
& &Default: & None
\\
getpt && \multicolumn{2}{p{3.36in}|}{Measurement Set input data only. If True, all pointing data are filled.}\\
& &allowed: & bool\\
& &Default: & False
\\
antenna && \multicolumn{2}{p{3.36in}|}{Measurement Set input data only. Antenna selection by ID or name}\\
& &allowed: & string, integer\\
& &Default: & '' (first antenna in the ANTENNA table) 
\\
parallactify && \multicolumn{2}{p{3.36in}|}{Indicate that the data had been parallactified.}\\
& &allowed: & bool\\
& &Default: & None (taken from scantable.parallactify attribute of rc parameters)
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\

\begin{verbatim}
     # create scantable from the data from the second antenna in Measurement Set
     s=sd.scantable('sddata.ms',average=False,getpt=True,antenna=1)
\end{verbatim}


Methods
\begin{longtable}{ll}

	\ahlink{add}{sd:sd.scantable.add} &Return a scan where all spectra have the offset added \\

        \ahlink{auto\_cspline\_baseline}{sd:sd.scantable.auto_cspline_baseline} &Perform automatic line finding and baseline subtraction using cubic spline function \\

	\ahlink{auto\_poly\_baseline}{sd:sd.scantable.auto_poly_baseline} &Perform automatic line finding and baseline subtraction using polynomial function \\

        \ahlink{auto\_sinusoid\_baseline}{sd:sd.scantable.auto_sinusoid_baseline} &Perform automatic line finding and baseline subtraction using sinusoidal function \\

	\ahlink{auto\_quotient}{sd:sd.scantable.auto_quotient} &Automatic quotient for coordinated scans \\

	\ahlink{average\_beam}{sd:sd.scantable.average_beam} &Average beams together for multi-beam observation \\

	\ahlink{average\_pol}{sd:sd.scantable.average_pol} &Average polarizations together \\

	\ahlink{average\_time}{sd:sd.scantable.average_time} &Return time average of a scan \\

	\ahlink{bin}{sd:sd.scantable.bin} &Perform binning of spectra \\

	\ahlink{chan2data}{sd:sd.scantable.chan2data} &Return channel/frequency/velocity and spectral value\\

	\ahlink{clip}{sd:sd.scantable.clip} &Flag data by its spectral value \\

	\ahlink{convert\_flux}{sd:sd.scantable.convert_flux} &Return a scan where all spectra are converted to Jy or K \\

	\ahlink{convert\_pol}{sd:sd.scantable.convert_pol} &Convert data to a different polarization type \\

	\ahlink{copy}{sd:sd.scantable.copy} &Return a copy of this scantable \\

	\ahlink{create\_mask}{sd:sd.scantable.create_mask} &Return a bool array based on [min,max] windows \\

	\ahlink{cspline\_baseline}{sd:sd.scantable.cspline_baseline} &Perform a baseline subtraction using cubic spline function \\

	\ahlink{drop\_scan}{sd:sd.scantable.drop_scan} &Return a new scantable where the specified scan number(s) dropped \\

	\ahlink{flag}{sd:sd.scantable.fft} & Apply FFT to the spectra \\

	\ahlink{flag}{sd:sd.scantable.flag} & Flag selected data using specified mask (channel based flag) \\

	\ahlink{flag\_nans}{sd:sd.scantable.flag_nans} &Flag NaN values\\

	\ahlink{flag\_row}{sd:sd.scantable.flag_row} &Flag spectra based on specified rows (row based flag)\\

	\ahlink{freq\_align}{sd:sd.scantable.freq_align} &Perform frequency alignment \\

	\ahlink{freq\_switch}{sd:sd.scantable.freq_switch} &Apply frequency switching to the data\\

	\ahlink{gain\_el}{sd:sd.scantable.gain_el} &Apply gain-elevation correction based on user-provided data \\

	\ahlink{get\_abcissa}{sd:sd.scantable.get_abcissa} &Get the abcissa values \\

	\ahlink{get\_antennaname}{sd:sd.scantable.get_antennaname} &Get antenna name\\

	\ahlink{get\_azimuth}{sd:sd.scantable.get_azimuth} &Get a list of azimuth during the observation \\

	\ahlink{get\_column\_names}{sd:sd.scantable.get_column_names} &Get a list of column names in the main table\\

	\ahlink{get\_coordinate}{sd:sd.scantable.get_coordinate} &Return the spectral coordinate for a given row as a \ahlink{coordinate}{sd:sd.coordinate} object \\

	\ahlink{get\_direction}{sd:sd.scantable.get_direction} &Get a list of positions on the sky as a string \\

	\ahlink{get\_directionval}{sd:sd.scantable.get_directionval} &Get a list of positions on the sky as a float \\

	\ahlink{get\_elevation}{sd:sd.scantable.get_elevation} &Get a list of elevation during the observation \\

	\ahlink{get\_fit}{sd:sd.scantable.get_fit} &Get the stored fits for a row in scantable \\

	\ahlink{get\_fluxunit}{sd:sd.scantable.get_fluxunit} &Get a flux unit \\

	\ahlink{get\_inttime}{sd:sd.scantable.get_inttime} &Get a list of integration times for the observation \\

	\ahlink{get\_mask}{sd:sd.scantable.get_mask} &Get mask for the specified row as a bool list \\

	\ahlink{get\_mask\_indices}{sd:sd.scantable.get_mask_indices} &Compute a lists of mask start/end indices from the given bool array \\

	\ahlink{get\_masklist}{sd:sd.scantable.get_masklist} &Compute a list of mask windows from the given bool array \\

	\ahlink{get\_parangle}{sd:sd.scantable.get_parangle} &Get a list of parallactic angles for the observation \\

	\ahlink{get\_restfreqs}{sd:sd.scantable.get_restfreqs} &Get the rest frequency(s) stored in the scantable \\

	\ahlink{get\_rms}{sd:sd.scantable.get_rms} &Calculate rms of the spectrum \\

	\ahlink{get\_row}{sd:sd.scantable.get_row} &Return a scantable with single row \\

	\ahlink{get\_row\_selector}{sd:sd.scantable.get_row_selector} &Return a \ahlink{selector}{sd:sd.selector} object that only selects target row \\

	\ahlink{get\_scan}{sd:sd.scantable.get_scan} &Return a specified scan(s) specified by scan number or source name \\

	\ahlink{get\_selection}{sd:sd.scantable.get_selection} &Get current selection that is currently set on this scantable \\

	\ahlink{get\_sourcename}{sd:sd.scantable.get_sourcename} &Get a list of source names for the observation \\

	\ahlink{get\_spectrum}{sd:sd.scantable.get_spectrum} &Get the spectrum for the current row \\

	\ahlink{get\_time}{sd:sd.scantable.get_time} &Get a list of time stamps for the observation \\

	\ahlink{get\_tsys}{sd:sd.scantable.get_tsys} &Get a list of system temperatures \\

	\ahlink{get\_unit}{sd:sd.scantable.get_unit} &Get the default unit of spectral axis \\

	\ahlink{get\_weather}{sd:sd.scantable.get_weather} &Get the weather informations \\

	\ahlink{getbeam}{sd:sd.scantable.getbeam} &Get beam number of the given row \\

	\ahlink{getbeamnos}{sd:sd.scantable.getbeamnos} &Get a list of beam numbers in the scantable \\

	\ahlink{getcycle}{sd:sd.scantable.getcycle} &Get cycle number of the given row \\

	\ahlink{getif}{sd:sd.scantable.getif} &Get IF number of the given row \\

	\ahlink{getifnos}{sd:sd.scantable.getifnos} &Get a list of IF nubers in the scantable \\

	\ahlink{getmolnos}{sd:sd.scantable.getmolnos} &Get a list of molecule ids in the scantable \\

	\ahlink{getpol}{sd:sd.scantable.getpol} &Get polarization number of the given row \\

	\ahlink{getpolnos}{sd:sd.scantable.getpolnos} &Get a list of polarization numbers in the scantable \\

	\ahlink{getscan}{sd:sd.scantable.getscan} &Get scan number of the given row \\

	\ahlink{getscannos}{sd:sd.scantable.getscannos} &Get a list of scan numbers in the scantable \\

	\ahlink{history}{sd:sd.scantable.history} &Print a history \\

	\ahlink{invert\_phase}{sd:sd.scantable.invert_phase} &Invert the phase of the complex polarization \\

	\ahlink{lag\_flag}{sd:sd.scantable.lag_flag} &Perform Fourier filtering on the spectra \\

	\ahlink{mx\_quotient}{sd:sd.scantable.mx_quotient} &Form a quotient using "off" beams when observing in "MX" mode \\

	\ahlink{nbeam}{sd:sd.scantable.nbeam} &Return a number of beams \\

	\ahlink{nchan}{sd:sd.scantable.nchan} &Return a number of channels \\

	\ahlink{ncycle}{sd:sd.scantable.ncycle} &Return a number of cycles \\

	\ahlink{nif}{sd:sd.scantable.nif} &Return a number of IFs \\

	\ahlink{npol}{sd:sd.scantable.npol} &Return a number of polarizations \\

	\ahlink{nrow}{sd:sd.scantable.nrow} &Return a number of rows \\

	\ahlink{nscan}{sd:sd.scantable.nscan} &Return a number of scans \\

	\ahlink{opacity}{sd:sd.scantable.opacity} &Apply an opacity correction \\

	\ahlink{parallactify}{sd:sd.scantable.parallactify} &Set a flag to indicate the data should be treated as "parallactified"  \\

	\ahlink{poltype}{sd:sd.scantable.poltype} &Get a polarization type \\

	\ahlink{poly\_baseline}{sd:sd.scantable.poly_baseline} &Perform a baseline subtraction using polynomial function \\

	\ahlink{recalc\_azel}{sd:sd.scantable.recalc_azel} &Recalculate azimuth and elevation for each sky position \\

	\ahlink{resample}{sd:sd.scantable.resample} &Perform a binning \\

	\ahlink{rotate\_linpolphase}{sd:sd.scantable.rotate_linpolphase} &Rotate a phase of the complex polarization \\

	\ahlink{rotate\_xyphase}{sd:sd.scantable.rotate_xyphase} &Rotate a phase of the XY correlation \\

	\ahlink{save}{sd:sd.scantable.save} &Store the scantable on disk \\

	\ahlink{scale}{sd:sd.scantable.scale} &Scale spectra by the given factor \\

	\ahlink{set\_dirframe}{sd:sd.scantable.set_dirframe} &Set the frame type of the direction on the sky \\

	\ahlink{set\_doppler}{sd:sd.scantable.set_doppler} &Set definition of the Doppler correction  \\

	\ahlink{set\_feedtype}{sd:sd.scantable.set_feedtype} &Set the feed type \\

	\ahlink{set\_fluxunit}{sd:sd.scantable.set_fluxunit} &Set flux unit \\

	\ahlink{set\_freqframe}{sd:sd.scantable.set_freqframe} &Set the frame type of the spectral axis \\

	\ahlink{set\_instrument}{sd:sd.scantable.set_instrument} &Set antenna name \\

	\ahlink{set\_restfreqs}{sd:sd.scantable.set_restfreqs} &Set rest frequency \\

	\ahlink{set\_selection}{sd:sd.scantable.set_selection} &Select a subset of the data \\

	\ahlink{set\_sourcetype}{sd:sd.scantable.set_sourcetype} &Set the types of source to be source or reference scan \\

	\ahlink{set\_spectrum}{sd:sd.scantable.set_spectrum} &Set spectrum for specified row \\

	\ahlink{set\_unit}{sd:sd.scantable.set_unit} &Set unit for spectral axis \\

	\ahlink{shift\_refpix}{sd:sd.scantable.shift_refpix} &Shift the reference pixel of the spectral coordinate \\

	\ahlink{sinusoid\_baseline}{sd:sd.scantable.sinusoid_baseline} &Perform a baseline subtraction using sinusoidal function \\

	\ahlink{smooth}{sd:sd.scantable.smooth} &Smooth the spectra \\

	\ahlink{stats}{sd:sd.scantable.stats} &Compute specified statistics of the spectra \\

	\ahlink{stddev}{sd:sd.scantable.stddev} &Compute standard deviation of the spectra \\

	\ahlink{summary}{sd:sd.scantable.summary} &Print a summary of the contents of the scantable \\

	\ahlink{swap\_linears}{sd:sd.scantable.swap_linears} &Swap the linear polarizations XX and YY \\

\end{longtable}


%% sd.scantable.add
\newpage
\ahfunction{sd.scantable.add}{Return a scan where all spectra have the offset added}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

   Return a scan where all spectra have the offset added.
   If insitu is True, or insitu is None and sd.rcParams['insitu'] is True, 
   the method will not return the result, but apply operation on this scantable. 

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
offset && \multicolumn{2}{p{3.36in}|}{The offset}\\
& &allowed: & float \\
& &Default: & 
\\
insitu && \multicolumn{2}{p{3.36in}|}{If False a new scantable is returned}\\
& &allowed: & bool \\
& &Default: & None (use default value)\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline
scantable

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.scantable.auto_cspline_baseline
\newpage
\ahsdfunction{sd.scantable.auto\_cspline\_baseline}{sd.scantable.auto_cspline_baseline}{Perform automatic line finding and baseline subtraction using cubic spline function}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

    Return a scan which has been baselined (all rows) by cubic spline
    function (piecewise cubic polynomial). Fit will be done with 'sigma-clipping'.

    Spectral lines are detected first using linefinder and masked out
    to avoid them affecting the baseline solution.

    The edge argument is an optional number of channel to drop at the edge of
    spectrum. If only one value is specified, the same number will be dropped from
    both sides of the spectrum. Default is to keep all channels. Nested tuples 
    represent individual edge selection for different IFs (a number of spectral
    channels can be different).

    The threshold and chan\_avg\_limit arguments are linefinder options.
    The former is the threshold used by line finder. It is better to
    keep it large as only strong lines affect the baseline solution.
    The later is  a maximum number of consequtive spectral channels to
    average during the search of weak and broad lines.
    The default is no averaging (and no search for weak
    lines). If such lines can affect the fitted baseline
    (e.g. a high order polynomial is fitted), increase this
    parameter (usually values up to 8 are reasonable). Most
    users of this method should find the default value sufficient.
    See \ahlink{linefinder}{sd:sd.linefinder} for more details on these options.

    Note:
        The best-fit parameter values output in logger and/or blfile are now
        based on specunit of 'channel'. 
 
\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
insitu && \multicolumn{2}{p{3.36in}|}{If False a new scantable is returned}\\
& &allowed: bool &  \\
& &Default: None (use default value) & 
\\
mask && \multicolumn{2}{p{3.36in}|}{An optional mask retreived from scantable}\\
& &allowed: & bool \\
& &Default: & None (no mask)
\\
npiece && \multicolumn{2}{p{3.36in}|}{Number of pieces}\\
& &allowed: & integer \\
& &Default: & 2
\\
clipthresh && \multicolumn{2}{p{3.36in}|}{Clipping threshold in unit of sigma}\\
& &allowed: & float \\
& &Default: & 3.0
\\
clipniter && \multicolumn{2}{p{3.36in}|}{Maximum number of iteration of clipping}\\
& &allowed: & integer \\
& &Default: & 0
\\
edge && \multicolumn{2}{p{3.36in}|}{An optional number of channel to drop at the edge of spectrum}\\
& &allowed: & integer, integer array \\
& &Default: & (0,0) 
\\
threshold && \multicolumn{2}{p{3.36in}|}{The threshold used by line finder}\\
& &allowed: & float \\
& &Default: & 3
\\
chan\_avg\_limit && \multicolumn{2}{p{3.36in}|}{A maximum number of consequtive spectral channels to average during the search}\\
& &allowed: & int \\
& &Default: & 1
\\
plot && \multicolumn{2}{p{3.36in}|}{Plot the fit and the residual (currently unavailable)}\\
& &allowed: & bool \\
& &Default: & False
\\
getresidual && \multicolumn{2}{p{3.36in}|}{If False, return best-fit value instead of residual}\\
& &allowed: & bool \\
& &Default: & True 
\\
showprogress && \multicolumn{2}{p{3.36in}|}{Show progress status for large data}\\
& &allowed: & bool \\
& &Default: & True 
\\
minnrow && \multicolumn{2}{p{3.36in}|}{Minimum number of spectra to show progress status}\\
& &allowed: & integer \\
& &Default: & 1000
\\
outlog && \multicolumn{2}{p{3.36in}|}{Output the coefficients of the best-fit function to logger}\\
& &allowed: & bool \\
& &Default: & False
\\
blfile && \multicolumn{2}{p{3.36in}|}{Name of text file in which the best-fit parameter values to be written}\\
& &allowed: & string \\
& &Default: & '' 
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline
scantable

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\

\begin{verbatim}
        scan = sd.scantable('OrionS_rawACSmod_cal',average=False)
        bscan = scan.auto_cspline_baseline(npiece=3, insitu=False)
\end{verbatim}


%% sd.scantable.auto_poly_baseline
\newpage
\ahsdfunction{sd.scantable.auto\_poly\_baseline}{sd.scantable.auto_poly_baseline}{Perform automatic line finding and baseline subtraction using polynomial function}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

    Return a scan which has been baselined (all rows) by a polynomial.
    Spectral lines are detected first using linefinder and masked out
    to avoid them affecting the baseline solution.

    The edge argument is an optional number of channel to drop at the edge of
    spectrum. If only one value is specified, the same number will be dropped from
    both sides of the spectrum. Default is to keep all channels. Nested tuples 
    represent individual edge selection for different IFs (a number of spectral
    channels can be different).

    The threshold and chan\_avg\_limit arguments are linefinder options.
    The former is the threshold used by line finder. It is better to
    keep it large as only strong lines affect the baseline solution.
    The later is  a maximum number of consequtive spectral channels to
    average during the search of weak and broad lines.
    The default is no averaging (and no search for weak
    lines). If such lines can affect the fitted baseline
    (e.g. a high order polynomial is fitted), increase this
    parameter (usually values up to 8 are reasonable). Most
    users of this method should find the default value sufficient.
    See \ahlink{linefinder}{sd:sd.linefinder} for more details on these options.

    You can verify and decide whether you apply the fit result or not, if plot argument is True.
    In that case, you have to answer 'y' or 'n' for each spectra so that setting True is not 
    recommended for large dataset.
 
    Note:
        The best-fit parameter values output in logger and/or blfile are now
        based on specunit of 'channel'. 

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
mask && \multicolumn{2}{p{3.36in}|}{An optional mask retreived from scantable}\\
& &allowed: & bool array \\
& &Default: & None (no mask)
\\
order && \multicolumn{2}{p{3.36in}|}{The order of the polynomial}\\
& &allowed: & integer \\
& &Default: & 0
\\
edge && \multicolumn{2}{p{3.36in}|}{An optional number of channel to drop at the edge of spectrum}\\
& &allowed: & integer, integer array \\
& &Default: & (0,0) 
\\
threshold && \multicolumn{2}{p{3.36in}|}{The threshold used by line finder}\\
& &allowed: & float \\
& &Default: & 3
\\
chan\_avg\_limit && \multicolumn{2}{p{3.36in}|}{A maximum number of consequtive spectral channels to average during the search}\\
& &allowed: & int \\
& &Default: & 1
\\
plot && \multicolumn{2}{p{3.36in}|}{Plot the fit and the residual.}\\
& &allowed: & bool \\
& &Default: & False
\\
insitu && \multicolumn{2}{p{3.36in}|}{If False a new scantable is returned}\\
& &allowed: & bool \\
& &Default: & None (use default value)
\\
getresidual && \multicolumn{2}{p{3.36in}|}{If False, return best-fit value instead of residual}\\
& &allowed: & bool \\
& &Default: & True 
\\
showprogress && \multicolumn{2}{p{3.36in}|}{Show progress status for large data}\\
& &allowed: & bool \\
& &Default: & True 
\\
minnrow && \multicolumn{2}{p{3.36in}|}{Minimum number of spectra to show progress status}\\
& &allowed: & integer \\
& &Default: & 1000
\\
outlog && \multicolumn{2}{p{3.36in}|}{Output the coefficients of the best-fit function to logger}\\
& &allowed: & bool \\
& &Default: & False
\\
blfile && \multicolumn{2}{p{3.36in}|}{Name of text file in which the best-fit parameter values to be written}\\
& &allowed: & string \\
& &Default: & '' 
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline
scantable

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\

\begin{verbatim}
        scan = sd.scantable('OrionS_rawACSmod_cal',average=False)
        scan2 = scan.auto_poly_baseline(order=7, insitu=False)
\end{verbatim}


%% sd.scantable.auto_quotient
\newpage
\ahsdfunction{sd.scantable.auto\_quotient}{sd.scantable.auto_quotient}{Automatic quotient for coordinated scans}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

    This function allows to build quotients automatically.
    It assumes the observation to have the same number of
    "ons" and "offs".

    The formula to get result depends on the preserve paramter. If it is True, the continuum will be 
    preserved while if it is False, the continuum will be removed. The equation used are

    \begin{displaymath}
    T_{\rm a}^* = T_{\rm sys}^{\rm OFF} { ON \over OFF } - T_{\rm sys}^{\rm OFF},
    \end{displaymath}
   
    if preserve is True, while

    \begin{displaymath}
    T_{\rm a}^* = T_{\rm sys}^{\rm OFF} { ON \over OFF } - T_{\rm sys}^{\rm ON},
    \end{displaymath}

    if preserve is False.

    The mode argument controls the on/off decition mode. If mode is 'paired' (default), 
    it identifies 'off' scans by the
    trailing '\_R' (Mopra/Parkes) or '\_e'/'\_w' (Tid) and matches on/off pairs from the observing pattern.
    On the other hand, 'time' finds the closest off in time.

    Note that the verify argument is not yet implemented.

 
\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
preserve && \multicolumn{2}{p{3.36in}|}{You can preserve the continuum or remove it}\\
& &allowed: & bool \\
& &Default: & True
\\
mode && \multicolumn{2}{p{3.36in}|}{The on/off decition mode}\\
& &allowed: & string \\
& &Default: & 'paired'
\\
verify && \multicolumn{2}{p{3.36in}|}{Verify result (not yet implemented)} \\
& &allowed: & bool \\
& &Default: & False
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline
scantable

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.scantable.auto_sinusoid_baseline
\newpage
\ahsdfunction{sd.scantable.auto\_sinusoid\_baseline}{sd.scantable.auto_sinusoid_baseline}{Perform automatic line finding and baseline subtraction using sinusoidal function}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

    Return a scan which has been baselined (all rows) with sinusoidal functions.
    Fit will be done with 'sigma-clipping'.

    Spectral lines are detected first using linefinder and masked out
    to avoid them affecting the baseline solution.

    If applyfft is set to True, the function performs Fourier analysis to select 
    wave numbers for sinusoidal fitting. Currently, 'fft' is only available to be 
    used for the analysis. You can specify threshold for selection of wave number 
    using fftthresh parameter. Both float and string is acceptable. Given a float 
    value, the unit is set to sigma. For string values, allowed formats include:

    \begin{itemize}
    \item any decimal number plus 'sigma' (e.g. '3sigma')
    \item 'top' plus any decimal number (e.g. 'top10')
    \end{itemize}

    In addition, you can add or reject specific wave numbers from the fit using 
    addwn and rejwn, respectively. You can specify wave numbers as an integer,  
    string, or list of them. For string specification, syntax for those parameters 
    are as follows:
    
    \begin{itemize}
    \item 'a-b' (= a, a+1, a+2, ..., b-1, b)
    \item '$<$a' (= 0, 1, ..., a-2, a-1)
    \item '$>$a' (= a+1, a+2, ... up to maximum wave number corresponding to the Nyquist frequency)
    \end{itemize} 

    You can append '=' after inequality sign. When both addwn and rejwn are set, 
    rejwn will take priority of addwn.
 
    The edge argument is an optional number of channel to drop at the edge of
    spectrum. If only one value is specified, the same number will be dropped from
    both sides of the spectrum. Default is to keep all channels. Nested tuples 
    represent individual edge selection for different IFs (a number of spectral
    channels can be different).

    The threshold and chan\_avg\_limit arguments are linefinder options.
    The former is the threshold used by line finder. It is better to
    keep it large as only strong lines affect the baseline solution.
    The later is  a maximum number of consequtive spectral channels to
    average during the search of weak and broad lines.
    The default is no averaging (and no search for weak
    lines). If such lines can affect the fitted baseline
    (e.g. a high order polynomial is fitted), increase this
    parameter (usually values up to 8 are reasonable). Most
    users of this method should find the default value sufficient.
    See \ahlink{linefinder}{sd:sd.linefinder} for more details on these options.

    Note:
        The best-fit parameter values output in logger and/or blfile are now
        based on specunit of 'channel'. 

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
insitu && \multicolumn{2}{p{3.36in}|}{If False a new scantable is returned}\\
& &allowed: & bool \\
& &Default: & None (use default value)
\\
mask && \multicolumn{2}{p{3.36in}|}{An optional mask retreived from scantable}\\
& &allowed: & bool array \\
& &Default: & None (no mask)
\\
applyfft && \multicolumn{2}{p{3.36in}|}{Perform Fourier analysis to find appropriate sinusoidal component}\\
& &allowed: & bool \\
& &Default: & True
\\
fftmethod && \multicolumn{2}{p{3.36in}|}{Method to find sinusoidal component (currently only 'fft' is available)}\\
& &allowed: & string \\
& &Default: & 'fft'
\\
fftthresh && \multicolumn{2}{p{3.36in}|}{Threshod to select wave number in Fourier analysis}\\
& &allowed: & float, string \\
& &Default: & 3.0
\\
addwn && \multicolumn{2}{p{3.36in}|}{Additional wave numbers to be used for fitting}\\
& &allowed: & integer, string, any array \\
& &Default: & []
\\
rejwn && \multicolumn{2}{p{3.36in}|}{Waver numbers not to be used for fitting}\\
& &allowed: & integer, string, any array \\
& &Default: & []
\\
clipthresh && \multicolumn{2}{p{3.36in}|}{Clipping threshold in unit of sigma}\\
& &allowed: & float \\
& &Default: & 3.0
\\
clipniter && \multicolumn{2}{p{3.36in}|}{Maximum number of iteration of clipping}\\
& &allowed: & integer \\
& &Default: & 0
\\
edge && \multicolumn{2}{p{3.36in}|}{An optional number of channel to drop at the edge of spectrum}\\
& &allowed: & integer, integer array \\
& &Default: & (0,0) 
\\
threshold && \multicolumn{2}{p{3.36in}|}{The threshold used by line finder}\\
& &allowed: & float \\
& &Default: & 3
\\
chan\_avg\_limit && \multicolumn{2}{p{3.36in}|}{A maximum number of consequtive spectral channels to average during the search}\\
& &allowed: & int \\
& &Default: & 1
\\
plot && \multicolumn{2}{p{3.36in}|}{Plot the fit and the residual (currently unavailable)}\\
& &allowed: & bool \\
& &Default: & False
\\
getresidual && \multicolumn{2}{p{3.36in}|}{If False, return best-fit value instead of residual}\\
& &allowed: & bool \\
& &Default: & True 
\\
showprogress && \multicolumn{2}{p{3.36in}|}{Show progress status for large data}\\
& &allowed: & bool \\
& &Default: & True 
\\
minnrow && \multicolumn{2}{p{3.36in}|}{Minimum number of spectra to show progress status}\\
& &allowed: & integer \\
& &Default: & 1000
\\
outlog && \multicolumn{2}{p{3.36in}|}{Output the coefficients of the best-fit function to logger}\\
& &allowed: & bool \\
& &Default: & False
\\
blfile && \multicolumn{2}{p{3.36in}|}{Name of text file in which the best-fit parameter values to be written}\\
& &allowed: & string \\
& &Default: & '' 
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline
scantable

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\

\begin{verbatim}
        scan = sd.scantable('OrionS_rawACSmod_cal',average=False)
        scan2 = scan.auto_sinusoid_baseline(addwn='<=10', insitu=False)
\end{verbatim}


%% sd.scantable.average_beam
\newpage
\ahsdfunction{sd.scantable.average\_beam}{sd.scantable.average_beam}{Average beams together for multi-beam observation}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

    Average the Beams together.

    The mask argument is an optional mask defining the region, where the
    averaging will be applied. The output will have all specified points masked.

    The weight argument specifies weighting scheme. Valid options are:

    \begin{longtable}{rl}
    'none': & no weight (default) \\
    'var': & 1/var(spec) weighted \\
    'tsys': & 1/Tsys**2 weighted \\
    \end{longtable}
 
\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
mask && \multicolumn{2}{p{3.36in}|}{An optional mask defining the region}\\
& &allowed: & bool array \\
& &Default: & None
\\
weight && \multicolumn{2}{p{3.36in}|}{Weighting scheme}\\
& &allowed: & string \\
& &Default: & 'none'
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline
scantable

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.scantable.average_pol
\newpage
\ahsdfunction{sd.scantable.average\_pol}{sd.scantable.average_pol}{Average polarizations together}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

    Average the Polarisations together.
 
    The mask argument is an optional mask defining the region, where the
    averaging will be applied. The output will have all specified points masked.

    The weight argument specifies weighting scheme. Valid options are:

    \begin{longtable}{rl}
    'none': & no weight (default) \\
    'var': & 1/var(spec) weighted \\
    'tsys': & 1/Tsys**2 weighted \\
    \end{longtable}
 
\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
mask && \multicolumn{2}{p{3.36in}|}{An optional mask defining the region}\\
& &allowed: & bool array \\
& &Default: & None
\\
weight && \multicolumn{2}{p{3.36in}|}{Weighting scheme}\\
& &allowed: & string \\
& &Default: & 'none'
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline
scantable

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.scantable.average_time
\newpage
\ahsdfunction{sd.scantable.average\_time}{sd.scantable.average_time}{Return time average of a scan}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

    Return the (time) weighted average of a scan.

    The weight argument specifies weighting scheme. Valid options are:

    \begin{longtable}{rl}
    'none': & no weight \\
    'var': & 1/var(spec) weighted \\
    'tsys': & 1/Tsys**2 weighted \\
    'tint': & integration time weighted (default) \\
    'tintsys': & Tint/Tsys**2 weightd \\
    'median': & median averaging \\
    \end{longtable}
 
    The align argument is effective only for channel. 
    If it is True,  align the spectra in velocity before averaging. It takes
    the time of the first spectrum as reference time.


\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
mask && \multicolumn{2}{p{3.36in}|}{An optional mask (only used for 'var' and 'tsys' weighting)}\\
& &allowed: & bool array \\
& &Default: & None
\\
scanav && \multicolumn{2}{p{3.36in}|}{True averages each scan separately, False averages all scans together}\\
& &allowed: & bool \\
& &Default: & False
\\
weight && \multicolumn{2}{p{3.36in}|}{Weighting scheme}\\
& &allowed: & string \\
& &Default: & 'none'
\\
align && \multicolumn{2}{p{3.36in}|}{Align the spectral in velocity before averaging}\\
& &allowed: & bool \\
& &Default: & False
\\
compel && \multicolumn{2}{p{3.36in}|}{True forces to average overwrapped IFs}\\
& &allowed: & bool \\
& &Default: & False
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline
scantable

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\

\begin{verbatim}
        scan = sd.scantable('OrionS_rawACSmod_cal',average=False)
        # time average the scantable without using a mask
        newscan = scan.average_time()
\end{verbatim}


%% sd.scantable.bin
\newpage
\ahfunction{sd.scantable.bin}{Perform binning of spectra}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

    Return a scan where all spectra have been binned up.
    If insitu is True, or insitu is None and sd.rcParams['insitu'] is True, 
    the method will not return the result, but apply operation on this scantable. 

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
width && \multicolumn{2}{p{3.36in}|}{The bin width in pixels}\\
& &allowed: & integer \\
& &Default: & 5
\\
insitu && \multicolumn{2}{p{3.36in}|}{If False a new scantable is returned}\\
& &allowed: & bool \\
& &Default: & None (use default value)
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline
scantable

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.scantable.chan2data
\newpage
\ahfunction{sd.scantable.chan2data}{Return channel/frequency/velocity and spectral value at an arbitrary row and channel}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

    Returns channel/frequency/velocity and spectral value
    at an arbitrary row and channel in the scantable.

    The returned value is a tuple with length of 2.
    The first element is a dictionary that contains an unit and a value for the abcissa, while 
    the second one is also a dictionary that contains an unit and a value for the ordinate.
 
\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
rowno && \multicolumn{2}{p{3.36in}|}{A row number in the scantable}\\
& &allowed: & integer \\
& &Default: & 0
\\
chan && \multicolumn{2}{p{3.36in}|}{A channel in the scantable}\\
& &allowed: & integer \\
& &Default: & 0 
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline
dictionary array

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\

\begin{verbatim}
   s=sd.scantable('OrionS_rawACSmod_cal',average=False)
   s.chan2data(rowno=0,chan=0)
   ({'unit': 'channel', 'value': 0.0}, {'unit': 'K', 'value': 1.7028001546859741})
\end{verbatim}


%% sd.scantable.clip
\newpage
\ahfunction{sd.scantable.clip}{Flag data by its spectral value}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

    Flag the selected data outside a specified range (in channel-base).

    The method requires to set upper and lower threshold for spectral value.
    If clipoutside is True, the data outside the range will be flagged/unflagged.
    On the other hand, if it is False, the data inside the range will be flagged/unflagged.
    The operation if flag or unflag is controlled by the unflag argument.

    Note that the operation will always be applied to this scantable regardless of 
    the value of sd.rcParams['insitu']. 
 
\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
uthres && \multicolumn{2}{p{3.36in}|}{Upper threshold}\\
& &allowed: & float \\
& &Default: & None
\\
dthres && \multicolumn{2}{p{3.36in}|}{Lower threshold}\\
& &allowed: & float \\
& &Default: & None
\\
clipoutside && \multicolumn{2}{p{3.36in}|}{True for flagging data outside the range, False for flagging data inside the range}\\
& &allowed: & bool \\
& &Default: & True
\\
unflag && \multicolumn{2}{p{3.36in}|}{If True, unflag the data}\\
& &allowed: & bool \\
& &Default: & False
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.scantable.convert_flux
\newpage
\ahsdfunction{sd.scantable.convert\_flux}{sd.scantable.convert_flux}{Return a scan where all spectra are converted to Jy or K}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

    Return a scan where all spectra are converted to either
    Jansky or Kelvin depending upon the flux units of the scan table.
    By default the function tries to look the values up internally.
    If it can't find them (or if you want to over-ride), you must
    specify EITHER jyperk OR eta (and D which it will try to look up
    also if you don't set it). jyperk takes precedence if you set both.

    If insitu is True, or insitu is None and sd.rcParams['insitu'] is True, 
    the method will not return the result, but apply operation on this scantable. 

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
jyperk && \multicolumn{2}{p{3.36in}|}{The Jy/K conversion factor}\\
& &allowed: & float \\
& &Default: & None
\\
eta && \multicolumn{2}{p{3.36in}|}{The aperture efficiency}\\
& &allowed: & float \\
& &Default: & None
\\
d && \multicolumn{2}{p{3.36in}|}{The geometric diameter (metres)}\\
& &allowed: & float \\
& &Default: & None
\\
insitu && \multicolumn{2}{p{3.36in}|}{If False a new scantable is returned}\\
& &allowed: & bool \\
& &Default: & None
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline
scantable

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.scantable.convert_pol
\newpage
\ahsdfunction{sd.scantable.convert\_pol}{sd.scantable.convert_pol}{Convert data to a different polarization type}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

    Convert the data to a different polarisation type.
    Note that you will need cross-polarisation terms for most conversions.

    The poltype argument specifies the new polarization type. Valid types are: 
    'linear', 'circular', 'stokes', and 'linpol'.
 
\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
poltype && \multicolumn{2}{p{3.36in}|}{The new polarization type}\\
& &allowed: & string \\
& &Default: & None
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline
scantable

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.scantable.copy
\newpage
\ahfunction{sd.scantable.copy}{Return a copy of this scantable}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

    Return a copy of this scantable.

    Note that this makes a full (deep) copy. scan2 = scan1 makes a reference.
 
\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\flushleft\vspace{.20in}\textbf {Returns}\newline
scantable

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\

\begin{verbatim}
   s=sd.scantable('OrionS_rawACSmod_cal',average=True)
   # deep copy
   copiedscan=s.copy()
   # this makes a reference
   s2=s
\end{verbatim}



%% sd.scantable.create_mask
\newpage
\ahsdfunction{sd.scantable.create\_mask}{sd.scantable.create_mask}{Return a bool array based on [min,max] windows}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

    Compute and return a mask based on [min, max] windows.
    The specified windows are to be INCLUDED, when the mask is
    applied.

    The mask window should be given as a pairs of start/end points, e.g. [min, max], [min2, max2], ...
    If the invert argument specified as True, return an inverted mask, i.e. the regions
    specified are EXCLUDED.
    The mask is created using the specified row for unit conversions. This is only necessary if frequency 
    varies over rows.
 
\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
 && \multicolumn{2}{p{3.36in}|}{Pairs of start/end points}\\
& &allowed: & list or sequence of lists \\
& &Default: & 
\\
invert && \multicolumn{2}{p{3.36in}|}{Determine the operation is inclusive or exclusive}\\
& &allowed: & bool \\
& &Default: & False (inclusive)
\\
row && \multicolumn{2}{p{3.36in}|}{create the mask using the specified row for unit conversions}\\
& &allowed: & integer \\
& &Default: & 0
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline
bool array

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\

\begin{verbatim}
        scan = sd.scantable('OrionS_rawACSmod_cal',average=True)
        scan.set_unit('channel')
        # a)
        msk = scan.create_mask([400, 500], [800, 900])
        # masks everything outside 400 and 500
        # and 800 and 900 in the unit 'channel'
    
        # b)
        msk = scan.create_mask([400, 500], [800, 900], invert=True)
        # masks the regions between 400 and 500
        # and 800 and 900 in the unit 'channel'
    
        # c)
        #mask only channel 400
        msk =  scan.create_mask([400])
\end{verbatim}


%% sd.scantable.cspline_baseline
\newpage
\ahsdfunction{sd.scantable.cspline\_baseline}{sd.scantable.cspline_baseline}{Perform a baseline subtraction using cubic spline function}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

    Return a scan which has been baselined (all rows) by cubic spline
    function (piecewise cubic polynomial). Fit will be done with 'sigma-clipping'.

    Note:
        The best-fit parameter values output in logger and/or blfile are now
        based on specunit of 'channel'. 
 
\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
insitu && \multicolumn{2}{p{3.36in}|}{If False a new scantable is returned}\\
& &allowed: bool &  \\
& &Default: None (use default value) & 
\\
mask && \multicolumn{2}{p{3.36in}|}{An optional mask retreived from scantable}\\
& &allowed: & bool \\
& &Default: & None (no mask)
\\
npiece && \multicolumn{2}{p{3.36in}|}{Number of pieces}\\
& &allowed: & integer \\
& &Default: & 2
\\
clipthresh && \multicolumn{2}{p{3.36in}|}{Clipping threshold in unit of sigma}\\
& &allowed: & float \\
& &Default: & 3.0
\\
clipniter && \multicolumn{2}{p{3.36in}|}{Maximum number of iteration of clipping}\\
& &allowed: & integer \\
& &Default: & 0
\\
plot && \multicolumn{2}{p{3.36in}|}{Plot the fit and the residual (currently unavailable)}\\
& &allowed: & bool \\
& &Default: & False
\\
getresidual && \multicolumn{2}{p{3.36in}|}{If False, return best-fit value instead of residual}\\
& &allowed: & bool \\
& &Default: & True 
\\
showprogress && \multicolumn{2}{p{3.36in}|}{Show progress status for large data}\\
& &allowed: & bool \\
& &Default: & True 
\\
minnrow && \multicolumn{2}{p{3.36in}|}{Minimum number of spectra to show progress status}\\
& &allowed: & integer \\
& &Default: & 1000
\\
outlog && \multicolumn{2}{p{3.36in}|}{Output the coefficients of the best-fit function to logger}\\
& &allowed: & bool \\
& &Default: & False
\\
blfile && \multicolumn{2}{p{3.36in}|}{Name of text file in which the best-fit parameter values to be written}\\
& &allowed: & string \\
& &Default: & '' 
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline
scantable

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\

\begin{verbatim}
        scan = sd.scantable('OrionS_rawACSmod_cal',average=False)
        # return a scan baselined by a cubic spline consisting of 2 pieces (i.e., 1 internal knot),
        # also with 3-sigma clipping, iteration up to 4 times
        bscan = scan.cspline_baseline(npiece=2,clipthresh=3.0,clipniter=4)
\end{verbatim}


%% sd.scantable.drop_scan
\newpage
\ahsdfunction{sd.scantable.drop\_scan}{sd.scantable.drop_scan}{Return a new scantable where the specified scan number(s) are dropped}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

    Return a new scantable where the specified scan number(s) has(have)
    been dropped.

    It always returns a new scantable regardless of sd.rcParams['insitu'].
 
\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
scanid && \multicolumn{2}{p{3.36in}|}{A (list of) scan number(s)}\\
& &allowed: & integer, integer array \\
& &Default: & None
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline
scantable

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.scantable.fft
\newpage
\ahfunction{sd.scantable.fft}{Apply FFT to the spectra}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

    Apply FFT to the spectra.

    Flagged data in the scantable get interpolated over the region.
    An optional channel mask specified by mask parameter is applied to 
    all specified rows if it is given as one dimensional array.

    It returns a list of dictionaries containing the results for 
    each spectrum.
    Each dictionary contains two values, the real and the imaginary 
    parts when getrealimag = True, or the amplitude(absolute value)
    and the phase(argument) when getrealimag = False. The key for
    these values are 'real' and 'imag', or 'ampl' and 'phase',
    respectively.

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
rowno && \multicolumn{2}{p{3.36in}|}{Row number(s) to be processed.}\\
& &allowed: & integet, integer list or tuple \\
& &Default: & [] (apply to whole data)
\\
mask && \multicolumn{2}{p{3.36in}|}{An optional channel mask}\\
& &allowed: & bool array \\
& &Default: & [] 
\\
getrealimag && \multicolumn{2}{p{3.36in}|}{If True, return real and imaginary part instead of amplitude and phase}\\
& &allowed: & bool \\
& &Default: & False (return amplitude and phase)
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline
dictionary

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.scantable.flag
\newpage
\ahfunction{sd.scantable.flag}{Flag selected data using specified mask (channel based flag)}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

    Flag the selected data using an optional channel mask. 
    The appropriate value of the mask can be created with \ahlink{create\_mask}{sd:sd.scantable.create_mask}.
    If no mask is specified, all channels are flagged/unflagged depending on the unflag argument. 

    Note that the operation will always be applied to this scantable regardless of 
    the value of sd.rcParams['insitu']. 

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
mask && \multicolumn{2}{p{3.36in}|}{An optional channel mask}\\
& &allowed: & bool array \\
& &Default: & None (all channels)
\\
unflag && \multicolumn{2}{p{3.36in}|}{If True, unflag the data}\\
& &allowed: & bool \\
& &Default: & False
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.scantable.flag_nans
\newpage
\ahsdfunction{sd.scantable.flag\_nans}{sd.scantable.flag_nans}{Flag NaN values}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

    Utility function to flag NaN values in the scantable.
 
    Note that the operation will always be applied to this scantable regardless of 
    the value of sd.rcParams['insitu']. 

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\flushleft\vspace{.20in}\textbf {Returns}\newline

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.scantable.flag_row
\newpage
\ahsdfunction{sd.scantable.flag\_row}{sd.scantable.flag_row}{Flag spectra based on specified rows (row based flag)}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

    Flag the selected data in row-based manner.
 
    Note that the operation will always be applied to this scantable regardless of 
    the value of sd.rcParams['insitu']. 

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
rows && \multicolumn{2}{p{3.36in}|}{List of row numbers to be flagged}\\
& &allowed: & integer, integer array \\
& &Default: & []
\\
unflag && \multicolumn{2}{p{3.36in}|}{If True, unflag the data}\\
& &allowed: & bool \\
& &Default: & False
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.scantable.freq_align
\newpage
\ahsdfunction{sd.scantable.freq\_align}{sd.scantable.freq_align}{Perform frequency alignment}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

    Return a scan where all rows have been aligned in frequency/velocity.
    The alignment frequency frame (e.g. LSRK) is that set by function
    \ahlink{set\_freqframe}{sd:sd.scantable.set_freqframe}.

    The reference time to align can be specified as reftime argument. By default, the 
    time of the first row of data is used.
    The method argument specifies interpolation method for regridding the spectra. 
    Valid options are 'nearest', 'linear', 'cubic' (default), and 'spline'.
 
\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
reftime && \multicolumn{2}{p{3.36in}|}{Reference time to align at.}\\
& &allowed: & string\\
& &Default: & None (use first row of data)
\\
method && \multicolumn{2}{p{3.36in}|}{Interpolation method for regridding the spectra}\\
& &allowed: & string \\
& &Default: & 'cubic'
\\
insitu && \multicolumn{2}{p{3.36in}|}{If False a new scantable is returned}\\
& &allowed: & bool \\
& &Default: & None
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline
scantable

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.scantable.freq_switch
\newpage
\ahsdfunction{sd.scantable.freq\_switch}{sd.scantable.freq_switch}{Apply frequency switching to the data}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

    Apply frequency switching to the data.
 
\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
insitu && \multicolumn{2}{p{3.36in}|}{If False a new scantable is returned}\\
& &allowed: & bool \\
& &Default: & None
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline
scantable

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.scantable.gain_el
\newpage
\ahsdfunction{sd.scantable.gain\_el}{sd.scantable.gain_el}{Apply gain-elevation correction based on user-provided correction factors}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

    Return a scan after applying a gain-elevation correction.
    The correction can be made via either a polynomial or a
    table-based interpolation (and extrapolation if necessary).
    You specify polynomial coefficients, an ascii table or neither.
    If you specify neither, then a polynomial correction will be made
    with built in coefficients known for certain telescopes (an error
    will occur if the instrument is not known).
    The data and Tsys are *divided* by the scaling factors.

    The polynomial coefficients to compute a gain-elevation correction should be given 
    as that of a function of elevation in degrees.
    Contents of the ascii table specified by filename argument is correction factors 
    as a function of time and elevation (in degree).
    The first row of the ascii file must give the column names and these MUST include columns
    "ELEVATION" (degrees) and "FACTOR" (multiply data by this) somewhere.
    The second row must give the data type of the column. Use 'R' for Real and 'I' for Integer.
    An example file would be (actual factors are arbitrary) :

    \begin{longtable}{lll}
                     TIME & ELEVATION & FACTOR \\
                     R & R & R \\
                     0.1 & 0 & 0.8 \\
                     0.2 & 20 & 0.85 \\
                     0.3 & 40 & 0.9 \\
                     0.4 & 60 & 0.85 \\
                     0.5 & 80 & 0.8 \\
                     0.6 & 90 & 0.75 \\
    \end{longtable}

    The interpolation method can be specified by method argument. Valid options are 
    'nearest', 'linear' (default), 'cubic', and 'spline'.

 
\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
poly && \multicolumn{2}{p{3.36in}|}{Polynomial coefficients to comput a gain-elevation correction}\\
& &allowed: & float array \\
& &Default: & None
\\
filename && \multicolumn{2}{p{3.36in}|}{The name of an ascii file holding correction factors}\\
& &allowed: & string \\
& &Default: & ''
\\
method && \multicolumn{2}{p{3.36in}|}{Interpolation method when correcting from a table}\\
& &allowed: & string \\
& &Default: & 'linear'
\\
insitu && \multicolumn{2}{p{3.36in}|}{If False a new scantable is returned}\\
& &allowed: & bool \\
& &Default: & None
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline
scantable

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.scantable.get_abcissa
\newpage
\ahsdfunction{sd.scantable.get\_abcissa}{sd.scantable.get_abcissa}{Get the abcissa values and format string that represents current coordinate setup}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

    Get the abcissa in the current coordinate setup for the currently
    selected Beam/IF/Pol.
    The method returns the abcissa values and the format string as a dictionary.
 
\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
rowno && \multicolumn{2}{p{3.36in}|}{An optional row number in the scantable}\\
& &allowed: & integer \\
& &Default: & 0
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline
dictionary

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.scantable.get_antennaname
\newpage
\ahsdfunction{sd.scantable.get\_antennaname}{sd.scantable.get_antennaname}{Get antenna name}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

   Return a name of antenna observed.

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\flushleft\vspace{.20in}\textbf {Returns}\newline
string

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.scantable.get_azimuth
\newpage
\ahsdfunction{sd.scantable.get\_azimuth}{sd.scantable.get_azimuth}{Get a list of azimuth during the observation}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

    Get a list of azimuths for the observations.
    Return a float for each integration in the scantable.
    The unit is radian.
 
\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
row && \multicolumn{2}{p{3.36in}|}{Row no of integration}\\
& &allowed: & integer \\
& &Default: & -1 (all rows)
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline
float, float array

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.scantable.get_column_names
\newpage
\ahsdfunction{sd.scantable.get\_column\_names}{sd.scantable.get_column_names}{Get a list of column names in the main table}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

    Return a  list of column names in the main table, which can be used for selection.
 
\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\flushleft\vspace{.20in}\textbf {Returns}\newline
string array

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.scantable.get_coordinate
\newpage
\ahsdfunction{sd.scantable.get\_coordinate}{sd.scantable.get_coordinate}{Return the spectral coordinate for a given row as a \ahlink{coordinate}{sd:sd.coordinate} object}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

    Return the (spectral) coordinate for a a given 'rowno'.

    Notes:
   
    \begin{itemize}
    \item This coordinate is only valid until a scantable method modifies the frequency axis.
    \item This coordinate does contain the original frequency set-up
          NOT the new frame. The conversions however are done using the user
          specified frame (e.g. LSRK/TOPO). To get the 'real' coordinate,
          use \ahlink{scantable.freq\_align}{sd:sd.scantable.freq_align} first. Without it there is no closure,
          i.e.:: \\
    
          \begin{verbatim}
              c = myscan.get_coordinate(0)
              c.to_frequency(c.get_reference_pixel()) != c.get_reference_value()
          \end{verbatim}
    \end{itemize}

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
rowno && \multicolumn{2}{p{3.36in}|}{The row number for the spectral coordinate}\\
& &allowed: & integer \\
& &Default: & 
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline
coordinate

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.scantable.get_direction
\newpage
\ahsdfunction{sd.scantable.get\_direction}{sd.scantable.get_direction}{Get a list of positions on the sky as a string}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

    Get a list of Positions on the sky (direction) for the observations.
    Return a string for each integration in the scantable.

    To get float value for positions, use \ahlink{get\_directionval}{sd:sd.scantable.get_directionval}.
 
\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
row && \multicolumn{2}{p{3.36in}|}{Row no of integration}\\
& &allowed: & integer \\
& &Default: & -1 (all rows)
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline
string, string array

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\

\begin{verbatim}
   s=sd.scantable('OrionS_rawACSmod_cal',average=False)
   # get_direction() returns string expression of position
   s.get_direction(0)
   '05:35:13.5 -05.24.08.2'
   # s.get_directionval() returns float value of position
   s.get_directionval(0)
   [1.4626913601468896, -0.0942875343295448]
\end{verbatim}


%% sd.scantable.get_directionval
\newpage
\ahsdfunction{sd.scantable.get\_directionval}{sd.scantable.get_directionval}{Get a list of positions on the sky as a float}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

    Get a list of Positions on the sky (direction) for the observations.
    Return a float for each integration in the scantable.
    The unit is radian.

    To get string expression for positions, use \ahlink{get\_direction}{sd:sd.scantable.get_direction}.
 
\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
row && \multicolumn{2}{p{3.36in}|}{Row no of integration}\\
& &allowed: & integer \\
& &Default: & -1 (all rows)
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline
float array

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\

\begin{verbatim}
   s=sd.scantable('OrionS_rawACSmod_cal',average=False)
   # get_direction() returns string expression of position
   s.get_direction(0)
   '05:35:13.5 -05.24.08.2'
   # s.get_directionval() returns float value of position
   s.get_directionval(0)
   [1.4626913601468896, -0.0942875343295448]
\end{verbatim}


%% sd.scantable.get_elevation
\newpage
\ahsdfunction{sd.scantable.get\_elevation}{sd.scantable.get_elevation}{Get a list of elevation during the observation}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

    Get a list of elevations for the observations.
    Return a float for each integration in the scantable.
    The unit is radian.

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
row && \multicolumn{2}{p{3.36in}|}{Row no of integration}\\
& &allowed: & integer \\
& &Default: & -1 (all rows)
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline
float, float array

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.scantable.get_fit
\newpage
\ahsdfunction{sd.scantable.get\_fit}{sd.scantable.get_fit}{Get the stored fits for a row in scantable}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

    Print or return the stored fits for a row in the scantable
 
\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
row && \multicolumn{2}{p{3.36in}|}{The row which the fit has been applied to}\\
& &allowed: & integer \\
& &Default: & 0
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline
dictionary

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.scantable.get_fluxunit
\newpage
\ahsdfunction{sd.scantable.get\_fluxunit}{sd.scantable.get_fluxunit}{Get a flux unit}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

   Return a flux unit string.

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\flushleft\vspace{.20in}\textbf {Returns}\newline
string

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.scantable.get_inttime
\newpage
\ahsdfunction{sd.scantable.get\_inttime}{sd.scantable.get_inttime}{Get a list of integration times for the observation}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

    Get a list of integration times for the observations.
    Return a time in seconds for each integration in the scantable.
 
\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
row && \multicolumn{2}{p{3.36in}|}{The row which the fit has been applied to}\\
& &allowed: & integer \\
& &Default: & -1 (all rows)
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline
float, float array

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.scantable.get_mask
\newpage
\ahsdfunction{sd.scantable.get\_mask}{sd.scantable.get_mask}{Get mask for the specified row as a bool list}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

    Return the mask for the current row in the scantable as a list.
 
\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
rowno && \multicolumn{2}{p{3.36in}|}{The row number to retrieve the mask from}\\
& &allowed: & integer \\
& &Default: & 
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline
bool array

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.scantable.get_mask_indices
\newpage
\ahsdfunction{sd.scantable.get\_mask\_indices}{sd.scantable.get_mask_indices}{Compute and return lists of mask start indices and mask end indices from the given bool array}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

    Compute and Return lists of mask start indices and mask end indices.
    Returned value is a list of mask start indices and that of mask end indices,
    i.e., ([istart1,istart2,....], [iend1,iend2,....]).
 
\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
mask && \multicolumn{2}{p{3.36in}|}{Channel mask, created with create\_mask}\\
& &allowed: & bool array \\
& &Default: & None
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline
integer array

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\

\begin{verbatim}
   s=sd.scantable('OrionS_rawACSmod_cal',average=False)
   # this is an example to show how get_mask_indices() works
   s.get_mask_indices(s.create_mask([1000,2000],[4000,5000]))
   ([1000, 4000], [2000, 5000])
\end{verbatim}


%% sd.scantable.get_masklist
\newpage
\ahsdfunction{sd.scantable.get\_masklist}{sd.scantable.get_masklist}{Compute and return a list of mask windows [min,max] from the given bool array}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

    Compute and return a list of mask windows, [min, max].
    Returned value is pairs of start/end points (inclusive) specifying the masked regions, 
    i.e. [min, max], [min2, max2], ...
 
    The row argument specifies the row to use for unit conversions, default is row=0.
    It is only necessary if frequency varies over rows.

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
mask && \multicolumn{2}{p{3.36in}|}{Channel mask, created with create\_mask}\\
& &allowed: & bool array \\
& &Default: & None
\\
row && \multicolumn{2}{p{3.36in}|}{calculate the masklist using the specified row for unit conversion}\\
& &allowed: & integer \\
& &Default: & 0
\\
silent && \multicolumn{2}{p{3.36in}|}{True for silent mode}\\
& &allowed: & bool \\
& &Default: & False
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline
float array

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\

\begin{verbatim}
   s=sd.scantable('OrionS_rawACSmod_cal',average=False)
   # this is an example to show how get_masklist() works
   s.get_masklist(s.create_mask([1000,2000],[4000,5000]))
   ([1000.0, 2000.0], [4000.0, 5000.0])
\end{verbatim}


%% sd.scantable.get_parangle
\newpage
\ahsdfunction{sd.scantable.get\_parangle}{sd.scantable.get_parangle}{Get a list of parallactic angles for the observation}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

    Get a list of parallactic angles for the observations.
    Return a float for each integration in the scantable.
 
\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
row && \multicolumn{2}{p{3.36in}|}{Row no of integration}\\
& &allowed: & integer \\
& &Default: & -1 (all rows)
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline
float, float array

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.scantable.get_restfreqs
\newpage
\ahsdfunction{sd.scantable.get\_restfreqs}{sd.scantable.get_restfreqs}{Get the rest frequency(s) stored in the scantable}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

    Get the restfrequency(s) stored in this scantable.
    The return value(s) are always of unit 'Hz'
    The method returns a dictionary containing ids and a list of doubles for each id.

    The rest frequency is stored in MOLECULES subtable of the scantable. 
    Rows in MOLECULES subtable is referred from main table by MOLECULE\_ID.
    You can specify a list of that id using ids argument to retrieve particular rest frequency(s). 

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
ids && \multicolumn{2}{p{3.36in}|}{A list of MOLECULE\_ID for that rest frequency(s) to be retrieved}\\
& &allowed: & integer \\
& &Default: & None (retrieve all)
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline
dictionary

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.scantable.get_rms
\newpage
\ahsdfunction{sd.scantable.get\_rms}{sd.scantable.get_rms}{Calculate rms of the spectrum}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

   Calculate rms of the spectrum. Mask can be specified.

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
mask && \multicolumn{2}{p{3.36in}|}{Optional mask for calculation}\\
& &allowed: & bool array \\
& &Default: & 
\\
whichrow && \multicolumn{2}{p{3.36in}|}{Row number to be processed}\\
& &allowed: & int \\
& &Default: & 
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline
float

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.scantable.get_row
\newpage
\ahsdfunction{sd.scantable.get\_row}{sd.scantable.get_row}{Return a scantable with single row}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

    Select a row in the scantable.
    Return a scantable with single row.
 
    If insitu is True, or insitu is None and sd.rcParams['insitu'] is True, 
    the method will not return the result, but apply operation on this scantable. 

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
row && \multicolumn{2}{p{3.36in}|}{Row no of integration}\\
& &allowed: & integer \\
& &Default: & 0
\\
insitu && \multicolumn{2}{p{3.36in}|}{If False a new scantable is returned}\\
& &allowed: & bool \\
& &Default: & None
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline
scantable

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.scantable.get_row_selector
\newpage
\ahsdfunction{sd.scantable.get\_row\_selector}{sd.scantable.get_row_selector}{Return a \ahlink{selector}{sd:sd.selector} object that only selects target row}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

   Return a \ahlink{selector}{sd:sd.selector} object that only selects target row.

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
rowno && \multicolumn{2}{p{3.36in}|}{The row number to select}\\
& &allowed: & integer \\
& &Default: & 
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline
selector

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.scantable.get_scan
\newpage
\ahsdfunction{sd.scantable.get\_scan}{sd.scantable.get_scan}{Return a specified scan(s) specified by scan number or source name as a new scantable}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

    Return a specific scan (by scanno) or collection of scans (by
    source name) in a new scantable.
    In both case, you can set selection criteria to scanid argument.
    For source name, unix-style patterns are accepted for source name matching, e.g.
    '*\_R' gets all 'ref scans.


    Note that \ahlink{drop\_scan}{sd:sd.scantable.drop_scan} is an inverse operation.
 
\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
scanid && \multicolumn{2}{p{3.36in}|}{A (list of) scanno or a source name}\\
& &allowed: & integer, integer array, string \\
& &Default: & None
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline
scantable

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\

\begin{verbatim}
        scan=sd.scantable('data.asap')
        # get all scans containing the source '323p459'
        newscan = scan.get_scan('323p459')
        # get all 'off' scans
        refscans = scan.get_scan('*_R')
        # get a susbset of scans by scanno (as listed in scan.summary())
        newscan = scan.get_scan([0, 2, 7, 10])
\end{verbatim}


%% sd.scantable.get_selection
\newpage
\ahsdfunction{sd.scantable.get\_selection}{sd.scantable.get_selection}{Get current selection that is currently set on this scantable}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

    Get the selection object currently set on this scantable.
 
\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\flushleft\vspace{.20in}\textbf {Returns}\newline
selector

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\

\begin{verbatim}
        scan = sd.scantable('OrionS_rawACSmod')
        sel = scan.get_selection()
        sel.set_ifs(0)              # select IF 0
        scan.set_selection(sel)     # apply modified selection
\end{verbatim}


%% sd.scantable.get_sourcename
\newpage
\ahsdfunction{sd.scantable.get\_sourcename}{sd.scantable.get_sourcename}{Get a list of source names for the observation}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

    Get a list source names for the observations.
    Return a string for each integration in the scantable.
 
\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
row && \multicolumn{2}{p{3.36in}|}{Row no of integration}\\
& &allowed: & integer \\
& &Default: & -1 (all rows)
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline
string, string array

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.scantable.get_spectrum
\newpage
\ahsdfunction{sd.scantable.get\_spectrum}{sd.scantable.get_spectrum}{Get the spectrum for the current row}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

   Return  the spectrum for the current row in the scantable as a list.
    

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
rowno && \multicolumn{2}{p{3.36in}|}{The row number to retrieve the spectrum from}\\
& &allowed: & integer \\
& &Default: & 
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline
float array

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.scantable.get_time
\newpage
\ahsdfunction{sd.scantable.get\_time}{sd.scantable.get_time}{Get a list of time stamps for the observation}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

    Get a list of time stamps for the observations.
    Return a datetime object or a string (default) for each integration time stamp in the scantable.
 
\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
row && \multicolumn{2}{p{3.36in}|}{Row no of integration}\\
& &allowed: & integer \\
& &Default: & -1 (all rows)
\\
asdatetime && \multicolumn{2}{p{3.36in}|}{Return values as datetime objects rather than strings}\\
& &allowed: & bool \\
& &Default: & False
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline
string, datetime, their array

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.scantable.get_tsys
\newpage
\ahsdfunction{sd.scantable.get\_tsys}{sd.scantable.get_tsys}{Get a list of system temperatures}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

    Return the System temperatures.
 
\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
row && \multicolumn{2}{p{3.36in}|}{The rowno to get the information for}\\
& &allowed: & integer \\
& &Default: & -1 (all rows)
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline
float array

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.scantable.get_unit
\newpage
\ahsdfunction{sd.scantable.get\_unit}{sd.scantable.get_unit}{Get the default unit of spectral axis}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

    Get the default unit set for spectral axis in this scantable
 
\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\flushleft\vspace{.20in}\textbf {Returns}\newline
string

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.scantable.get_weather
\newpage
\ahsdfunction{sd.scantable.get\_weather}{sd.scantable.get_weather}{Get the weather informations}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

    Return the weather informations.

    The contents of returned dictionary is as follows:

    \begin{longtable}{rl}
    humidity: & relative humidity \\
    pressure: & atmospheric pressure \\
    temperature: & atmospheric temperature \\
    windaz: & wind direction in radian \\
    windspeed: & wind speed in m/s \\
    \end{longtable}
 
\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
row && \multicolumn{2}{p{3.36in}|}{The rowno to get the information for}\\
& &allowed: & integer \\
& &Default: & -1 (all rows)
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline
dictionary, dictionary array

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.scantable.getbeam
\newpage
\ahfunction{sd.scantable.getbeam}{Get beam number of the given row}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

   Return a beam number for the given row.

   

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
 && \multicolumn{2}{p{3.36in}|}{The rowno to get the information for}\\
& &allowed: & integer \\
& &Default: & 
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline
integer

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\

\begin{verbatim}
        scan = sd.scantable('OrionS_rawACSmod')
        beam = scan.getbeam(0) # get beam number for the first row
\end{verbatim}


%% sd.scantable.getbeamnos
\newpage
\ahfunction{sd.scantable.getbeamnos}{Get a list of beam numbers in the scantable}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

   Return a list of beam numbers in the scantable.

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\flushleft\vspace{.20in}\textbf {Returns}\newline
integer array

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.scantable.getcycle
\newpage
\ahfunction{sd.scantable.getcycle}{Get cycle number of the given row}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

   Return a cycle number for the given row.

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
 && \multicolumn{2}{p{3.36in}|}{The rowno to get the information for}\\
& &allowed: & integer \\
& &Default: & 
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline
integer

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\

\begin{verbatim}
        scan = sd.scantable('OrionS_rawACSmod')
        cycle = scan.getcycle(0) # get cycle number for the first row
\end{verbatim}


%% sd.scantable.getif
\newpage
\ahfunction{sd.scantable.getif}{Get IF number of the given row}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

   Return a IF number for the given row.

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
 && \multicolumn{2}{p{3.36in}|}{The rowno to get the information for}\\
& &allowed: & integer \\
& &Default: & 
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline
integer

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\

\begin{verbatim}
        scan = sd.scantable('OrionS_rawACSmod')
        ifno = scan.getifs(0) # get IF number for the first row
\end{verbatim}


%% sd.scantable.getifnos
\newpage
\ahfunction{sd.scantable.getifnos}{Get a list of IF nubers in the scantable}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

   Return a list of IF numbers in the scantable.

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\flushleft\vspace{.20in}\textbf {Returns}\newline
integer array

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.scantable.getmolnos
\newpage
\ahfunction{sd.scantable.getmolnos}{Get a list of molecule ids in the scantable}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

   Return a list of molecule ids in the scantable.

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\flushleft\vspace{.20in}\textbf {Returns}\newline
integer array

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.scantable.getpol
\newpage
\ahfunction{sd.scantable.getpol}{Get polarization number of the given row}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

   Return a polarization number for the given row.

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
 && \multicolumn{2}{p{3.36in}|}{The rowno to get the information for}\\
& &allowed: & integer \\
& &Default: & 
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline
integer 

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\

\begin{verbatim}
        scan = sd.scantable('OrionS_rawACSmod')
        polno = scan.getpol(0) # get polarization number for the first row
\end{verbatim}


%% sd.scantable.getpolnos
\newpage
\ahfunction{sd.scantable.getpolnos}{Get a list of polarization numbers in the scantable}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

   Return a list of polarization numbers in the scantable.

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\flushleft\vspace{.20in}\textbf {Returns}\newline
integer array

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.scantable.getscan
\newpage
\ahfunction{sd.scantable.getscan}{Get scan number of the given row }

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

   Return a scan number for the given row.

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
 && \multicolumn{2}{p{3.36in}|}{The rowno to get the information for}\\
& &allowed: & integer \\
& &Default: & 
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline
integer 

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\

\begin{verbatim}
        scan = sd.scantable('OrionS_rawACSmod')
        scanno = scan.getscan(0) # get scan number for the first row
\end{verbatim}


%% sd.scantable.getscannos
\newpage
\ahfunction{sd.scantable.getscannos}{Get a list of scan numbers in the scantable}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

   Return a list of scan numbers in the scantable.

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\flushleft\vspace{.20in}\textbf {Returns}\newline
integer array

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.scantable.history
\newpage
\ahfunction{sd.scantable.history}{Print a history}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

    Print the history. Optionally to a file.
 
\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
filename && \multicolumn{2}{p{3.36in}|}{The name of the file to save the history to}\\
& &allowed: & string \\
& &Default: & None
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline
string

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.scantable.invert_phase
\newpage
\ahsdfunction{sd.scantable.invert\_phase}{sd.scantable.invert_phase}{Invert the phase of the complex polarization}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

    Invert the phase of the complex polarisation.
 
\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\flushleft\vspace{.20in}\textbf {Returns}\newline

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.scantable.lag_flag
\newpage
\ahsdfunction{sd.scantable.lag\_flag}{sd.scantable.lag_flag}{Perform Fourier filtering on the spectra}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

    Flag the data in 'lag' space by providing a frequency to remove.
    Flagged data in the scantable gets interpolated over the region.
    No taper is applied.

    If insitu is True, or insitu is None and sd.rcParams['insitu'] is True, 
    the method will not return the result, but apply operation on this scantable. 

    It is recommended to flag edges of the band or strong signals beforehand.
 
\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
start && \multicolumn{2}{p{3.36in}|}{The start frequency (really a period within the bandwidth) or period to remove}\\
& &allowed: & float \\
& &Default: & 
\\
end && \multicolumn{2}{p{3.36in}|}{The end frequency or period to remove}\\
& &allowed: & string \\
& &Default: & None
\\
unit && \multicolumn{2}{p{3.36in}|}{The frequency unit or '' for explicit lag channels}\\
& &allowed: & string \\
& &Default: & 'MHz'
\\
insitu && \multicolumn{2}{p{3.36in}|}{If False a new scantable is returned}\\
& &allowed: & bool \\
& &Default: & None
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline
scantable

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.scantable.mx_quotient
\newpage
\ahsdfunction{sd.scantable.mx\_quotient}{sd.scantable.mx_quotient}{Form a quotient using "off" beams when observing in "MX" mode}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

    Form a quotient using "off" beams when observing in "MX" mode.
 
    The formula to get result depends on the preserve paramter. If it is True, the continuum will be 
    preserved while if it is False, the continuum will be removed. The equation used are

    \begin{displaymath}
    T_{\rm a}^* = T_{\rm sys}^{\rm OFF} { ON \over OFF } - T_{\rm sys}^{\rm OFF},
    \end{displaymath}
   
    if preserve is True, while

    \begin{displaymath}
    T_{\rm a}^* = T_{\rm sys}^{\rm OFF} { ON \over OFF } - T_{\rm sys}^{\rm ON},
    \end{displaymath}

    if preserve is False.

    The weight argument is used for time averaging off beams. You can set any options same as 
    \ahlink{average\_time}{sd:sd.scantable.average_time}.

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
mask && \multicolumn{2}{p{3.36in}|}{An optional mask to be used when weight == 'stddev'}\\
& &allowed: & bool array \\
& &Default: & None
\\
weight && \multicolumn{2}{p{3.36in}|}{How to average the off beams}\\
& &allowed: & string \\
& &Default: & 'median'
\\
preserve && \multicolumn{2}{p{3.36in}|}{Preserve the continuum or remove it}\\
& &allowed: & bool  \\
& &Default: & True
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline
scantable

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.scantable.nbeam
\newpage
\ahfunction{sd.scantable.nbeam}{Return a number of beams}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

   Return a number of beams in this scantable.

   If scanno argument is specified, the number of beams for that scan will be returned.
   Otherwise, the total number of beams, which is written in the header of the data, will be returned.

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
scanno && \multicolumn{2}{p{3.36in}|}{Scan number}\\
& &allowed: & integer  \\
& &Default: & -1 (total)
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline
integer

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.scantable.nchan
\newpage
\ahfunction{sd.scantable.nchan}{Return a number of channels}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

   Return a number of channels in this scantable.

   If ifno argument is specified, the number of channels for that IF will be returned.
   Otherwise, the maximum number of channels, which is written in the header of the data, will be returned.

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
ifno && \multicolumn{2}{p{3.36in}|}{IF number}\\
& &allowed: & integer \\
& &Default: & -1 (maximum)
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline
integer 

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.scantable.ncycle
\newpage
\ahfunction{sd.scantable.ncycle}{Return a number of cycles}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

   Return a number of cycles in this scantable.

   If scanno argument is specified, the number of cycles for that scan will be returned.
   Otherwise, the total number of cycles will be returned.

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
scanno && \multicolumn{2}{p{3.36in}|}{Scan number}\\
& &allowed: & integer \\
& &Default: & -1 (total)
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline
integer

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.scantable.nif
\newpage
\ahfunction{sd.scantable.nif}{Return a number of IFs}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

   Return a number of IFs in this scantable.

   If scanno argument is specified, the number of IFs for that scan will be returned.
   Otherwise, the total number of IFs, which is written in the header of the data, will be returned.

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
scanno && \multicolumn{2}{p{3.36in}|}{Scan number}\\
& &allowed: & integer \\
& &Default: & -1 (total)
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline
integer

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.scantable.npol
\newpage
\ahfunction{sd.scantable.npol}{Return a number of polarizations}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

   Return a number of polarizations in this scantable.

   If scanno argument is specified, the number of polarizations for that scan will be returned.
   Otherwise, the total number of polarizations, which is written in the header of the data, will be returned.

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
scanno && \multicolumn{2}{p{3.36in}|}{Scan number}\\
& &allowed: & integer \\
& &Default: & -1 (total)
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline
integer

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.scantable.nrow
\newpage
\ahfunction{sd.scantable.nrow}{Return a number of rows}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

   Return a total number of rows (= total number of spectra) in this scantable.

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\flushleft\vspace{.20in}\textbf {Returns}\newline
integer

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.scantable.nscan
\newpage
\ahfunction{sd.scantable.nscan}{Return a number of scans}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

   Return a total number of scans in this scantable.

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\flushleft\vspace{.20in}\textbf {Returns}\newline
integer

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\



%% sd.scantable.opacity
\newpage
\ahfunction{sd.scantable.opacity}{Apply an opacity correction}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

    Apply an opacity correction. The data
    and Tsys are multiplied by the correction factor.

    Correction includes an elevation dependence of the opacity.
    Actual correction factor is $\exp(\tau * {\rm ZD})$, where ZD is the zenith-distance and $\tau$ is a value 
    given as the tau argument. 
    If a list of opacities is provided, it has to be of length nIF, nIF*nPol or 1 and in order of IF/POL, e.g.
    [opif0pol0, opif0pol1, opif1pol0 ...]. If tau is `None` the opacities are determined from a model.
 
    If insitu is True, or insitu is None and sd.rcParams['insitu'] is True, 
    the method will not return the result, but apply operation on this scantable. 

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
tau && \multicolumn{2}{p{3.36in}|}{A (list of) opacity}\\
& &allowed: & float, float array \\
& &Default: & None
\\
insitu && \multicolumn{2}{p{3.36in}|}{If False a new scantable is returned}\\
& &allowed: & bool \\
& &Default: & None
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline
scantable

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.scantable.parallactify
\newpage
\ahfunction{sd.scantable.parallactify}{Set a flag to indicate the data should be treated as "parallactified"}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

    Set a flag to indicate whether this data should be treated as having
    been 'parallactified' (total phase == 0.0)
 
\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
pflag && \multicolumn{2}{p{3.36in}|}{Bool indicating whether to turn this on (True) or off (False)}\\
& &allowed: & bool \\
& &Default: & 
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.scantable.poltype
\newpage
\ahfunction{sd.scantable.poltype}{Get a plarization type}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

   Return a polarization type in this scantable.

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\flushleft\vspace{.20in}\textbf {Returns}\newline
string

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.scantable.poly_baseline
\newpage
\ahsdfunction{sd.scantable.poly\_baseline}{sd.scantable.poly_baseline}{Perform a baseline subtraction using polynomial function}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

    Return a scan which has been baselined (all rows) by a polynomial.
 
    If insitu is True, or insitu is None and sd.rcParams['insitu'] is True, 
    the method will not return the result, but apply operation on this scantable. 

    You can verify and decide whether you apply the fit result or not, if plot argument is True.
    In that case, you have to answer 'y' or 'n' for each spectra so that setting True is not 
    recommended for large dataset.

    This is an newer version of \ahlink{old\_poly\_baseline}{sd:sd.scantable.old_poly_baseline}. 
    The only difference between them is its performance. For larger dataset, 
    it is recommended to use this method.
 
\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
mask && \multicolumn{2}{p{3.36in}|}{An optional mask}\\
& &allowed: & bool array \\
& &Default: & None
\\
order && \multicolumn{2}{p{3.36in}|}{The order of the polynomial}\\
& &allowed: & integer \\
& &Default: & 0
\\
insitu && \multicolumn{2}{p{3.36in}|}{If False a new scantable is returned}\\
& &allowed: & bool \\
& &Default: & None (use default value)
\\
plot && \multicolumn{2}{p{3.36in}|}{Plot the fit and the residual}\\
& &allowed: & bool \\
& &Default: & False
\\
getresidual && \multicolumn{2}{p{3.36in}|}{If False, return best-fit value instead of residual}\\
& &allowed: & bool \\
& &Default: & True 
\\
showprogress && \multicolumn{2}{p{3.36in}|}{Show progress status for large data}\\
& &allowed: & bool \\
& &Default: & True 
\\
minnrow && \multicolumn{2}{p{3.36in}|}{Minimum number of spectra to show progress status}\\
& &allowed: & integer \\
& &Default: & 1000
\\
outlog && \multicolumn{2}{p{3.36in}|}{Output the coefficients of the best-fit function to logger}\\
& &allowed: & bool \\
& &Default: & False
\\
blfile && \multicolumn{2}{p{3.36in}|}{Name of text file in which the best-fit parameter values to be written}\\
& &allowed: & string \\
& &Default: & '' 
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline
scantable

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\

\begin{verbatim}
        scan = sd.scantable('OrionS_rawACSmod_cal')
        # return a scan baselined by a third order polynomial,
        # not using a mask
        bscan = scan.poly_baseline(order=3)
\end{verbatim}


%% sd.scantable.recalc_azel
\newpage
\ahsdfunction{sd.scantable.recalc\_azel}{sd.scantable.recalc_azel}{Recalculate azimuth and elevation for each sky position}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

    Recalculate the azimuth and elevation for each position.

    Note that the operation will always be applied to this scantable regardless of 
    the value of sd.rcParams['insitu']. 

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\flushleft\vspace{.20in}\textbf {Returns}\newline

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.scantable.resample
\newpage
\ahfunction{sd.scantable.resample}{Perform a binning}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

    Return a scan where all spectra have been binned up.

    The method argument specifies interpolation method when correcting from a table.
    Values are 'nearest', 'linear', 'cubic' (default), and 'spline'.

    If insitu is True, or insitu is None and sd.rcParams['insitu'] is True, 
    the method will not return the result, but apply operation on this scantable. 


\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
width && \multicolumn{2}{p{3.36in}|}{The bin width in pixels}\\
& &allowed: & integer \\
& &Default: & 5
\\
method && \multicolumn{2}{p{3.36in}|}{Interpolation method when correcting from a table}\\
& &allowed: & string \\
& &Default: & 'cubic'
\\
insitu && \multicolumn{2}{p{3.36in}|}{If False a new scantable is returned}\\
& &allowed: & bool \\
& &Default: & None
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline
scantable

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.scantable.rotate_linpolphase
\newpage
\ahsdfunction{sd.scantable.rotate\_linpolphase}{sd.scantable.rotate_linpolphase}{Rotate a phase of the complex polarization}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

    Rotate the phase of the complex polarization O=Q+iU correlation.
    This is always done in situ in the raw data.  So if you call this
    function more than once then each call rotates the phase further.
 
\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
angle && \multicolumn{2}{p{3.36in}|}{The angle (in dgree) to rotate (add) by}\\
& &allowed: & float \\
& &Default: &
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\

\begin{verbatim}
        scan = sd.scantable('OrionS_rawACSmod_cal')
        scan.rotate_linpolphase(2.3)
\end{verbatim}



%% sd.scantable.rotate_xyphase
\newpage
\ahsdfunction{sd.scantable.rotate\_xyphase}{sd.scantable.rotate_xyphase}{Rotate a phase of the XY correlation}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

    Rotate the phase of the XY correlation.  This is always done in situ
    in the data.  So if you call this function more than once
    then each call rotates the phase further.
    
 
\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
angle && \multicolumn{2}{p{3.36in}|}{The angle (in dgree) to rotate (add) by}\\
& &allowed: & float \\
& &Default: &
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\

\begin{verbatim}
        scan = sd.scantable('OrionS_rawACSmod_cal')
        scan.rotate_xyphase(2.3)
\end{verbatim}



%% sd.scantable.save
\newpage
\ahfunction{sd.scantable.save}{Store the scantable on disk}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

    Store the scantable on disk. This can be an asap (\casa\ Table),
    SDFITS or MS2 format.

    The output filename can be specified as name. For format 'ASCII', this is the root file name 
    (data in 'name'.txt and header in 'name'\_header.txt). If no name is given, the default name 
    will be used.
    The format is optinal file format. Default is 'ASAP'. Allows are:

    \begin{itemize}
    \item 'ASAP' (save as ASAP [\casa\ Table])
    \item 'SDFITS' (save as SDFITS file)
    \item 'ASCII' (saves as ascii text file)
    \item 'MS2' (saves as an casacore MeasurementSet V2)
    \item 'FITS' (save as image FITS - not readable by class)
    \item 'CLASS' (save as FITS readable by CLASS)
    \end{itemize}

    If overwrite argument is True, the file should be overwritten if it exists.
    The default False is to return with warning without writing the output. USE WITH CARE.
 
\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
name && \multicolumn{2}{p{3.36in}|}{The name of the output file}\\
& &allowed: & string \\
& &Default: & None
\\
format && \multicolumn{2}{p{3.36in}|}{An optional file format}\\
& &allowed: & string \\
& &Default: & None
\\
overwrite && \multicolumn{2}{p{3.36in}|}{Overwrite existing file}\\
& &allowed: & bool \\
& &Default: & False
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\

\begin{verbatim}
        scan = sd.scantable('OrionS_rawACSmod_cal')
        scan.save('myscan.asap')
        scan.save('myscan.sdfits', 'SDFITS')
\end{verbatim}


%% sd.scantable.scale
\newpage
\ahfunction{sd.scantable.scale}{Scale spectra by the given factor}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

    Return a scan where all spectra are scaled by the given 'factor'.
    The factor can be a float or one- or two-dimensional float array. 
    If it is one-dimensional array, the scaling will be done in channel-by-channel manner.
    If it is two-dimensional, the scaling will be done in element-by-element or row-by-row manner. 
 
    If insitu is True, or insitu is None and sd.rcParams['insitu'] is True, 
    the method will not return the result, but apply operation on this scantable. 

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
factor && \multicolumn{2}{p{3.36in}|}{The scaling factor}\\
& &allowed: & float, float array\\
& &Default: & 
\\
insitu && \multicolumn{2}{p{3.36in}|}{If False a new scantable is returned}\\
& &allowed: & bool \\
& &Default: & None
\\
tsys && \multicolumn{2}{p{3.36in}|}{If True then apply the operation to Tsys as well as the data}\\
& &allowed: & bool \\
& &Default: & True
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline
scantable

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.scantable.set_dirframe
\newpage
\ahsdfunction{sd.scantable.set\_dirframe}{sd.scantable.set_dirframe}{Set the frame type of the direction on the sky}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

    Set the frame type of the Direction on the sky.
    The valid frames are 'J2000', 'B1950', 'GALACTIC'.
 
\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
frame && \multicolumn{2}{p{3.36in}|}{An optional frame type}\\
& &allowed: & string \\
& &Default: & '' 
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\

\begin{verbatim}
        scan = sd.scantable('OrionS_rawACSmod_cal')
        scan.set_dirframe('GALAGTIC')
\end{verbatim}


%% sd.scantable.set_doppler
\newpage
\ahsdfunction{sd.scantable.set\_doppler}{sd.scantable.set_doppler}{Set definition of the Doppler correction}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

    Set the doppler for all following operations on this scantable.
 
\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
doppler && \multicolumn{2}{p{3.36in}|}{One of 'RADIO', 'OPTICAL', 'Z', 'BETA', 'GAMMA'}\\
& &allowed: & string \\
& &Default: & 'RADIO' 
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.scantable.set_feedtype
\newpage
\ahsdfunction{sd.scantable.set\_feedtype}{sd.scantable.set_feedtype}{Set the feed type}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

    Overwrite the feed type, which might not be set correctly.
 
\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
feedtype && \multicolumn{2}{p{3.36in}|}{'linear' or 'circular'}\\
& &allowed: & string \\
& &Default: & 
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\



%% sd.scantable.set_fluxunit
\newpage
\ahsdfunction{sd.scantable.set\_fluxunit}{sd.scantable.set_fluxunit}{Set flux unit}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

   Set flux unit to this scantable. Valid values are 'K' and 'Jy'.

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
 && \multicolumn{2}{p{3.36in}|}{'K' or 'Jy'}\\
& &allowed: & string \\
& &Default: & 
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.scantable.set_freqframe
\newpage
\ahsdfunction{sd.scantable.set\_freqframe}{sd.scantable.set_freqframe}{Set the frame type of the spectral axis}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

    Set the frame type of the Spectral Axis.
    Valid frames are 'TOPO', 'LSRD', 'LSRK', 'BARY',
    'GEO', 'GALACTO', 'LGROUP', 'CMB'.
    The default is taken from sd.rcParams['scantable.freqframe'].
 
\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
frame && \multicolumn{2}{p{3.36in}|}{An optional frame type}\\
& &allowed: & string \\
& &Default: & None 
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\

\begin{verbatim}
        scan = sd.scantable('OrionS_rawACSmod_cal')
        scan.set_freqframe('BARY')
\end{verbatim}


%% sd.scantable.set_instrument
\newpage
\ahsdfunction{sd.scantable.set\_instrument}{sd.scantable.set_instrument}{Set antenna name}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

    Set the instrument (antenna name) for subsequent processing.
 
\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
instr && \multicolumn{2}{p{3.36in}|}{Instrument (or antenna) name}\\
& &allowed: & string \\
& &Default: & 
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.scantable.set_restfreqs
\newpage
\ahsdfunction{sd.scantable.set\_restfreqs}{sd.scantable.set_restfreqs}{Set rest frequency}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

    Set or replace the restfrequency specified and
    if the 'freqs' argument holds a scalar,
    then that rest frequency will be applied to all the selected
    data.  If the 'freqs' argument holds
    a vector, then it MUST be of equal or smaller length than
    the number of IFs (and the available restfrequencies will be
    replaced by this vector).  In this case, *all* data have
    the restfrequency set per IF according
    to the corresponding value you give in the 'freqs' vector.
    E.g. 'freqs=[1e9, 2e9]'  would mean IF 0 gets restfreq 1e9 and
    IF 1 gets restfreq 2e9.
    
    You can also specify the frequencies via a linecatalog.

    Note that, to do more sophisticate Restfrequency setting, e.g. on a
    source and IF basis, use scantable.set\_selection() before using
    this function::

    \begin{verbatim}
             # provided your scantable is called scan
             selection = sd.selector()
             selection.set_name("ORION*")
             selection.set_ifs([1])
             scan.set_selection(selection)
             scan.set_restfreqs(freqs=86.6e9)
    \end{verbatim}

 
\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
freqs && \multicolumn{2}{p{3.36in}|}{List of rest frequency values or string identifiers}\\
& &allowed: & string \\
& &Default: & None
\\
unit && \multicolumn{2}{p{3.36in}|}{Unit for rest frequency}\\
& &allowed: & string \\
& &Default: & 'Hz'
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\

\begin{verbatim}
         scan = sd.scantable('OrionS_rawACSmod_cal')
         # set the given restfrequency for the all currently selected IFs
         scan.set_restfreqs(freqs=1.4e9)
         # set restfrequencies for the n IFs  (n > 1) in the order of the
         # list, i.e
         # IF0 -> 1.4e9, IF1 ->  1.41e9, IF3 -> 1.42e9
         # len(list_of_restfreqs) == nIF
         # for nIF == 1 the following will set multiple restfrequency for
         # that IF
         scan.set_restfreqs(freqs=[1.4e9, 1.41e9, 1.42e9])
         # set multiple restfrequencies per IF. as a list of lists where
         # the outer list has nIF elements, the inner s arbitrary
         scan.set_restfreqs(freqs=[[1.4e9, 1.41e9], [1.67e9]])
\end{verbatim}


%% sd.scantable.set_selection
\newpage
\ahsdfunction{sd.scantable.set\_selection}{sd.scantable.set_selection}{Select a subset of the data}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

    Select a subset of the data. All following operations on this scantable
    are only applied to the selection.

    The selection can be done via a selector object (default unset the selection), or
    any combination of "pols", "ifs", "beams", "scans", "cycles", "name", "query", "types" 
    that will be passed to the constructor of the selector object to create a new selection.
 
\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
selection && \multicolumn{2}{p{3.36in}|}{A selector object}\\
& &allowed: & selector \\
& &Default: & None
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\
\begin{verbatim}
        scan = sd.scantable('OrionS_rawACSmod_cal')
        sel = sd.selector()         # create a selection object
        self.set_scans([0, 3])    # select SCANNO 0 and 3
        scan.set_selection(sel)  # set the selection
        scan.summary()           # will only print summary of scanno 0 an 3
        scan.set_selection()     # unset the selection
        # or the equivalent
        scan.set_selection(scans=[0,3])
        scan.summary()           # will only print summary of scanno 0 an 3
        scan.set_selection()     # unset the selection
\end{verbatim}


%% sd.scantable.set_sourcetype
\newpage
\ahsdfunction{sd.scantable.set\_sourcetype}{sd.scantable.set_sourcetype}{Set the types of source to be source or reference scan}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

    Set the type of the source to be an source or reference scan
    using the provided pattern.
 
\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
match && \multicolumn{2}{p{3.36in}|}{A Unix style pattern, regular expression or selector}\\
& &allowed: & string, selector \\
& &Default: & 
\\
matchtype && \multicolumn{2}{p{3.36in}|}{'pattern' for UNIX style pattern, 'regex' for regular expression}\\
& &allowed: & string \\
& &Default: & 'pattern'
\\
sourcetype && \multicolumn{2}{p{3.36in}|}{The type of the source to use (source/reference)}\\
& &allowed: & string \\
& &Default: & 'reference'
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.scantable.set_spectrum
\newpage
\ahsdfunction{sd.scantable.set\_spectrum}{sd.scantable.set_spectrum}{Set spectrum for specified row}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

   Set the spectrum for the current row in the scantable.

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
spec && \multicolumn{2}{p{3.36in}|}{The new spectrum}\\
& &allowed: & float array \\
& &Default: & 
\\
rowno && \multicolumn{2}{p{3.36in}|}{The row number to set the spectrum for}\\
& &allowed: & integer \\
& &Default: & 
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.scantable.set_unit
\newpage
\ahsdfunction{sd.scantable.set\_unit}{sd.scantable.set_unit}{Set unit for spectral axis}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

    Set the unit for all following operations on this scantable.
    Valid options are '*Hz', 'km/s', 'channel', or ''.
 
\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
unit && \multicolumn{2}{p{3.36in}|}{Optional unit}\\
& &allowed: & string \\
& &Default: & 'channel'
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.scantable.shift_refpix
\newpage
\ahsdfunction{sd.scantable.shift\_refpix}{sd.scantable.shift_refpix}{Shift the reference pixel of the spectral coordinate}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

    Shift the reference pixel of the Spectra Coordinate by an
    integer amount.

    Be careful using this with broadband data.
 
\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
delta && \multicolumn{2}{p{3.36in}|}{The amount to shift by}\\
& &allowed: & integer \\
& &Default: & 
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.scantable.sinusoid_baseline
\newpage
\ahsdfunction{sd.scantable.sinusoid\_baseline}{sd.scantable.sinusoid_baseline}{Perform a baseline subtraction using sinusoidal function}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

    Return a scan which has been baselined (all rows) with sinusoidal functions.
    Fit will be done with 'sigma-clipping'.

    Spectral lines are detected first using linefinder and masked out
    to avoid them affecting the baseline solution.

    If applyfft is set to True, the function performs Fourier analysis to select 
    wave numbers for sinusoidal fitting. Currently, 'fft' is only available to be 
    used for the analysis. You can specify threshold for selection of wave number 
    using fftthresh parameter. Both float and string is acceptable. Given a float 
    value, the unit is set to sigma. For string values, allowed formats include:

    \begin{itemize}
    \item any decimal number plus 'sigma' (e.g. '3sigma')
    \item 'top' plus any decimal number (e.g. 'top10')
    \end{itemize}

    In addition, you can add or reject specific wave numbers from the fit using 
    addwn and rejwn, respectively. You can specify wave numbers as an integer,  
    string, or list of them. For string specification, syntax for those parameters 
    are as follows:
    
    \begin{itemize}
    \item 'a-b' (= a, a+1, a+2, ..., b-1, b)
    \item '$<$a' (= 0, 1, ..., a-2, a-1)
    \item '$>$a' (= a+1, a+2, ... up to maximum wave number corresponding to the Nyquist frequency)
    \end{itemize} 

    You can append '=' after inequality sign. When both addwn and rejwn are set, 
    rejwn will take priority of addwn.
 
    Note:
        The best-fit parameter values output in logger and/or blfile are now
        based on specunit of 'channel'. 

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
insitu && \multicolumn{2}{p{3.36in}|}{If False a new scantable is returned}\\
& &allowed: & bool \\
& &Default: & None (use default value)
\\
mask && \multicolumn{2}{p{3.36in}|}{An optional mask retreived from scantable}\\
& &allowed: & bool array \\
& &Default: & None (no mask)
\\
applyfft && \multicolumn{2}{p{3.36in}|}{Perform Fourier analysis to find appropriate sinusoidal component}\\
& &allowed: & bool \\
& &Default: & True
\\
fftmethod && \multicolumn{2}{p{3.36in}|}{Method to find sinusoidal component (currently only 'fft' is available)}\\
& &allowed: & string \\
& &Default: & 'fft'
\\
fftthresh && \multicolumn{2}{p{3.36in}|}{Threshod to select wave number in Fourier analysis}\\
& &allowed: & float, string \\
& &Default: & 3.0
\\
addwn && \multicolumn{2}{p{3.36in}|}{Additional wave numbers to be used for fitting}\\
& &allowed: & integer, string, any array \\
& &Default: & []
\\
rejwn && \multicolumn{2}{p{3.36in}|}{Waver numbers not to be used for fitting}\\
& &allowed: & integer, string, any array \\
& &Default: & []
\\
clipthresh && \multicolumn{2}{p{3.36in}|}{Clipping threshold in unit of sigma}\\
& &allowed: & float \\
& &Default: & 3.0
\\
clipniter && \multicolumn{2}{p{3.36in}|}{Maximum number of iteration of clipping}\\
& &allowed: & integer \\
& &Default: & 0
\\
plot && \multicolumn{2}{p{3.36in}|}{Plot the fit and the residual (currently unavailable)}\\
& &allowed: & bool \\
& &Default: & False
\\
getresidual && \multicolumn{2}{p{3.36in}|}{If False, return best-fit value instead of residual}\\
& &allowed: & bool \\
& &Default: & True 
\\
showprogress && \multicolumn{2}{p{3.36in}|}{Show progress status for large data}\\
& &allowed: & bool \\
& &Default: & True 
\\
minnrow && \multicolumn{2}{p{3.36in}|}{Minimum number of spectra to show progress status}\\
& &allowed: & integer \\
& &Default: & 1000
\\
outlog && \multicolumn{2}{p{3.36in}|}{Output the coefficients of the best-fit function to logger}\\
& &allowed: & bool \\
& &Default: & False
\\
blfile && \multicolumn{2}{p{3.36in}|}{Name of text file in which the best-fit parameter values to be written}\\
& &allowed: & string \\
& &Default: & '' 
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline
scantable

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\

\begin{verbatim}
        scan = sd.scantable('OrionS_rawACSmod_cal',average=False)
        # return a scan baselined by a combination of sinusoidal curves having
        # wave numbers in spectral window up to 10, 
        # also with 3-sigma clipping, iteration up to 4 times
        bscan = scan.sinusoid_baseline(addwn='<=10',clipthresh=3.0,clipniter=4)
\end{verbatim}


%% sd.scantable.smooth
\newpage
\ahfunction{sd.scantable.smooth}{Smooth the spectra}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

    Smooth the spectrum by the specified kernel (conserving flux).

    The user should specify a type of smoothing kernel. Supported types are 
    'hanning' (default), 'gaussian', 'boxcar', 'rmedian', or 'poly'.
    The width of the kernel in pixel can be specified as width argument. 
    For hanning this is ignored otherwise it defauls to 5 pixels.
    For 'gaussian' it is the Full Width Half Maximum. For 'boxcar' it is the full width.
    For 'rmedian' and 'poly' it is the half width.
    The order argument is an optional parameter for 'poly' kernel (default is 2), to
    specify the order of the polnomial. It is ignored by all other kernels.

    You can verify and decide whether you apply the fit result or not, if plot argument is True.
    In that case, you have to answer 'y' or 'n' for each spectra so that setting True is not 
    recommended for large dataset.

    If insitu is True, or insitu is None and sd.rcParams['insitu'] is True, 
    the method will not return the result, but apply operation on this scantable. 

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
kernel && \multicolumn{2}{p{3.36in}|}{The type of smoothing kernel}\\
& &allowed: & string \\
& &Default: & 'hanning'
\\
width && \multicolumn{2}{p{3.36in}|}{The width of the kernel in pixels}\\
& &allowed: & float \\
& &Default: & 5.0
\\
order && \multicolumn{2}{p{3.36in}|}{Order of the polynomial for 'poly' kernel}\\
& &allowed: & integer \\
& &Default: & 2
\\
plot && \multicolumn{2}{p{3.36in}|}{Plot the fit and the residual}\\
& &allowed: & bool \\
& &Default: & False
\\
insitu && \multicolumn{2}{p{3.36in}|}{If False a new scantable is returned}\\
& &allowed: & bool \\
& &Default: & None
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline
scantable

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.scantable.stats
\newpage
\ahfunction{sd.scantable.stats}{Compute specified statistics of the spectra}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

    Determine the specified statistic of the current beam/if/pol
    Takes a 'mask' as an optional parameter to specify which
    channels should be excluded.

    Available statistics are 'min', 'max', 'min\_abc', 'max\_abc', 'sumsq', 'sum',
    'mean', 'var', 'stddev', 'avdev', 'rms', 'median'.

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
stat && \multicolumn{2}{p{3.36in}|}{Statistics to be calculated}\\
& &allowed: & string \\
& &Default: & 'stddev'
\\
mask && \multicolumn{2}{p{3.36in}|}{An optional mask specifying where the statistic should be determined}\\
& &allowed: & bool array \\
& &Default: & None
\\
form && \multicolumn{2}{p{3.36in}|}{Format string to print statistic values}\\
& &allowed: & string \\
& &Default: & '3.3f'
\\
row && \multicolumn{2}{p{3.36in}|}{Row number of spectrum to process}\\
& &allowed: & integer \\
& &Default: & None (all rows)
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline
float array 

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\

\begin{verbatim}
        scan = sd.scantable('OrionS_rawACSmod_cal')
        scan.set_unit('channel')
        msk = scan.create_mask([100, 200], [500, 600])
        scan.stats(stat='mean', mask=m)
\end{verbatim}


%% sd.scantable.stddev
\newpage
\ahfunction{sd.scantable.stddev}{Compute standard deviation of the spectra}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

    Determine the standard deviation of the current beam/if/pol
    Takes a 'mask' as an optional parameter to specify which
    channels should be excluded.
 
\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
mask && \multicolumn{2}{p{3.36in}|}{An optional mask specifying where the standard deviation should be determined}\\
& &allowed: & bool array \\
& &Default: & None
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline
float array

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\

\begin{verbatim}
        scan = sd.scantable('OrionS_rawACSmod_cal')
        scan.set_unit('channel')
        msk = scan.create_mask([100, 200], [500, 600])
        scan.stddev(mask=m)
\end{verbatim}


%% sd.scantable.summary
\newpage
\ahfunction{sd.scantable.summary}{Print a summary of the contents of the scantable}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

    Print a summary of the contents of this scantable.
    Optionally, output to the file specified.

 
\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
filename && \multicolumn{2}{p{3.36in}|}{The name of a file to write the output}\\
& &allowed: & string \\
& &Default: & None (no file output)
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline
string

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.scantable.swap_linears
\newpage
\ahsdfunction{sd.scantable.swap\_linears}{sd.scantable.swap_linears}{Swap the linear polarizations XX and YY}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

    Swap the linear polarisations XX and YY, or better the first two
    polarisations as this also works for ciculars.

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\flushleft\vspace{.20in}\textbf {Returns}\newline

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%%%%% sd.selector
\newpage
\ahobject{sd.selector}{Data selection tool for single-dish data}
%\ahfunction{sd.selector}{Data selection tool for single-dish data}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

  The selector is a data selection object that affects a 
  \ahlink{scantable}{sd:sd.scantable} object via 
  \ahlink{set\_selection}{sd:sd.scantable.set_selection} function.
  Selection by the following attributes are available:

\begin{itemize}
\item scan number
\item beam number
\item cycle number
\item IF number
\item source name (allows regular expression)
\item polarization number
\item row number
\item source type
\item value of system temperature (minimum and maximum threshold)
\end{itemize}

  Note that the selection by an integer is 0-based (scan, beam, cycle, IF, polarization, and row).

  In addition, the selector provides interface for more flexible data 
  selection using
  \htmladdnormallink{TaQL}{http://aips2.nrao.edu/docs/notes/199/199.html}.

  The selector also support sorting data. 
  The selector sorts data based on values of columns specified by the user.

  Summary of the current selection is stored in the object as a string. 
  Thus, you can see that summary by using print (see example below).

  The constructor takes some arguments to set selection criteria. So,  
  the user can set selection either using constructor options and 
  available setter functions.

  Source types should be given as an integer or an enumerations that are properly defined for 
  source type. That enumeration can be accessed via sd.srctype. 
  The list of enumerations defined (following sd.srctype.) are as follows:

\begin{longtable}{lcl}
enum & int & description \\
\hline
pson & 0 & on-source scan of position switched data \\
psoff & 1 & off-source scan of position switched data \\
nod & 2 & nod scan \\
fson & 3 & on-source scan of frequency switched data \\
fsoff & 4 & reference scan of frequency switched data \\
sky & 6 & sky scan for calibration \\
hot & 7 & hot load scan for calibration \\
warm & 8 & warm load scan for calibration \\
cold & 9 & cold load scan for calibration \\
poncal & 10 & on-source calibration scan of position switched data \\
poffcal & 11 & off-source calibration scan of position switched data \\
nodcal & 12 & nod calibration scan \\
foncal & 13 & on-source calibration scan of frequency switched data \\
foffcal & 14 & reference calibration scan of frequency switched data \\
fslo & 20 & lower frequency throw of symmetric freuqnecy switching \\
flooff & 21 & off-source lower frequency throw of symmetric frequency switching \\
flosky & 26 & sky lower frequency throw of symmetric frequency switching \\
flohot & 27 & hot load lower frequency throw of symmetric frequency switching \\
flowarm & 28 & warm load lower frequency throw of symmetric frequency switching \\
flocold & 29 & cold load lower frequency throw of symmetric frequency switching \\ 
fshi & 30 & higher frequency throw of symmetric freuqnecy switching \\
fhioff & 31 & off-source higher frequency throw of symmetric frequency switching \\
fhisky & 36 & sky higher frequency throw of symmetric frequency switching \\
fhihot & 37 & hot load higher frequency throw of symmetric frequency switching \\
fhiwarm & 38 & warm load higher frequency throw of symmetric frequency switching \\
fhicold & 39 & cold load higher frequency throw of symmetric frequency switching \\
sig & 90 & signal scan \\
ref & 91 & reference scan \\
cal & 92 & calibration scan \\
notype & 99 & no type \\ 
\end{longtable}

%  \medskip\noindent\textbf{Known Issues}
%
%    After the data in scantable is selected by the selector object, 
%    \ahlink{save}{sd:sd.scantable.save} function doesn't work.
%    Before saving selected data, you must \ahlink{copy}{sd:sd.scantable.copy} 
%    scantable first, and save it as usual.

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
beams && \multicolumn{2}{p{3.36in}|}{Beam number selection}\\
& &allowed: & integer, integer array \\
& &Default: & None (no selection)
\\
cycles && \multicolumn{2}{p{3.36in}|}{Cycle number selection}\\
& &allowed: & integer, integer array \\
& &Default: & None (no selection)
\\
ifs && \multicolumn{2}{p{3.36in}|}{IF number selection}\\
& &allowed: & integer, integer array \\
& &Default: & None (no selection)
\\
name && \multicolumn{2}{p{3.36in}|}{Source name selection. Allows regular expression.}\\
& &allowed: & string\\
& &Default: & None (no selection)
\\
pols && \multicolumn{2}{p{3.36in}|}{Polarization number selection}\\
& &allowed: & integer, integer array, string, string array \\
& &Default: & None (no selection)
\\
query && \multicolumn{2}{p{3.36in}|}{TaQL selection query}\\
& &allowed: & string \\
& &Default: & None (no selection)
\\
scans && \multicolumn{2}{p{3.36in}|}{Scan number selection}\\
& &allowed: & integer, integer array \\
& &Default: & None (no selection)
\\
types && \multicolumn{2}{p{3.36in}|}{Source type selection}\\
& &allowed: & integer, integer array \\
& &Default: & None (no selection)
\\
rows && \multicolumn{2}{p{3.36in}|}{Row number selection}\\
& &allowed: & integer, integer array \\
& &Default: & None (no selection)
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\

\begin{verbatim}
     # create a selector object
     sel=sd.selector()
     # These are equivalent if data is 'linear'
     sel.set_polarisations(["XX","Re(XY)"])
     sel.set_polarisations([0,2])
     # reset the polarisation selection
     sel.set_polarisations()
     # these are equivalent
     sel2=sd.selector(ifs=[0,1])
     sel2=sd.selector()
     sel2.set_ifs([0,1])
     # check current selection
     print sel
     IFNO: [0,1]
     # apply selection on scantable
     s=sd.scantable('OrionS_rawACSmod_cal',average=False)
     s.set_selection(sel)
\end{verbatim}


Methods
\begin{longtable}{ll}

	\ahlink{get\_beams}{sd:sd.selector.get_beams} &Return a list of current beam selection \\

	\ahlink{get\_cycles}{sd:sd.selector.get_cycles} &Return a list of current cycle selection \\

	\ahlink{get\_ifs}{sd:sd.selector.get_ifs} &Return a list of current IF selection \\

	\ahlink{get\_name}{sd:sd.selector.get_name} &Return a selection string for source name (not yet implemented) \\

	\ahlink{get\_order}{sd:sd.selector.get_order} &Return a list of columns used for sorting \\

	\ahlink{get\_pols}{sd:sd.selector.get_pols} &Return a list of current polarization selection \\

	\ahlink{get\_poltypes}{sd:sd.selector.get_poltypes} &Return a list of polarization types for current polarization selection \\

	\ahlink{get\_query}{sd:sd.selector.get_query} &Return current selection string for TaQL selection \\

	\ahlink{get\_rows}{sd:sd.selector.get_rows} &Return a list of current row number selection \\

	\ahlink{get\_scans}{sd:sd.selector.get_scans} &Return a list of current scan number selection \\

	\ahlink{get\_types}{sd:sd.selector.get_types} &Return a list of current source type selection \\

	\ahlink{is\_empty}{sd:sd.selector.is_empty} &Check if any selection has been set \\

	\ahlink{reset}{sd:sd.selector.reset} &Unset all selections \\

	\ahlink{set\_beams}{sd:sd.selector.set_beams} &Set a sequence of beam numbers \\

	\ahlink{set\_cycles}{sd:sd.selector.set_cycles} &Set a sequence of cycle numbers \\

	\ahlink{set\_ifs}{sd:sd.selector.set_ifs} &Set a sequence of IF numbers \\

	\ahlink{set\_name}{sd:sd.selector.set_name} &Set a selection based on a source name \\

	\ahlink{set\_order}{sd:sd.selector.set_order} &Set column names that is used for sorting data \\

	\ahlink{set\_polarisations}{sd:sd.selector.set_polarisations} &Set a sequence of polarization numbers or strings \\

	\ahlink{set\_polarizations}{sd:sd.selector.set_polarizations} &Set a sequence of polarization numbers or strings\\

	\ahlink{set\_pols}{sd:sd.selector.set_pols} &Set a sequence of polarization numbers or strings \\

	\ahlink{set\_query}{sd:sd.selector.set_query} &Set a selection string based on TaQL \\

	\ahlink{set\_rows}{sd:sd.selector.set_rows} &Set a sequence of row numbers \\

	\ahlink{set\_scans}{sd:sd.selector.set_scans} &Set a sequence of scan numbers  \\

	\ahlink{set\_tsys}{sd:sd.selector.set_tsys} &Set range of system temperature \\

	\ahlink{set\_types}{sd:sd.selector.set_types} &Set a sequence of source types \\

\end{longtable}


%% sd.selector.get_beams
\newpage
\ahsdfunction{sd.selector.get\_beams}{sd.selector.get_beams}{Return a list of current beam selection}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

   Return a list of current beam selection.

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\flushleft\vspace{.20in}\textbf {Returns}\newline
integer array

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.selector.get_cycles
\newpage
\ahsdfunction{sd.selector.get\_cycles}{sd.selector.get_cycles}{Return a list of current cycle selection}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

   Return a list of current cycle selection.

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\flushleft\vspace{.20in}\textbf {Returns}\newline
integer array

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.selector.get_ifs
\newpage
\ahsdfunction{sd.selector.get\_ifs}{sd.selector.get_ifs}{Return a list of current IF selection}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

   Return a list of current IF selection.

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\flushleft\vspace{.20in}\textbf {Returns}\newline
integer array

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.selector.get_name
\newpage
\ahsdfunction{sd.selector.get\_name}{sd.selector.get_name}{Return a selection string for source name (not yet implemented) }

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

   Return a selection strings for source name.
   Not yet implemented.

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\flushleft\vspace{.20in}\textbf {Returns}\newline
None

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.selector.get_order
\newpage
\ahsdfunction{sd.selector.get\_order}{sd.selector.get_order}{Return a list of columns used for sorting}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

   Return a list of columns used for sorting.

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\flushleft\vspace{.20in}\textbf {Returns}\newline
string list

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.selector.get_pols
\newpage
\ahsdfunction{sd.selector.get\_pols}{sd.selector.get_pols}{Return a list of current polarization selection}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

   Return a list of current polarization selection.
   It returns an integer array even if you set polarization selection by string (e.g. 'XX', 'I').

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\flushleft\vspace{.20in}\textbf {Returns}\newline
integer array

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.selector.get_poltypes
\newpage
\ahsdfunction{sd.selector.get\_poltypes}{sd.selector.get_poltypes}{Return a list of polarization types for current polarization selection}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

   Return a list of polarization types for current polarization selection.

   The returned array contains polarization types for each polarization selection strings.
   If you set polarization selection as integer, empty array will be returned since integer 
   selection doesn't specify polarization type.

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\flushleft\vspace{.20in}\textbf {Returns}\newline
string array

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.selector.get_query
\newpage
\ahsdfunction{sd.selector.get\_query}{sd.selector.get_query}{Return current selection string for TaQL selection}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

   Return current selection string for TaQL selection.

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\flushleft\vspace{.20in}\textbf {Returns}\newline
string

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.selector.get_rows
\newpage
\ahsdfunction{sd.selector.get\_rows}{sd.selector.get_rows}{Return a list of current row number selection}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

   Return a list of current row number selection.

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\flushleft\vspace{.20in}\textbf {Returns}\newline
integer array

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.selector.get_scans
\newpage
\ahsdfunction{sd.selector.get\_scans}{sd.selector.get_scans}{Return a list of current scan number selection}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

   Return a list of current scan number selection.

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\flushleft\vspace{.20in}\textbf {Returns}\newline
integer array

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.selector.get_types
\newpage
\ahsdfunction{sd.selector.get\_types}{sd.selector.get_types}{Return a list of current source type selection}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

   Return a list of current source type selection.

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\flushleft\vspace{.20in}\textbf {Returns}\newline
integer array 

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.selector.is_empty
\newpage
\ahsdfunction{sd.selector.is\_empty}{sd.selector.is_empty}{Check if any selection has been set}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

   Check if any selection has been set.

   If any selection is set, the method returns False. Otherwise, it returns True.

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\flushleft\vspace{.20in}\textbf {Returns}\newline
bool

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\

\begin{verbatim}
   # create selector without any selection
   sel=sd.selector()
   # is_empty() returns True
   sel.is_empty()
   True
   # set any selection
   sel.set_ifs([0])
   # then, is_empty() returns False
   sel.is_empty()
   False
\end{verbatim}


%% sd.selector.reset
\newpage
\ahfunction{sd.selector.reset}{Unset all selections}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

   Unset all selections.
   Note that the method doesn't clear sorting order set by \ahlink{set\_order}{sd:sd.selector.set_order}.
   To unset sort order, you have to execute set\_order([]).

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\flushleft\vspace{.20in}\textbf {Returns}\newline

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\

\begin{verbatim}
   # create selector without any selection
   sel=sd.selector()
   # is_empty() returns True
   sel.is_empty()
   True
   # set any selection
   sel.set_ifs([0])
   # then, is_empty() returns False
   sel.is_empty()
   False
   # reset() clear all selections 
   sel.reset()
   # thus, is_empty() returns True
   sel.is_empty()
   True
\end{verbatim}



%% sd.selector.set_beams
\newpage
\ahsdfunction{sd.selector.set\_beams}{sd.selector.set_beams}{Set a sequence of beam numbers}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

   Set a sequence of beam numbers to the selection.

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
beams && \multicolumn{2}{p{3.36in}|}{Beam number selection}\\
& &allowed: & integer, integer array \\
& &Default: & [] (no selection)
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.selector.set_cycles
\newpage
\ahsdfunction{sd.selector.set\_cycles}{sd.selector.set_cycles}{Set a sequence of cycle numbers}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

   Set a sequence of cycle numbers to the selection.

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
cycles && \multicolumn{2}{p{3.36in}|}{Cycle number selection}\\
& &allowed: & integer, integer array \\
& &Default: & [] (no selection)
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.selector.set_ifs
\newpage
\ahsdfunction{sd.selector.set\_ifs}{sd.selector.set_ifs}{Set a sequence of IF numbers}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

   Set a sequence of IF numbers to the selection.

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
ifs && \multicolumn{2}{p{3.36in}|}{IF number selection}\\
& &allowed: & integer, integer array \\
& &Default: & [] (no selection)
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.selector.set_name
\newpage
\ahsdfunction{sd.selector.set\_name}{sd.selector.set_name}{Set a selection based on a source name}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\
 
   Set a selection based on a source name.
   This can be a unix pattern , e.g. "*\_R".

   Note that the method overwrites TaQL selection string set by \ahlink{set\_query}{sd:sd.selector.set_query}.

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
name && \multicolumn{2}{p{3.36in}|}{A string containing a source name or pattern}\\
& &allowed: & string \\
& &Default: & 
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\

\begin{verbatim}
        sel=sd.selector()
        # select all reference scans which start with "Orion"
        sel.set_name("Orion*_R")
\end{verbatim}



%% sd.selector.set_order
\newpage
\ahsdfunction{sd.selector.set\_order}{sd.selector.set_order}{Set column names that is used for sorting data}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

   Set the order the scantable should be sorted by.
   The user specify a list of column names that is used for sorting data (e.g. 'IFNO', 'SCANNO').
   The data are sorted according to the value of these columns.

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
order && \multicolumn{2}{p{3.36in}|}{The list of column names to sort by in order}\\
& &allowed: & string array \\
& &Default: & 
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.selector.set_polarisations
\newpage
\ahsdfunction{sd.selector.set\_polarisations}{sd.selector.set_polarisations}{Set a sequence of polarization numbers or strings}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

   Set the polarisations to be selected in the scantable.
   It allows to set polarization selection via integer or string (e.g. "XX", "Q").
   Integer must be within the range of 0 to 3 since the number outside this range will result no 
   selected data exception.
   If the selection is specified by an integer, the selection will refer polarization type of the 
   original scantable.
   On the other hand, the selection by string contains both type and component so that the selection 
   will refer its type, not the original scantable. 
   

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
pols && \multicolumn{2}{p{3.36in}|}{A list of integers of 0-3, or strings, e.g ["I","Q"].}\\
& &allowed: & integer, string, integer array, string array \\
& &Default: & [] (no selection)
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\

\begin{verbatim}
         sel = sd.selector()
         # These are equivalent if data is 'linear'
         sel.set_polarisations(["XX","Re(XY)"])
         sel.set_polarisations([0,2])
         # reset the polarisation selection
         sel.set_polarisations()
\end{verbatim}


%% sd.selector.set_polarizations
\newpage
\ahsdfunction{sd.selector.set\_polarizations}{sd.selector.set_polarizations}{Set a sequence of polarization numbers or strings}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

   See \ahlink{set\_polarisations}{sd:sd.selector.set_polarisations}.

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\flushleft\vspace{.20in}\textbf {Returns}\newline

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.selector.set_pols
\newpage
\ahsdfunction{sd.selector.set\_pols}{sd.selector.set_pols}{Set a sequence of polarization numbers or strings}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

   See \ahlink{set\_polarisations}{sd:sd.selector.set_polarisations}.

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\flushleft\vspace{.20in}\textbf {Returns}\newline

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.selector.set_query
\newpage
\ahsdfunction{sd.selector.set\_query}{sd.selector.set_query}{Set a selection string based on TaQL}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

   Select by Column query. Power users only!

   The mehtod is used to set TaQL selection string directly.
   The user must be familiar with \htmladdnormallink{TaQL}{http://aips2.nrao.edu/docs/notes/199/199.html} 
   and data structure of scantable.
 
\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
query && \multicolumn{2}{p{3.36in}|}{TaQL selection string}\\
& &allowed: & string \\
& &Default: & 
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\

\begin{verbatim}
        sel=sd.selector()
        # select all off scans with integration times over 60 seconds.
        sel.set_query("SRCTYPE == PSOFF AND INTERVAL > 60.0")
\end{verbatim}


%% sd.selector.set_rows
\newpage
\ahsdfunction{sd.selector.set\_rows}{sd.selector.set_rows}{Set a sequence of row numbers}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

   Set a sequence of row numbers (0-based). Power users Only!

   NOTICE row numbers can be changed easily by sorting,
   prior selection, etc.
 
\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
rows && \multicolumn{2}{p{3.36in}|}{A list of integers}\\
& &allowed: & integer, integer array \\
& &Default: & [] (no selection)
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.selector.set_scans
\newpage
\ahsdfunction{sd.selector.set\_scans}{sd.selector.set_scans}{Set a sequence of scan numbers}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

   Set a sequence of Scan numbers to the selection.
 
\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
scans && \multicolumn{2}{p{3.36in}|}{A list of integers}\\
& &allowed: & integer, integer array \\
& &Default: & [] (no selection)
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.selector.set_tsys
\newpage
\ahsdfunction{sd.selector.set\_tsys}{sd.selector.set_tsys}{Set range of system temperature}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

   Select by Tsys range.
   The method sets an upper and a lower limit of the Tsys value.
 
\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
tsysmin && \multicolumn{2}{p{3.36in}|}{The lower threshold}\\
& &allowed: & float \\
& &Default: & 0.0
\\
tsysmax && \multicolumn{2}{p{3.36in}|}{The upper threshold}\\
& &allowed: & float \\
& &Default: & None (no upper limit)
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\

\begin{verbatim}
        sel=sd.selector()
        # select all spectra with Tsys <= 500.0
        sel.set_tsys(tsysmax=500.0)
\end{verbatim}


%% sd.selector.set_types
\newpage
\ahsdfunction{sd.selector.set\_types}{sd.selector.set_types}{Set a sequence of source types}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

   Set a sequence of source types to the selection.
   The types argument can contain integer and/or sd.srctype enum.
 

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
types && \multicolumn{2}{p{3.36in}|}{A list of integers}\\
& &allowed: & integer, integer array \\
& &Default: & [] (no selection)
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\

\begin{verbatim}
   sel=sd.selector()
   # select only on-source scans of position switched observation
   sel.set_types(0)
   # or use enum
   sel.set_types(sd.srctype.pson)
\end{verbatim}


%%%%% sd.fitter
\newpage
\ahobject{sd.fitter}{General fitting tool}
%\ahfunction{sd.fitter}{General fitting tool}


\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

  The fitter is an object to fit data. This contains both baseline fitting 
  and spectral line fitting. For baseline fitting, simple polynomial fitting 
  with arbitrary order is available. For spectral line fitting, Gaussian 
  and Lorentzian fitting are supported. It allows fitting of multiple 
  lines, but it doesn't support hyperfine fitting, i.e. multiple line 
  fitting under some constraints.

  The constructor doesn't take any arguments. It just creates a fitter 
  object that no state is set.

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\
\begin{verbatim}
        s = sd.scantable('myscan.asap')
        s.set_cursor(thepol=1)        # select second pol
        f = sd.fitter()               # create fitter object
        f.set_scan(s)
        f.set_function(poly=0)
        f.fit(row=0)                  # fit first row
\end{verbatim}

Methods
\begin{longtable}{ll}

	\ahlink{auto\_fit}{sd:sd.fitter.auto_fit} & Return a scan where the function is applied to all rows \\

	\ahlink{commit}{sd:sd.fitter.commit} & Return a new scan where the fits have been subtracted \\

	\ahlink{fit}{sd:sd.fitter.fit} & Execute actual fitting process\\

	\ahlink{get\_area}{sd:sd.fitter.get_area} & Return the area under the fitted gaussian/lorentzian component \\

	\ahlink{get\_chi2}{sd:sd.fitter.get_chi2} & Return $\chi^2$ value \\

	\ahlink{get\_errors}{sd:sd.fitter.get_errors} & Return the errors in parameters \\

	\ahlink{get\_estimate}{sd:sd.fitter.get_estimate} & Return the parameter estimates \\

	\ahlink{get\_fit}{sd:sd.fitter.get_fit} & Return the fitted ordinate values \\

	\ahlink{get\_parameters}{sd:sd.fitter.get_parameters} & Return the fit parameters \\

	\ahlink{get\_residual}{sd:sd.fitter.get_residual} & Return the residual of the fit \\

	\ahlink{plot}{sd:sd.fitter.plot} & Plot fit \\

	\ahlink{set\_data}{sd:sd.fitter.set_data} & Set the abcissa and ordinate for the fit \\

	\ahlink{set\_function}{sd:sd.fitter.set_function} & Set the function to be fitted \\

	\ahlink{set\_gauss\_parameters}{sd:sd.fitter.set_gauss_parameters} & Set the parameters of Gaussian component \\

	\ahlink{set\_lorentz\_parameters}{sd:sd.fitter.set_lorentz_parameters} & Set the parameters of Lorentzian component \\

	\ahlink{set\_parameters}{sd:sd.fitter.set_parameters} & Set the parameters to be fitted \\

	\ahlink{set\_scan}{sd:sd.fitter.set_scan} & Set the data as a scantable \\

        \ahlink{set\_sinusoid\_parameters}{sd:sd.fitter.set_sinusoid_parameters} &Set the parameters of Sinusoidal component \\

	\ahlink{store\_fit}{sd:sd.fitter.store_fit} & Save fit parameters \\

\end{longtable}


%% sd.fitter.auto_fit
\newpage
\ahsdfunction{sd.fitter.auto\_fit}{sd.fitter.auto_fit}{Return a scan where the function is applied to all rows}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

   This method executes fitting for all rows in the current selection of the data.
   It returns a scan where the function is applied to all rows for all Beams/IFs/Pols.
   If any data is not set and/or fitting function is not specified, the function throws 
   an exception.

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
insitu && \multicolumn{2}{p{3.36in}|}{Apply operation on the input scantable or not}\\
& &allowed: & bool \\
& &Default: & None (use default setting defined in sd.rcParams)
\\
plot && \multicolumn{2}{p{3.36in}|}{Plot and verify result or not}\\
& &allowed: & bool \\
& &Default: & False
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline
scantable

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\

\begin{verbatim}
   f=sd.fitter()
   s=sd.scantable('OrionS_rawACSmod_cal',average=False)
   f.set_scan(s)
   f.set_function(poly=3)
   s_bs=f.auto_fit()
\end{verbatim}



%% sd.fitter.commit
\newpage
\ahfunction{sd.fitter.commit}{Return a new scan where the fits have been subtracted}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

   Return a new scan where the fits have been subtracted.
   You must fit the data before you execute this method. Otherwise, an exception will be thrown.
   
   If the data is set as a set of abcissa and ordinate values using \ahlink{set\_data}{sd:sd.fitter.set_data}, 
   it will not work.
   If you want to get data by this method, you must use \ahlink{set\_scan}{sd:sd.fitter.set_scan} that set 
   the data as a scantable. 

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\flushleft\vspace{.20in}\textbf {Returns}\newline
scantable

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\

\begin{verbatim}
   f=sd.fitter()
   s=sd.scantable('OrionS_rawACSmod_cal',average=False)
   # you must set data as a scantable
   f.set_scan(s)
   # set polynomial function of order 3 for baseline subtraction
   f.set_function(poly=3)
   # do fit
   f.fit()
   # get baseline subtracted scans
   s_bs=f.commit()
\end{verbatim}



%% sd.fitter.fit
\newpage
\ahfunction{sd.fitter.fit}{Execute actual fitting process}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

   Execute the actual fitting process. All the state (data, selection, and function) has to be set before executing.

   The method executes a fitting process for only one row that are specified by a row argument.
   By default, the first row will be fitted. 

   The estimate argument determines if the method computes an initial parameter set automatically.
   This can be used to compute estimates even if fit was called before.
 
\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
row && \multicolumn{2}{p{3.36in}|}{Specify the row in the scantable}\\
& &allowed: & integer \\
& &Default: & 0
\\
estimate && \multicolumn{2}{p{3.36in}|}{Auto-compute an initial parameter set}\\
& &allowed: & bool \\
& &Default: & False
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\

\begin{verbatim}
        s = sd.scantable('myscan.asap')
        s.set_cursor(thepol=1)        # select second pol (nb. 0-based)
        f = sd.fitter()
        f.set_scan(s)
        f.set_function(poly=0)
        f.fit(row=0)                  # fit first row
\end{verbatim}


%% sd.fitter.get_area
\newpage
\ahsdfunction{sd.fitter.get\_area}{sd.fitter.get_area}{Return the area under the fitted gaussian/lorentzian component}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

   Return the area under the fitted gaussian/lorentzian component.
   The component argument specifies which component you want to get area.
   By default, the method will return a sum of all gaussian/lorentzian components.

   Note that this will only work for gaussian/lorentzian fits.
   Otherwise, None will be returned.


\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
component && \multicolumn{2}{p{3.36in}|}{The gaussian/lorentzian component selection}\\
& &allowed: & integer \\
& &Default: & None (sum of all components)
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline
float

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.fitter.get_chi2
\newpage
\ahsdfunction{sd.fitter.get\_chi2}{sd.fitter.get_chi2}{Return $\chi^2$ value}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

   Return $\chi^2$ value of the fit. You must execute fitting process before getting $\chi^2$.

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\flushleft\vspace{.20in}\textbf {Returns}\newline
float

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\

\begin{verbatim}
        s = scantable('myscan.asap')
        s.set_cursor(thepol=1)        # select second pol (nb. 0-based)
        f = fitter()
        f.set_scan(s)
        f.set_function(poly=0)
        f.fit(row=0)                  # fit first row
        ch2=f.get_chi2()
\end{verbatim}




%% sd.fitter.get_errors
\newpage
\ahsdfunction{sd.fitter.get\_errors}{sd.fitter.get_errors}{Return the errors in parameters}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

   Return the errors in the parameters. You must execute fitting process before getting errors.

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
component && \multicolumn{2}{p{3.36in}|}{get the errors for the specified component only}\\
& &allowed: & integer \\
& &Default: & None (all components)
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline
float array

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.fitter.get_estimate
\newpage
\ahsdfunction{sd.fitter.get\_estimate}{sd.fitter.get_estimate}{Return the parameter estimates}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

   Return the parameter estimates for non-linear functions.
   It works only if fit is executed with estimate=True.

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\flushleft\vspace{.20in}\textbf {Returns}\newline
float array

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.fitter.get_fit
\newpage
\ahsdfunction{sd.fitter.get\_fit}{sd.fitter.get_fit}{Return the fitted ordinate values}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

   Return the fitted ordinate values.
   For spectral line fitting, it will represent model of the observed line.
   You must execute fitting process before getting fitted result.

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\flushleft\vspace{.20in}\textbf {Returns}\newline
float array

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.fitter.get_parameters
\newpage
\ahsdfunction{sd.fitter.get\_parameters}{sd.fitter.get_parameters}{Return the fit parameters}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

   Return the fit parameters as a dictionary. 
   The returned value contains the following attributes:

   \begin{itemize}
   \item errors \\ errors for each parameter
   \item fixed \\ list of fixed parameters
   \item formatted \\ formatted string that shows a fitting result
   \item params \\ list of resulting parameter values
   \end{itemize}

   The component argument specifies which component the user want to get fit parameters. 
   It is effective only for gaussian/lorentzian fitting.

   The error argument controls contents of formatted string. If error is True, the string 
   contains parameter values and their errors.

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
component && \multicolumn{2}{p{3.36in}|}{get the parameter values for the specified component only}\\
& &allowed: & integer \\
& &Default: & None (all components)
\\
errors && \multicolumn{2}{p{3.36in}|}{If True, include errors of fit parameters in formatted string}\\
& &allowed: & bool \\
& &Default: & False
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline
dictionary

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.fitter.get_residual
\newpage
\ahsdfunction{sd.fitter.get\_residual}{sd.fitter.get_residual}{Return the residual of the fit}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

   Return the residual of the fit.
   For baseline fitting, it will represent a baseline-subtracted spectrum.
   You must execute fitting process before getting fitted result.

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\flushleft\vspace{.20in}\textbf {Returns}\newline
float array

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.fitter.plot
\newpage
\ahfunction{sd.fitter.plot}{Plot fit}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

   Plot the last fit. 

   There are three arguments that control plot. 
   If residual argument is True, the plot contains residual in addition to 
   original data and fit. If plotparms argument is True, the parameter values 
   will be written on the plot explicitly. The components argument specifies 
   a list of components to plot. components=-1 means total fit (sum of all 
   components) will be plotted.

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
residual && \multicolumn{2}{p{3.36in}|}{An optional parameter indicating if the residual should be plotted}\\
& &allowed: & bool \\
& &Default: & False
\\
components && \multicolumn{2}{p{3.36in}|}{a list of components to plot, e.g [0,1]}\\
& &allowed: & integer, integer array \\
& &Default: & None (plot total fit)
\\
plotparms && \multicolumn{2}{p{3.36in}|}{Inidicates if the parameter values should be present on the plot}\\
& &allowed: & bool \\
& &Default: & False
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.fitter.set_data
\newpage
\ahsdfunction{sd.fitter.set\_data}{sd.fitter.set_data}{Set the abcissa and ordinate for the fit}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

    Set the absissa and ordinate for the fit. Also set the mask
    indicationg valid points.
    This can be used for data vectors retrieved from a scantable.

    For scantable fitting use \ahlink{set\_scan}{sd:sd.fitter.set_scan}.
 
\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
xdat && \multicolumn{2}{p{3.36in}|}{The abcissa values}\\
& &allowed: & float array \\
& &Default: & 
\\
ydat && \multicolumn{2}{p{3.36in}|}{The ordinate values}\\
& &allowed: & float array \\
& &Default: & 
\\
mask && \multicolumn{2}{p{3.36in}|}{An optional mask}\\
& &allowed: & bool array \\
& &Default: & 
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.fitter.set_function
\newpage
\ahsdfunction{sd.fitter.set\_function}{sd.fitter.set_function}{Set the function to be fitted}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

   Set the function to be fit.

   The argument to be set determines what the fitter will do.
   If you want to do polynomial fitting, you have to set poly or lpoly arguments.
   The value of poly or lpoly are interpreted as an order of the polynomial function to be 
   used for fitting. The poly is for non-linear least squares fitting, while lpoly is for linear one.
   If you want to do line fitting, you have to set either gauss or lorentz arguments.
   In that case, values of gauss or lorentz arguments are interpreted as a number of gaussian/lorentzian 
   components. Apparently, gauss=0 or lorentz=0 causes an exception.

   Note that all the above arguments are exclusive each other.
 
\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
poly && \multicolumn{2}{p{3.36in}|}{Use a polynomial of the order given with nonlinear least squares fit}\\
& &allowed: & integer \\
& &Default: & 
\\
lpoly && \multicolumn{2}{p{3.36in}|}{Use a polynomial of the order given with linear least squares fit}\\
& &allowed: & integer \\
& &Default: & 
\\
gauss && \multicolumn{2}{p{3.36in}|}{Fit the number of gaussian specified}\\
& &allowed: & integer \\
& &Default: & 
\\
lorentz && \multicolumn{2}{p{3.36in}|}{Fit the number of lorentzian specified}\\
& &allowed: & integer \\
& &Default: & 
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\

\begin{verbatim}
        f=sd.fitter()
        # will fit a 3rd order polynomial via nonlinear method
        f.set_function(poly=3)  
        # will fit a 3rd order polynomial via linear method
        f.set_function(lpoly=3) 
        # will fit two gaussians 
        f.set_function(gauss=2) 
        # will fit two lorentzians
        f.set_function(lorentz=2) 
\end{verbatim}



%% sd.fitter.set_gauss_parameters
\newpage
\ahsdfunction{sd.fitter.set\_gauss\_parameters}{sd.fitter.set_gauss_parameters}{Set the parameters of Gaussian component}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

   Set the Parameters of a 'Gaussian' component, set with \ahlink{set\_function}{sd:sd.fitter.set_function}.

   Three arguments, peak, centre, and fwhm, are mandatory to be set. They specifies an initial model of 
   Gaussian component. 

   The peakfixed, centrefixed, and fwhmfixed are optional parameters to indicate if
   the paramters should be held fixed during the fitting process. The default is to keep all parameters flexible.
   If you want to fix one of those parameters, you can do it by setting corresponding 
   arguments (peakfixed, centrefixed, and fwhmfixed) to 1.
   
   The component argument is only effective for multi-component Gaussian fitting.
   It specifies the number of the component to set the specified parameters.

 
\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
peak && \multicolumn{2}{p{3.36in}|}{The gaussian parameters (peak intensity)}\\
& &allowed: & float \\
& &Default: & 
\\
centre && \multicolumn{2}{p{3.36in}|}{The gaussian parameters (line center)}\\
& &allowed: & float \\
& &Default: & 
\\
fwhm && \multicolumn{2}{p{3.36in}|}{The gaussian parameters (FWHM)}\\
& &allowed: & float \\
& &Default: & 
\\
peakfixed && \multicolumn{2}{p{3.36in}|}{Optional parameters to indicate if peak should be held fixed during the fitting process}\\
& &allowed: & integer \\
& &Default: & 0 (flexible)
\\
centrefixed && \multicolumn{2}{p{3.36in}|}{Optional parameters to indicate if centre should be held fixed during the fitting process}\\
& &allowed: & integer \\
& &Default: & 0 (flexible)
\\
fwhmfixed && \multicolumn{2}{p{3.36in}|}{Optional parameters to indicate if fwhm should be held fixed during the fitting process}\\
& &allowed: & integer \\
& &Default: & 0 (flexible)
\\
component && \multicolumn{2}{p{3.36in}|}{The number of the component}\\
& &allowed: & integer \\
& &Default: & 0
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\

\begin{verbatim}
   f=sd.fitter()
   s=sd.scantable('OrionS_rawACSmod_cal',average=False)
   f.set_scan(s)
   # set fit function as gaussian
   f.set_function(gauss=1)
   # set gaussian parameter with centre fixed
   f.set_gauss_parameters(peak=0.5,centre=4100,fwhm=200,centrefixed=1)
   f.fit() 
\end{verbatim}


%% sd.fitter.set_lorentz_parameters
\newpage
\ahsdfunction{sd.fitter.set\_lorentz\_parameters}{sd.fitter.set_lorentz_parameters}{Set the parameters of Lorentzian component}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

   Set the Parameters of a 'Lorentzian' component, set with \ahlink{set\_function}{sd:sd.fitter.set_function}.

   Three arguments, peak, centre, and fwhm, are mandatory to be set. They specifies an initial model of 
   Lorentzian component. 

   The peakfixed, centrefixed, and fwhmfixed are optional parameters to indicate if
   the paramters should be held fixed during the fitting process. The default is to keep all parameters flexible.
   If you want to fix one of those parameters, you can do it by setting corresponding 
   arguments (peakfixed, centrefixed, and fwhmfixed) to 1.
   
   The component argument is only effective for multi-component Lorentzian fitting.
   It specifies the number of the component to set the specified parameters.

 
\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
peak && \multicolumn{2}{p{3.36in}|}{The lorentzian parameters (peak intensity)}\\
& &allowed: & float \\
& &Default: & 
\\
centre && \multicolumn{2}{p{3.36in}|}{The lorentzian parameters (line center)}\\
& &allowed: & float \\
& &Default: & 
\\
fwhm && \multicolumn{2}{p{3.36in}|}{The lorentzian parameters (FWHM)}\\
& &allowed: & float \\
& &Default: & 
\\
peakfixed && \multicolumn{2}{p{3.36in}|}{Optional parameters to indicate if peak should be held fixed during the fitting process}\\
& &allowed: & integer \\
& &Default: & 0 (flexible)
\\
centrefixed && \multicolumn{2}{p{3.36in}|}{Optional parameters to indicate if centre should be held fixed during the fitting process}\\
& &allowed: & integer \\
& &Default: & 0 (flexible)
\\
fwhmfixed && \multicolumn{2}{p{3.36in}|}{Optional parameters to indicate if fwhm should be held fixed during the fitting process}\\
& &allowed: & integer \\
& &Default: & 0 (flexible)
\\
component && \multicolumn{2}{p{3.36in}|}{The number of the component}\\
& &allowed: & integer \\
& &Default: & 0
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\

\begin{verbatim}
   f=sd.fitter()
   s=sd.scantable('OrionS_rawACSmod_cal',average=False)
   f.set_scan(s)
   # set fit function as lorentzian
   f.set_function(lorentz=1)
   # set lorentzian parameter with centre fixed
   f.set_lorentz_parameters(peak=0.5,centre=4100,fwhm=200,centrefixed=1)
   f.fit() 
\end{verbatim}



%% sd.fitter.set_parameters
\newpage
\ahsdfunction{sd.fitter.set\_parameters}{sd.fitter.set_parameters}{Set the parameters to be fitted}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

   Set the parameters to be fitted.

   It takes an argument that indicates a list of parameter values and preference if those parameters 
   are fixed or flexible during the fit. These lists should be given as a dictionary.
   The params and fixed in the following argument list doesn't indicate argument itself here.
   Instead, they indicate keywords in the above dictionary.

   This method is normally called from 
   \ahlink{set\_gauss\_parameters}{sd:sd.fitter.set_gauss_parameters}, 
   \ahlink{set\_lorentz\_parameters}{sd:sd.fitter.set_lorentz_parameters}, and 
   \ahlink{set\_sinusoid\_parameters}{sd:sd.fitter.set_sinusoid_parameters} so that you may 
   not need to call this method directly. 
 
\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
params && \multicolumn{2}{p{3.36in}|}{A vector of parameters (peak, centre, fwhm)}\\
& &allowed: & float array \\
& &Default: & 
\\
fixed && \multicolumn{2}{p{3.36in}|}{A vector of which parameters are to be held fixed}\\
& &allowed: & float array \\
& &Default: & None (all parameters are flexible)
\\
component && \multicolumn{2}{p{3.36in}|}{In case of multiple gaussians/lorentzians, the index of the component}\\
& &allowed: & integer \\
& &Default: & 0
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.fitter.set_sinusoid_parameters
\newpage
\ahsdfunction{sd.fitter.set\_sinusoid\_parameters}{sd.fitter.set_sinusoid_parameters}{Set the parameters of Sinusoidal component}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

   Set the Parameters of a 'Sinusoidal' component, set with 
   \ahlink{set\_function}{sd:sd.fitter.set_function}.

   Three arguments, ampl, period, and x0, are mandatory to be set. 
   They specifies an initial model of Sinusoidal component. 

   The amplfixed, periodfixed, and x0fixed are optional parameters to indicate if
   the paramters should be held fixed during the fitting process. 
   The default is to keep all parameters flexible.
   If you want to fix one of those parameters, you can do it by setting corresponding 
   arguments (amplfixed, periodfixed, and x0fixed) to 1.
   
   The component argument is only effective for multi-component Sinusoidal fitting.
   It specifies the number of the component to set the specified parameters.


\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
ampl && \multicolumn{2}{p{3.36in}|}{The sinusoidal parameters (amplitude)}\\
& &allowed: & float \\
& &Default: & 
\\
period && \multicolumn{2}{p{3.36in}|}{The sinusoidal parameters (period)}\\
& &allowed: & float \\
& &Default: & 
\\
x0 && \multicolumn{2}{p{3.36in}|}{The sinusoidal parameters (phase offset)}\\
& &allowed: & float \\
& &Default: & 
\\
amplfixed && \multicolumn{2}{p{3.36in}|}{Optional parameters to indicate if ampl should be held fixed during the fitting process}\\
& &allowed: & integer \\
& &Default: & 0 (flexible)
\\
periodfixed && \multicolumn{2}{p{3.36in}|}{Optional parameters to indicate if period should be held fixed during the fitting process}\\
& &allowed: & integer \\
& &Default: & 0 (flexible)
\\
x0fixed && \multicolumn{2}{p{3.36in}|}{Optional parameters to indicate if x0 should be held fixed during the fitting process}\\
& &allowed: & integer \\
& &Default: & 0 (flexible)
\\
component && \multicolumn{2}{p{3.36in}|}{}\\
& &allowed: & integer \\
& &Default: & 0
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.fitter.set_scan
\newpage
\ahsdfunction{sd.fitter.set\_scan}{sd.fitter.set_scan}{Set the data as a scantable}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

   Set the 'data' (a scantable) of the fitter.

 
\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
thescan && \multicolumn{2}{p{3.36in}|}{A scantable}\\
& &allowed: & scantable \\
& &Default: & 
\\
mask && \multicolumn{2}{p{3.36in}|}{A retrieved from the scantable}\\
& &allowed: & bool array \\
& &Default: & 
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.fitter.store_fit
\newpage
\ahsdfunction{sd.fitter.store\_fit}{sd.fitter.store_fit}{Save fit parameters}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

   Save the fit parameters.

   If filename is specified, the method saves the result in an ASCII file.
   Otherwise, the result will be stored in the scantable.
   More specifically, the result will be stored in FIT subtable in the scantable.   

   It works both for spectral line fitting (gaussian or lorentzian fitting) and 
   polynomial fitting although it is not sure if the latter is useful or not.
 
\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
filename && \multicolumn{2}{p{3.36in}|}{If specified, save as an ASCII table}\\
& &allowed: & string \\
& &Default: & None (store result in the scantable)
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\

\begin{verbatim}
   f=sd.fitter()
   s=sd.scantable('OrionS_rawACSmod_cal',average=False)
   f.set_scan(s)
   # set fit function as gaussian
   f.set_function(gauss=1)
   # set gaussian parameter with centre fixed
   f.set_gauss_parameters(peak=0.5,centre=4100,fwhm=200,centrefixed=1)
   f.fit() 
   # store fit in the scantable
   f.store_fit()
   # store fit in an ASCII file
   f.store_fit(filename='fitresult.txt')
\end{verbatim}



%%%%% sd.linecatalog
\newpage
\ahobject{sd.linecatalog}{Line catalog}
%\ahfunction{sd.linecatalog}{Line catalog}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

  The linecatalog is a wrapper for line catalog data base. 
  These can be either ASCII tables or the tables saved from this class.
  The table consists of the following items:

  \begin{itemize}
  \item row index in the table
  \item name of the species
  \item line frequency 
  \item frequency error
  \item line intensity
  \end{itemize}

  The user can filter lines by name, frequency range, or intensity range.
  It is possible to overlay line catalog on the spectral plot using 
  \ahlink{plotter.plot\_lines}{sd:sd.plotter.plot_lines}.

  For ASCII type input table, Comments can be present through lines 
  starting with '\#'.

  The constructor takes string that specifies a name of the catalog.

  \medskip\noindent\textbf{Known Issues}

   The name of species canno't contain spaces. If it does, it has to be 
   wrapped in double-quotes. 

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
name&& \multicolumn{2}{p{3.36in}|}{Name of the catalog}\\
& &allowed: & string\\
& &Default: & 
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\
\begin{verbatim}
        l = sd.linecatalog('jpl_asap.tbl')
        # set name restriction
        l.set_name('NH3')
        # print summary
        l.summary()
\end{verbatim}

  
Methods
\begin{longtable}{ll}

	\ahlink{get\_frequency}{sd:sd.linecatalog.get_frequency} & Get frequency in a specified row \\

	\ahlink{get\_name}{sd:sd.linecatalog.get_name} & Get name of specie in a specified row \\

	\ahlink{get\_row}{sd:sd.linecatalog.get_row} & Get the values in a specified row \\

	\ahlink{nrow}{sd:sd.linecatalog.nrow} & Get number of rows in the table \\

	\ahlink{reset}{sd:sd.linecatalog.reset} & Unset all filtering to the table \\

	\ahlink{save}{sd:sd.linecatalog.save} & Save the subset of the table to disk \\

	\ahlink{set\_frequency\_limits}{sd:sd.linecatalog.set_frequency_limits} & Set frequency limit on the table \\

	\ahlink{set\_name}{sd:sd.linecatalog.set_name} & Set a name restriction on the table \\

	\ahlink{set\_strength\_limits}{sd:sd.linecatalog.set_strength_limits} & Set line strength limit on the table \\

	\ahlink{summary}{sd:sd.linecatalog.summary} & Print the contents of the table \\

\end{longtable}


%% sd.linecatalog.get_frequency
\newpage
\ahsdfunction{sd.linecatalog.get\_frequency}{sd.linecatalog.get_frequency}{Get frequency in a specified row}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

   The method returns a frequency value in the catalog for given row number.

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
&& \multicolumn{2}{p{3.36in}|}{Row number}\\
& &allowed: & integer \\
& &Default: & 
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline
float

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.linecatalog.get_name
\newpage
\ahsdfunction{sd.linecatalog.get\_name}{sd.linecatalog.get_name}{Get name of specie in a specified row}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

   The method returns a name of species in the catalog for given row number.

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
&& \multicolumn{2}{p{3.36in}|}{Row number}\\
& &allowed: & integer \\
& &Default: & 
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline
string

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.linecatalog.get_row
\newpage
\ahsdfunction{sd.linecatalog.get\_row}{sd.linecatalog.get_row}{Get the values in a specified row}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

   The method returns the values in a specified row of the catalog.
   Returned value is a dictionary that contains a name of the species and its frequency 
   for that row.

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
row && \multicolumn{2}{p{3.36in}|}{The row to retrieve}\\
& &allowed: & integer \\
& &Default: & 0
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline
dictionary

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.linecatalog.nrow
\newpage
\ahfunction{sd.linecatalog.nrow}{Get number of rows in the table}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

   The method returns a number of rows of the catalog.

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\flushleft\vspace{.20in}\textbf {Returns}\newline
integer

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.linecatalog.reset
\newpage
\ahfunction{sd.linecatalog.reset}{Unset all filtering to the table}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

    This method resets the table to its initial state, i.e. undo all calls of filtering methods 
    on the catalog.
 
\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\flushleft\vspace{.20in}\textbf {Returns}\newline

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.linecatalog.save
\newpage
\ahfunction{sd.linecatalog.save}{Save the subset of the table to disk}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

   Save the subset of the table to disk. This uses an internal data format and can be read in again.
   If no filtering is done on the catalog, it just copies the original catalog. 

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
name && \multicolumn{2}{p{3.36in}|}{The name of the output catalog}\\
& &allowed: & string \\
& &Default: & 
\\
overwrite && \multicolumn{2}{p{3.36in}|}{Overwrite existing table if True}\\
& &allowed: & bool \\
& &Default: & False
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.linecatalog.set_frequency_limits
\newpage
\ahsdfunction{sd.linecatalog.set\_frequency\_limits}{sd.linecatalog.set_frequency_limits}{Set frequency limit on the table}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

    Set frequency limits on the table.

    Note that the underlying table contains frequency values in MHz
 
\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
fmin && \multicolumn{2}{p{3.36in}|}{The lower bound}\\
& &allowed: & float \\
& &Default: & 1.0
\\
fmax && \multicolumn{2}{p{3.36in}|}{The upper bound}\\
& &allowed: & float \\
& &Default: & 120.0
\\
unit && \multicolumn{2}{p{3.36in}|}{The frequency unit}\\
& &allowed: & string ('GHz' or 'MHz') \\
& &Default: & 'GHz'
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.linecatalog.set_name
\newpage
\ahsdfunction{sd.linecatalog.set\_name}{sd.linecatalog.set_name}{Set a name restriction on the table}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

    Set a name restriction on the table. This can be a standard unix-style
    pattern or a regular expression.
 
\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
name && \multicolumn{2}{p{3.36in}|}{The name pattern/regex}\\
& &allowed: & string \\
& &Default: & 
\\
mode && \multicolumn{2}{p{3.36in}|}{The matching mode, i.e. 'pattern' or 'regex'}\\
& &allowed: & string \\
& &Default: & 'pattern'
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.linecatalog.set_strength_limits
\newpage
\ahsdfunction{sd.linecatalog.set\_strength\_limits}{sd.linecatalog.set_strength_limits}{Set line strength limit on the table}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

    Set line strength limits on the table (arbitrary units).
 
\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
smin && \multicolumn{2}{p{3.36in}|}{The lower bound}\\
& &allowed: & float \\
& &Default: & 
\\
smax && \multicolumn{2}{p{3.36in}|}{The upper bound}\\
& &allowed: & float \\
& &Default: & 
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.linecatalog.summary
\newpage
\ahfunction{sd.linecatalog.summary}{Print the contents of the table}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

   Print the contents of the table. 

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\flushleft\vspace{.20in}\textbf {Returns}\newline

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\

\begin{verbatim}
   l=sd.linecatalog('jpl_asap.tbl')
   l.set_name('NH3')
   l.summary()
   # the output should look like the following
   --------------------------------------------------------------------------------
   Line Catalog summary
   --------------------------------------------------------------------------------

         0  NH3                 10293.659   -7.9334     
         1  NH3                 10426.949   -7.6822     
         2  NH3                 10536.183   -7.3906     
         3  NH3                 10836.127   -7.8889     
         4  NH3                 11132.722   -7.6055     
         5  NH3                 11673.171   -7.6559     
         6  NH3                 11947.244   -7.2809     
         7  NH3                 12251.33    -6.9818     
         8  NH3                 12336.462   -7.4568     
         9  NH3                 12923.04    -6.9522     
        10  NH3                 12951.048   -7.4088     
        11  NH3                 13296.342   -6.7014     
        12  NH3                 13297.266   -7.316      
        13  NH3                 13612.146   -7.5443     
        14  NH3                 13700.883   -6.6744     
        15  NH3                 13719.23    -6.9543     
        16  NH3                 13974.605   -6.897      
        17  NH3                 14224.647   -6.3276     
        18  NH3                 14376.817   -6.1817     
\end{verbatim}



%%%%% sd.linefinder
\newpage
\ahobject{sd.linefinder}{Line finder tool for single-dish spectrum}
%\ahfunction{sd.linefinder}{Line finder tool for single-dish spectrum}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\
  
  The linefinder performs automated spectral line search.
  The algorithm involves a simple threshold criterion. The line is
  considered to be detected if a specified number of consecutive
  channels (default is 3) is brighter (with respect to the current baseline
  estimate) than the threshold times the noise level. This criterion is
  applied in the iterative procedure updating baseline estimate and trying
  reduced spectral resolutions to detect broad lines as well. The off-line
  noise level is determined at each iteration as an average of 80\% of the
  lowest variances across the spectrum (i.e. histogram equalization is
  used to avoid missing weak lines if strong ones are present). For
  bad baseline shapes it is recommended to increase the threshold and
  possibly switch the averaging option off (see \ahlink{set\_options}{sd:sd.linefinder.set_options}) to
  detect strong lines only, fit a high order baseline and repeat the line
  search.

  There are six parameters for the algorithm. These can be set by 
  \ahlink{set\_options}{sd:sd.linefinder.set_options} method of this object. 

  \begin{itemize}
  \item threshold \\ A single channel S/N ratio above which the channel is considered to be a detection.
                     Default is sqrt(3), which together with min\_nchan=3 gives a 3-sigma criterion

  \item min\_nchan \\ A minimal number of consequtive channels, which should satisfy a threshold 
                      criterion to be a detection. Default is 3.

  \item avg\_limit \\ A number of consequtive channels not greater than
                      this parameter can be averaged to search for
                      broad lines. Default is 8.
  \item box\_size \\ A running mean/median box size specified as a fraction
                     of the total spectrum length. Default is 1/5

  \item noise\_box \\ Area of the spectrum used to estimate noise stats.
                      Both string values and numbers are allowed
                      Allowed string values are 
                      'all' that use all the spectrum (default), and 
                      'box' means noise box is the same as running mean/median box.
                      Numeric values are defined as a fraction from the
                      spectrum size. Values should be positive.
                      (noise\_box == box\_size has the same effect as
                       noise\_box = 'box')

  \item noise\_stat \\ Statistics used to estimate noise. Allowed values are 
                       'mean80' that use the 80\% of the lowest deviations in the noise box (default)
                       and 'median' means median of deviations in the noise box.

  \end{itemize}

  The constructor doesn't take any arguments. It creates linefinder 
  object without any settings for line finding.

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\

\begin{verbatim}
       fl=sd.linefinder()
       sc=sd.scantable('sddata.asap',average=False)
       # set data
       fl.set_scan(sc)
       # set linefinder options
       fl.set_options(threshold=3)
       # search lines
       nlines=fl.find_lines(edge=(50,0))
       # get range of lines found
       if nlines!=0:
          print "Found ",nlines," spectral lines"
          print fl.get_ranges(False)
       else:
          print "No lines found!"
       # baseline subtraction using masks provided by linefinder
       sc2=sc.poly_baseline(fl.get_mask(),7)
\end{verbatim}

    
Methods
\begin{longtable}{ll}

	\ahlink{find\_lines}{sd:sd.linefinder.find_lines} & Search for spectral lines in the scan \\

	\ahlink{get\_mask}{sd:sd.linefinder.get_mask} & Get the mask to mask all lines that have been found \\

	\ahlink{get\_ranges}{sd:sd.linefinder.get_ranges} & Get ranges for all spectral lines found \\

	\ahlink{set\_data}{sd:sd.linefinder.set_data} & Set the data as an array \\

	\ahlink{set\_options}{sd:sd.linefinder.set_options} & Set the parameters of the line finding algorithm \\

	\ahlink{set\_scan}{sd:sd.linefinder.set_scan} & Set the data as a scantable \\

\end{longtable}


%% sd.linefineder.find_lines
\newpage
\ahsdfunction{sd.linefinder.find\_lines}{sd.linefinder.find_lines}{Search for spectral lines in the scan}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

    Search for spectral lines in the scan assigned in \ahlink{set\_scan}{sd:sd.linefinder.set_scan}.
    A number of lines found will be returned.

    The method allows to set optional masks for the search. The mask parameter is a bool array 
    that sets channel-by-channel masking. On the other hand, the edge parameter set a number of 
    channels to drop at the edge of the spectrum. The number can be set for each side as an integer 
    array with length of two. 
    If only one value is specified, the same number will be dropped from both sides of the spectrum.
 
\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
nRow&& \multicolumn{2}{p{3.36in}|}{A row number in the scantable to work with}\\
& &allowed: & integer \\
& &Default: & 0
\\
mask&& \multicolumn{2}{p{3.36in}|}{An optional mask}\\
& &allowed: & bool array \\
& &Default: & [] (no mask)
\\
edge&& \multicolumn{2}{p{3.36in}|}{An optional number of channels to drop at the edge of the spectrum}\\
& &allowed: & integer, integer array \\
& &Default: & (0,0) (keep all channels)
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline
integer

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.linefinder.get_mask
\newpage
\ahsdfunction{sd.linefinder.get\_mask}{sd.linefinder.get_mask}{Get the mask to mask all lines that have been found}


\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

   By default, the method returns the mask to mask out all lines that have been found. 
   If the invert option is True, inverted mask that only channels belong to lines are unmasked, 
   will be returned.

   Note that all channels originally masked by the input mask or dropped out by the edge parameter 
   will still be excluded regardless on the invert option.

 
\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
invert&& \multicolumn{2}{p{3.36in}|}{If True, only channels belong to lines will be unmasked}\\
& &allowed: & bool \\
& &Default: & False
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline
bool array

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.linefinder.get_ranges
\newpage
\ahsdfunction{sd.linefinder.get\_ranges}{sd.linefinder.get_ranges}{Get ranges for all spectral lines found}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

   The method returns ranges (start and end channels or velocities) for all spectral lines found.

   By default, the unit of returned values will be used the same unit as set for the scan that is 
   set by this object using \ahlink{set\_scan}{sd:sd.linefinder.set_scan}.
   If defunits option is set to False, the range will always be expressed in channels.

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
defunits&& \multicolumn{2}{p{3.36in}|}{If False, the returned range will be expressed in channels}\\
& &allowed: & bool \\
& &Default: & True
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline
bool array

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.linefinder.set_data
\newpage
\ahsdfunction{sd.linefinder.set\_data}{sd.linefinder.set_data}{Set the data as an array}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

    Set the 'data' (spectrum) to work with
    Parameters: a method to allow linefinder work without setting scantable
    for the purpose of using linefinder inside some method in scantable
    class. (Dec 22, 2010 by W.Kawasaki)

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
spectrum&& \multicolumn{2}{p{3.36in}|}{The data to be set}\\
& &allowed: & float array \\
& &Default: & 
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.linefinder.set_options
\newpage
\ahsdfunction{sd.linefinder.set\_options}{sd.linefinder.set_options}{Set the parameters of the line finding algorithm}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

   This method is used to set the parameters of the line finding algorithm.
   There are six parameters that can be set by this method. See 
   \ahlink{description}{sd:sd.linefinder} of 
   this object for details about parameters.

   Note that, for bad baselines, threshold should be increased, and avg\_limit decreased 
   (or even switched off completely by setting this parameter to 1) to avoid detecting baseline
   undulations instead of real lines.

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
threshold&& \multicolumn{2}{p{3.36in}|}{A single channel S/N ratio above which the channel is considered to be a detection.}\\
& &allowed: & float \\
& &Default: & sqrt(3)
\\
min\_nchan&& \multicolumn{2}{p{3.36in}|}{A minimal number of consequtive channels, which should satisfy a threshold criterion to be a detection.}\\
& &allowed: & integer \\
& &Default: & 3
\\
avg\_limit&& \multicolumn{2}{p{3.36in}|}{A number of consequtive channels not greater than this parameter can be averaged to search for broad lines.}\\
& &allowed: & integer \\
& &Default: & 8
\\
box\_size&& \multicolumn{2}{p{3.36in}|}{A running mean/median box size specified as a fraction of the total spectrum length.}\\
& &allowed: & float \\
& &Default: & 0.2
\\
noise\_box&& \multicolumn{2}{p{3.36in}|}{Area of the spectrum used to estimate noise stats}\\
& &allowed: & float, string ('all' or 'box') \\
& &Default: & 'all'
\\
noise\_stat&& \multicolumn{2}{p{3.36in}|}{Statistics used to estimate noise}\\
& &allowed: & string ('mean80' or 'median') \\
& &Default: & 'mean80'
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.linefinder.set_scan
\newpage
\ahsdfunction{sd.linefinder.set\_scan}{sd.linefinder.set_scan}{Set the data as a scantable}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

   The method sets the data to work with.
   The data must be given as a scantable.

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
scan&& \multicolumn{2}{p{3.36in}|}{The data to be set}\\
& &allowed: & scantable \\
& &Default: & 
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%%%%% sd.simplelinefinder
\newpage
\ahobject{sd.simplelinefinder}{Simplified line finder tool for single-dish spectrum}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

    A simplified class to search for spectral features. The algorithm assumes that the bandpass
    is taken out perfectly and no spectral channels are flagged (except some edge channels).
    It works with a list or tuple rather than a scantable and returns the channel pairs.
    There is an optional feature to attempt to split the detected lines into components, although
    it should be used with caution. This class is largely intended to be used with scripts.
    
    The fully featured version of the algorithm working with scantables is called 
    \ahlink{linefinder}{sd:sd.linefinder}.

Methods
\begin{longtable}{ll}

	\ahlink{channelRange}{sd:sd.simplelinefinder.channelRange} & Convert supplied velocity range into the channel range \\

	\ahlink{find\_lines}{sd:sd.simplelinefinder.find_lines} & Search for spectral lines in the spectrum \\

	\ahlink{invertChannelSelection}{sd:sd.simplelinefinder.invertChannelSelection} & Invert channel range selection \\

	\ahlink{median}{sd:sd.simplelinefinder.median} & Return a median of the last spectrum passed to \ahlink{find\_lines}{sd:sd.simplelinefinder.find_lines} \\

	\ahlink{rms}{sd:sd.simplelinefinder.rms} & Return rms calculated during last \ahlink{find\_lines}{sd:sd.simplelinefinder.find_lines} call \\

	\ahlink{writeLog}{sd:sd.simplelinefinder.writeLog} & Write user defined string into log file \\

\end{longtable}


%% sd.simplelinefineder.channelRange
\newpage
\ahfunction{sd.simplelinefinder.channelRange}{Convert supplied velocity range into the channel range}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

    A helper method which works on a tuple with abcissa/flux vectors 
    (i.e. as returned by uvSpectrum). It allows to convert supplied 
    velocity range into the channel range.

    The argument spc specifies abcissa/flux vectors as tuple. First and second elements of the 
    tuple should be abcissa value and spectrum itself, respectively. 
    The argument vel\_range must be 2-element tuple that indicates start and stop velocity 
    of range.
    
    Note, if supplied range is completely outside the spectrum, an empty tuple will be returned.

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{tuple with the abcissa and spectrum}\\
spc && \multicolumn{2}{p{3.36in}|}{}\\
& &allowed: & tuple \\
& &Default: & 
\\
vel\_range && \multicolumn{2}{p{3.36in}|}{a 2-element tuple with start and stop velocity of the range}\\
& &allowed: & tuple \\
& &Default: & 
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline
a 2-element tuple with channels

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.simplelinefineder.find_lines
\newpage
\ahsdfunction{sd.simplelinefinder.find\_lines}{sd.simplelinefinder.find_lines}{Search for spectral lines in the spectrum}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

    A simple spectral line detection routine, which assumes that bandpass has been
    taken out perfectly and no channels are flagged within the spectrum. A detection
    is reported if consequtive minchan number of channels is consistently above or
    below the median value. The threshold is given in terms of the rms calculated
    using 80\% of the lowest data points by the absolute value (with respect to median).
 
    This method returns a list of tuples each containing start and stop 0-based channel
    number of every detected line. Empty list if nothing has been detected.
    
     Note. The median and rms about this median is stored inside this class and can
    be obtained with rms and median methods.

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
spc && \multicolumn{2}{p{3.36in}|}{a list or tuple with the spectrum, no default}\\
& &allowed: & tuple \\
& &Default: & 
\\
edge && \multicolumn{2}{p{3.36in}|}{detection threshold}\\
& &allowed: & intger \\
& &Default: & 0
\\
minchan && \multicolumn{2}{p{3.36in}|}{minimum number of consequitive channels exceeding threshold to claim the detection}\\
& &allowed: & integer \\
& &Default: & 3
\\
tailsearch && \multicolumn{2}{p{3.36in}|}{if True (default), the algorithm attempts to widen each line until its flux crosses the median. It merges lines if necessary}\\
& &allowed: & bool \\
& &Default: & True
\\
splitFeatures && \multicolumn{2}{p{3.36in}|}{if True, the algorithm attempts to split each detected spectral feature into a number of spectral lines (just one local extremum)}\\
& &allowed: & bool \\
& &Default: & False
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline
list of tuples that indicates ranges of detected lines

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.simplelinefineder.invertChannelSelection
\newpage
\ahfunction{sd.simplelinefinder.invertChannelSelection}{Invert channel range selection}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

    This method converts a tuple with channel ranges to a tuple which covers all channels
    not selected by the original tuple (optionally edge channels can be discarded).
 
    Note, at this stage channel ranges are assumed to be sorted and without overlap.

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
nchan && \multicolumn{2}{p{3.36in}|}{number of channels in the spectrum}\\
& &allowed: & integer \\
& &Default: & 
\\
chans && \multicolumn{2}{p{3.36in}|}{list of start and stop channels for all selected ranges}\\
& &allowed: & tuple \\
& &Default: & 
\\
edge&& \multicolumn{2}{p{3.36in}|}{how many channels to reject from the edge of spectrum}\\
& &allowed: & integer or tuple\\
& &Default: & (0,0)
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline
tuple with inverted channel selection

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.simplelinefineder.median
\newpage
\ahfunction{sd.simplelinefinder.median}{Return a median of the last spectrum passed to \ahlink{find\_lines}{sd:sd.simplelinefinder.find_lines}}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

    Return the median of the last spectrum passed to find\_lines.
    Note, this method throws an exception if 
    \ahlink{find\_lines}{sd:sd.simplelinefinder.find_lines} has never been called.

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\

\flushleft\vspace{.20in}\textbf {Returns}\newline
float 

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.simplelinefineder.rms
\newpage
\ahfunction{sd.simplelinefinder.rms}{Return rms calculated during last \ahlink{find\_lines}{sd:sd.simplelinefinder.find_lines} call}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

    Return rms scatter of the spectral points (with respect to the median) calculated
    during last find\_lines call. Note, this method throws an exception if
    \ahlink{find\_lines}{sd:sd.simplelinefinder.find_lines} has never been called.

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\

\flushleft\vspace{.20in}\textbf {Returns}\newline
float 

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.simplelinefineder.writeLog
\newpage
\ahfunction{sd.simplelinefinder.writeLog}{Write user defined string into log file}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

    Write user defined string into log file.

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
str && \multicolumn{2}{p{3.36in}|}{log message}\\
& &allowed: & string \\
& &Default: & 
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%%%%% sd.plotter
\newpage
\ahobject{sd.plotter}{Single-dish specific plotter tool}
%\ahfunction{sd.sdplotter}{Single-dish specific plotter tool}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

  This is a plotter object that is properly designed for single-dish tool.
  It supports stacking, multi-panel plotting, and multi-page plotting of 
  spectral plot (channel/frequency/velocity versus spectral data).
  For total power (single-channel) data, it provides special function to 
  plot total power data versus time. 
  It also supports to plot time variation of azimuth and elevation and 
  to plot pointing directions on the sky.

  \medskip\noindent\textbf{Known Issues}

   The multi-page plotting doesn't support to go back previous page 
   at the moment, it only allows to go forward.  

Methods
\begin{longtable}{ll}

	\ahlink{annotate}{sd:sd.plotter.annotate} & Annotate text at specified location \\

	\ahlink{arrow}{sd:sd.plotter.arrow} & Draw arrow on specified axis \\

	\ahlink{axhline}{sd:sd.plotter.axhline} & Draw a horizontal line \\

	\ahlink{axhspan}{sd:sd.plotter.axhspan} & Draw a horizontal rectangle \\

	\ahlink{axvline}{sd:sd.plotter.axvline} & Draw a vertical line \\

	\ahlink{axvspan}{sd:sd.plotter.axvspan} & Draw a vertical rectangle \\

        \ahlink{casabar\_exists}{sd:sd.plotter.casabar_exists} & Check if casa toolbar exists or not \\

        \ahlink{clear\_header}{sd:sd.plotter.clear_header} & Clear header \\

	\ahlink{create\_mask}{sd:sd.plotter.create_mask} & Interactively define a mask \\

	\ahlink{figtext}{sd:sd.plotter.figtext} & Add text to figure at specified location \\

	\ahlink{gca}{sd:sd.plotter.gca} & Get current axes \\

	\ahlink{plot}{sd:sd.plotter.plot} & Plot a scantable \\

	\ahlink{plot\_lines}{sd:sd.plotter.plot_lines} & Plot a line catalog \\

	\ahlink{plotazel}{sd:sd.plotter.plotazel} & Plot azimuth and elevation versus time of a scantable \\

	\ahlink{plotpointing}{sd:sd.plotter.plotpointing} & Plot telescope pointings in a scantable \\

	\ahlink{plottp}{sd:sd.plotter.plottp} & Plot total power data \\

	\ahlink{print\_header}{sd:sd.plotter.print_header} & Print header of the scantable on the plot and/or logger \\

	\ahlink{refresh}{sd:sd.plotter.refresh} & Do a soft refresh on the plot \\

	\ahlink{save}{sd:sd.plotter.save} & Save the plot to a file \\

	\ahlink{set\_abcissa}{sd:sd.plotter.set_abcissa} & Set the x-axis label of the plot \\

	\ahlink{set\_colors}{sd:sd.plotter.set_colors} & Set the colors to be used \\

	\ahlink{set\_colours}{sd:sd.plotter.set_colours} & Set the colors to be used \\

	\ahlink{set\_data}{sd:sd.plotter.set_data} & Set a scantable to plot \\

	\ahlink{set\_font}{sd:sd.plotter.set_font} & Set font properties \\

	\ahlink{set\_histogram}{sd:sd.plotter.set_histogram} & Enable/Disable histogram plotting \\

	\ahlink{set\_layout}{sd:sd.plotter.set_layout} & Set the multi-panel layout \\

	\ahlink{set\_legend}{sd:sd.plotter.set_legend} & Specify a mapping for the legend \\

	\ahlink{set\_linestyles}{sd:sd.plotter.set_linestyles} & Set the linestyles to be used \\

	\ahlink{set\_mask}{sd:sd.plotter.set_mask} & Set a plotting mask for a specific selection of the data \\

	\ahlink{set\_mode}{sd:sd.plotter.set_mode} & Set the plots look and feel \\

	\ahlink{set\_ordinate}{sd:sd.plotter.set_ordinate} & Set y-axis label of the plot \\

%	\ahlink{set\_panellayout}{sd:sd.plotter.set_panellayout} & Set layout of subplots \\

	\ahlink{set\_panelling}{sd:sd.plotter.set_panelling} & Set the panelling mode \\

	\ahlink{set\_range}{sd:sd.plotter.set_range} & Set the range of interest on the abcissa of the plot \\

	\ahlink{set\_selection}{sd:sd.plotter.set_selection} & Set selection to the data \\

	\ahlink{set\_stacking}{sd:sd.plotter.set_stacking} & Set the stacking mode \\

	\ahlink{set\_title}{sd:sd.plotter.set_title} & Set the title of the plot \\

	\ahlink{text}{sd:sd.plotter.text} & Add text in a specified location \\

\end{longtable}


%% sd.plotter.annotate
\newpage
\ahfunction{sd.plotter.annotate}{Annotate text at specified location}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

   Annotate text at specified location.
   This is an interface for matplotlib.axes.Axes.annotate function.

   The interactive argument is specific to this method (not available 
   from matplotlib). If it is True, you can set positions interactively 
   using GUI panel.
 
\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\

    See matplotlib help about detailed description of arguments.

\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
text && \multicolumn{2}{p{3.36in}|}{Annotate text}\\
& &allowed: & string \\
& &Default: & 
\\
xy && \multicolumn{2}{p{3.36in}|}{Position of the annotation}\\
& &allowed: & float array \\
& &Default: & 
\\
xytext && \multicolumn{2}{p{3.36in}|}{Position of the text}\\
& &allowed: & float array \\
& &Default: & None (use xy value)
\\
xycoords && \multicolumn{2}{p{3.36in}|}{Coordinate of xy}\\
& &allowed: & string \\
& &Default: & 'data'
\\
textcoords && \multicolumn{2}{p{3.36in}|}{Coordinate of xytext}\\
& &allowed: & string \\
& &Default: & 'data'
\\
arrowprops && \multicolumn{2}{p{3.36in}|}{Line properties for the arrow}\\
& &allowed: & dictionary \\
& &Default: & None
\\
interactive && \multicolumn{2}{p{3.36in}|}{Interactively set text position if True}\\
& &allowed: & bool \\
& &Default: & 
\\

\hline
\end{tabular}


\flushleft\vspace{.20in}\textbf {Returns}\newline

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.plotter.arrow
\newpage
\ahfunction{sd.plotter.arrow}{Draw arrow on specified axis}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

   Draws arrow on specified axis from (x,y) to (x+dx,y+dy).
   This is an interface for matplotlib.axes.Axes.arrow function.

   The interactive argument is specific to this method (not available 
   from matplotlib). If it is True, you can set positions interactively 
   using GUI panel.

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\

    See matplotlib help about detailed description of arguments.

\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
x && \multicolumn{2}{p{3.36in}|}{x position for the origin of the arrow}\\
& &allowed: & float \\
& &Default: & 
\\
y && \multicolumn{2}{p{3.36in}|}{y position for the origin of the arrow}\\
& &allowed: & float \\
& &Default: & 
\\
dx && \multicolumn{2}{p{3.36in}|}{x position for the terminal of the arrow (offset from origin)}\\
& &allowed: & float \\
& &Default: & 
\\
dy && \multicolumn{2}{p{3.36in}|}{y position for the terminal of the arrow (offset from origin)}\\
& &allowed: & float \\
& &Default: & 
\\
interactive && \multicolumn{2}{p{3.36in}|}{Interactively set origin and terminal of the arrow if True}\\
& &allowed: & bool \\
& &Default: & 
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.plotter.axhline
\newpage
\ahfunction{sd.plotter.axhline}{Draw a horizontal line}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

   Draw a horizontal line.
   This is an interface for matplotlib.axes.Axes.axhline function.

   The interactive argument is specific to this method (not available 
   from matplotlib). If it is True, you can set positions interactively 
   using GUI panel.
 
\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\

    See matplotlib help about detailed description of arguments.

\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
y && \multicolumn{2}{p{3.36in}|}{y position of the horizontal line}\\
& &allowed: & float \\
& &Default: & 
\\
xmin && \multicolumn{2}{p{3.36in}|}{Origin of the horizontal line}\\
& &allowed: & float \\
& &Default: & 0
\\
xmax && \multicolumn{2}{p{3.36in}|}{Terminate of the horizontal line}\\
& &allowed: & float \\
& &Default: & 1
\\
interactive && \multicolumn{2}{p{3.36in}|}{Interactively set origin and terminal of the line if True}\\
& &allowed: & bool \\
& &Default: & 
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline
Line2D object

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.plotter.axhspan
\newpage
\ahfunction{sd.plotter.axhspan}{Draw a horizontal rectangle}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

   Draw a horizontal rectangle.  
   This is an interface for matplotlib.axes.Axes.axhspan function.

   The interactive argument is specific to this method (not available 
   from matplotlib). If it is True, you can set positions interactively 
   using GUI panel.

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\

    See matplotlib help about detailed description of arguments.

\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
ymin && \multicolumn{2}{p{3.36in}|}{Bottom edge of the rectangle}\\
& &allowed: & float \\
& &Default: & 
\\
ymax && \multicolumn{2}{p{3.36in}|}{Top edge of the rectangle}\\
& &allowed: & float \\
& &Default: & 
\\
xmin && \multicolumn{2}{p{3.36in}|}{Left edge of the rectangle}\\
& &allowed: & float \\
& &Default: & 0
\\
xmax && \multicolumn{2}{p{3.36in}|}{Right edge of the rectangle}\\
& &allowed: & float \\
& &Default: & 1
\\
interactive && \multicolumn{2}{p{3.36in}|}{Interactively set the shape of the rectangle if True}\\
& &allowed: & bool \\
& &Default: & 
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline
Polygon object

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.plotter.axvline
\newpage
\ahfunction{sd.plotter.axvline}{Draw a vertical line}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

   Draw a vertical line.
   This is an interface for matplotlib.axes.Axes.axvline function.

   The interactive argument is specific to this method (not available 
   from matplotlib). If it is True, you can set positions interactively 
   using GUI panel.

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\

    See matplotlib help about detailed description of arguments.

\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
x && \multicolumn{2}{p{3.36in}|}{x position of the vertical line}\\
& &allowed: & float \\
& &Default: & 
\\
ymin && \multicolumn{2}{p{3.36in}|}{Origin of the vertical line}\\
& &allowed: & float \\
& &Default: & 0
\\
ymax && \multicolumn{2}{p{3.36in}|}{Terminate of the vertical line}\\
& &allowed: & float \\
& &Default: & 1
\\
interactive && \multicolumn{2}{p{3.36in}|}{Interactively set origin and terminal of the line if True}\\
& &allowed: & bool \\
& &Default: & 
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline
Line2D object 

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.plotter.axvspan
\newpage
\ahfunction{sd.plotter.axvspan}{Draw a vertical rectangle}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

   Draw a vertical rectangle.
   This is an interface for matplotlib.axes.Axes.axvspan function.

   The interactive argument is specific to this method (not available 
   from matplotlib). If it is True, you can set positions interactively 
   using GUI panel.

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\

    See matplotlib help about detailed description of arguments.

\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
xmin && \multicolumn{2}{p{3.36in}|}{Left edge of the rectangle}\\
& &allowed: & float \\
& &Default: & 
\\
xmax && \multicolumn{2}{p{3.36in}|}{Right edge of the rectangle}\\
& &allowed: & float \\
& &Default: & 
\\
ymin && \multicolumn{2}{p{3.36in}|}{Bottom edge of the rectangle}\\
& &allowed: & float \\
& &Default: & 0
\\
ymax && \multicolumn{2}{p{3.36in}|}{Top edge of the rectangle}\\
& &allowed: & float \\
& &Default: & 1
\\
interactive && \multicolumn{2}{p{3.36in}|}{Interactively set the shape of the rectangle if True}\\
& &allowed: & bool \\
& &Default: & 
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline
Polygon object

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.plotter.casabar_exists
\newpage
\ahsdfunction{sd.plotter.casabar\_exists}{sd.plotter.casabar_exists}{Check if casa toolbar exists or not}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

    The function checks if plotter object associates with casa toolbar. It returns True if 
    the object associates with casa toolbar. Otherwise, it returns False.

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\

\flushleft\vspace{.20in}\textbf {Returns}\newline
bool 

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.plotter.clear_header
\newpage
\ahsdfunction{sd.plotter.clear\_header}{sd.plotter.clear_header}{Clear header}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

    The function clears out header information from the plotter object.
    Nothing is done if plotter object doesn't have header.

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\

\flushleft\vspace{.20in}\textbf {Returns}\newline

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.plotter.create_mask
\newpage
\ahsdfunction{sd.plotter.create\_mask}{sd.plotter.create_mask}{Interactively define a mask}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

    Interactively define a mask. It retruns a mask that is equivalent to
    the one created manually with \ahlink{scantable.create\_mask}{sd:sd.scantable.create_mask}.

    The nwin argument indicates a number of mask windows to create interactively. 
    The panel argument specifies which panel to use for mask selection (0-based). This is 
    useful if different IFs are spread over panels.

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
nwin && \multicolumn{2}{p{3.36in}|}{Number of mask windows to create interactively}\\
& &allowed: & integer \\
& &Default: & 1
\\
panel && \multicolumn{2}{p{3.36in}|}{Which panel to use for mask selection}\\
& &allowed: & integer \\
& &Default: & 0 
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline
bool array

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.plotter.figtext
\newpage
\ahfunction{sd.plotter.figtext}{Add text to figure at specified location}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

    Add text to figure at location x,y (relative 0-1 coords).
    This method forwards *args and **kwargs to a Matplotlib method,
    matplotlib.Figure.text.
    See the method help for detailed information.

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
x && \multicolumn{2}{p{3.36in}|}{x position of the text}\\
& &allowed: & float \\
& &Default: & 
\\
y && \multicolumn{2}{p{3.36in}|}{y position of the text}\\
& &allowed: & float \\
& &Default: &  
\\
s && \multicolumn{2}{p{3.36in}|}{Text to be added}\\
& &allowed: & string \\
& &Default: & 
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.plotter.gca
\newpage
\ahfunction{sd.plotter.gca}{Get current axes}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

   Return the current axis object.

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\flushleft\vspace{.20in}\textbf {Returns}\newline
Subplot object

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.plotter.plot
\newpage
\ahfunction{sd.plotter.plot}{Plot a scantable}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

    Plot a scantable.

    If a scantable was specified in a previous call
    to plot, no argument has to be given to 'replot'
    NO checking is done that the abcissas of the scantable
    are consistent e.g. all 'channel' or all 'velocity' etc.


\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
scan && \multicolumn{2}{p{3.36in}|}{A scantable}\\
& &allowed: & scantable \\
& &Default: & None 
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\

\begin{verbatim}
   #create scantable
   s=sd.scantable('OrionS_rawACSmod_cal',average=False)
   # plot
   sd.plotter.plot(s)
\end{verbatim}


%% sd.plotter.plot_lines
\newpage
\ahsdfunction{sd.plotter.plot\_lines}{sd.plotter.plot_lines}{Plot a line catalog}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

    Plot a line catalog.

    The linecat argument specifies actual catalog to be plot. 
    It must be given as a \ahlink{linecatalog}{sd:sd.linecatalog} object.

    Note that if the spectrum is flagged no line will be drawn in that location.

 
\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
linecat && \multicolumn{2}{p{3.36in}|}{The linecatalog to plot}\\
& &allowed: & linecatalog \\
& &Default: & None 
\\
doppler && \multicolumn{2}{p{3.36in}|}{The velocity shift to apply to the frequencies}\\
& &allowed: & float \\
& &Default: & 0.0
\\
deltachan && \multicolumn{2}{p{3.36in}|}{The number of channels to include each side of theline to determine a local maximum/minimum}\\
& &allowed: & integer \\
& &Default: & 10
\\
rotate && \multicolumn{2}{p{3.36in}|}{The rotation (in degrees) for the text label}\\
& &allowed: & float \\
& &Default: & 90.0
\\
location && \multicolumn{2}{p{3.36in}|}{The location of the line annotation from the 'top', 'bottom' or alternate }\\
& &allowed: & string \\
& &Default: & None 
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.plotter.plotazel
\newpage
\ahfunction{sd.plotter.plotazel}{Plot azimuth and elevation versus time of a scantable}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

    Plot azimuth and elevation versus time of a scantable.
    If outfile is specified, the plot will be saved to a disk.

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
scan && \multicolumn{2}{p{3.36in}|}{A scantable}\\
& &allowed: & scantable \\
& &Default: & None 
\\
outfile && \multicolumn{2}{p{3.36in}|}{Output file name}\\
& &allowed: & string \\
& &Default: & None
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.plotter.plotpointing
\newpage
\ahfunction{sd.plotter.plotpointing}{Plot telescope pointings in a scantable}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

    Plot telescope pointings in a scantable.
    If outfile is specified, the plot will be saved to a disk.


\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
scan && \multicolumn{2}{p{3.36in}|}{A scantable}\\
& &allowed: & scantable \\
& &Default: & None 
\\
outfile && \multicolumn{2}{p{3.36in}|}{Output file name}\\
& &allowed: & string \\
& &Default: & None
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.plotter.plottp
\newpage
\ahfunction{sd.plotter.plottp}{Plot total power data}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

   Plot total power data versus row number (or time).
   If outfile is specified, the plot will be saved to a disk.

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
scan && \multicolumn{2}{p{3.36in}|}{A scantable}\\
& &allowed: & scantable \\
& &Default: & None 
\\
outfile && \multicolumn{2}{p{3.36in}|}{Output file name}\\
& &allowed: & string \\
& &Default: & None
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.plotter.print_header
\newpage
\ahsdfunction{sd.plotter.print\_header}{sd.plotter.print_header}{Print header of the scantable on the plot and/or logger}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

    Print data (scantable) header on the plot and/or logger.
 
\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
plot && \multicolumn{2}{p{3.36in}|}{Whether or not print header info on the plot}\\
& &allowed: & bool \\
& &Default: & True 
\\
fontsize && \multicolumn{2}{p{3.36in}|}{Header font size (valid only plot=True)}\\
& &allowed: & integer \\
& &Default: & 9
\\
logger && \multicolumn{2}{p{3.36in}|}{Whether or not print header info on the logger}\\
& &allowed: & bool \\
& &Default: & False
\\
selstr && \multicolumn{2}{p{3.36in}|}{Additional selection string (not verified)}\\
& &allowed: & string \\
& &Default: & ''
\\
extrastr && \multicolumn{2}{p{3.36in}|}{Additional string to print (not verified)}\\
& &allowed: & string \\
& &Default: & ''
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.plotter.refresh
\newpage
\ahfunction{sd.plotter.refresh}{Do a soft refresh on the plot}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

   Do a soft refresh on the plot.

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\flushleft\vspace{.20in}\textbf {Returns}\newline

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.plotter.save
\newpage
\ahfunction{sd.plotter.save}{Save the plot to a file}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

    Save the plot to a file. The known formats are 'png', 'ps', 'eps'.

    If filename have suffix, the image format will be automatically detected.
    If no filename is specified a file called 'yyyymmdd\_hhmmss.png' is created 
    in the current directory.

    The orientation argument is an optional parameter for postscript only (not eps).
    'landscape', 'portrait' or None (default) are valid. If None is choosen for 'ps' output, the plot is
    automatically oriented to fill the page.

 
\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
filename && \multicolumn{2}{p{3.36in}|}{The name of the output file}\\
& &allowed: & bool \\
& &Default: & True 
\\
orientation && \multicolumn{2}{p{3.36in}|}{Optional parameter for postscript that specifies orientation of the plot}\\
& &allowed: & string ('landscape' or 'portrait') \\
& &Default: & None
\\
dpi && \multicolumn{2}{p{3.36in}|}{The dpi of the output non-postscript plot}\\
& &allowed: & integer \\
& &Default: & False (150 dpi)
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.plotter.set_abcissa
\newpage
\ahsdfunction{sd.plotter.set\_abcissa}{sd.plotter.set_abcissa}{Set the x-axis label of the plot}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

    Set the x-axis label of the plot. If multiple panels are plotted,
    multiple labels have to be specified.

    If no abcissa labels are specified (i.e. None), data determine the labels.
 
\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
abcissa && \multicolumn{2}{p{3.36in}|}{A list of abcissa labels}\\
& &allowed: & string, string array \\
& &Default: & None
\\
fontsize && \multicolumn{2}{p{3.36in}|}{A font size of the label}\\
& &allowed: & integer \\
& &Default: & None
\\
refresh && \multicolumn{2}{p{3.36in}|}{If True, the plot is replotted based on the new parameter setting(s)}\\
& &allowed: & bool \\
& &Default: & True
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\

\begin{verbatim}
         # two panels are visible on the plotter
         sd.plotter.set_ordinate(["First X-Axis","Second X-Axis"])
\end{verbatim}



%% sd.plotter.set_colors
\newpage
\ahsdfunction{sd.plotter.set\_colors}{sd.plotter.set_colors}{Set the colors to be used}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

    Set the colours to be used. The plotter will cycle through
    these colours when lines are overlaid (stacking mode).
 
\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
colmap && \multicolumn{2}{p{3.36in}|}{A list of color names}\\
& &allowed: & string \\
& &Default: & 
\\
refresh && \multicolumn{2}{p{3.36in}|}{If True, the plot is replotted based on the new parameter setting(s)}\\
& &allowed: & bool \\
& &Default: & True
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\

\begin{verbatim}
         sd.plotter.set_colors("red green blue")
         # If for example four lines are overlaid e.g I Q U V
         # 'I' will be 'red', 'Q' will be 'green', U will be 'blue'
         # and 'V' will be 'red' again.
\end{verbatim}



%% sd.plotter.set_colours
\newpage
\ahsdfunction{sd.plotter.set\_colours}{sd.plotter.set_colours}{Set the colors to be used}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

   See \ahlink{set\_colors}{sd:sd.plotter.set_colors}.

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\flushleft\vspace{.20in}\textbf {Returns}\newline

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.plotter.set_data
\newpage
\ahsdfunction{sd.plotter.set\_data}{sd.plotter.set_data}{Set a scantable to plot}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

    Set a scantable to plot.

    Note that the user specified masks and data selections will be reset
    if a new scantable is set. This method should be called before
    setting data selections (\ahlink{set\_selection}{sd:sd.scantable.set_selection}) 
    and/or masks (\ahlink{set\_mask}{sd:sd.plotter.set_mask}).

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
scan && \multicolumn{2}{p{3.36in}|}{A scantable}\\
& &allowed: & scantable \\
& &Default: & 
\\
refresh && \multicolumn{2}{p{3.36in}|}{If True, the plot is replotted based on the new parameter setting(s)}\\
& &allowed: & bool \\
& &Default: & True
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.plotter.set_font
\newpage
\ahsdfunction{sd.plotter.set\_font}{sd.plotter.set_font}{Set font properties}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

    Set font properties.
 
\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
family && \multicolumn{2}{p{3.36in}|}{One of 'sans-serif', 'serif', 'cursive', 'fantasy', 'monospace'}\\
& &allowed: & string \\
& &Default: & 
\\
style && \multicolumn{2}{p{3.36in}|}{One of 'normal' (or 'roman'), 'italic'  or 'oblique'}\\
& &allowed: & string \\
& &Default: & 
\\
weight && \multicolumn{2}{p{3.36in}|}{One of 'normal or 'bold'}\\
& &allowed: & string \\
& &Default: & 
\\
size && \multicolumn{2}{p{3.36in}|}{the 'general' font size, individual elements can be adjusted seperately}\\
& &allowed: & integer \\
& &Default: & 
\\
refresh && \multicolumn{2}{p{3.36in}|}{If True, the plot is replotted based on the new parameter setting(s)}\\
& &allowed: & bool \\
& &Default: & True
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.plotter.set_histogram
\newpage
\ahsdfunction{sd.plotter.set\_histogram}{sd.plotter.set_histogram}{Enable/Disable histogram plotting}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

    Enable/Disable histogram-like plotting.

    The first default is taken from sd.rcParams[plotter.histogram].
 
\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
hist && \multicolumn{2}{p{3.36in}|}{Enable/Disable histogram plotting}\\
& &allowed: & bool \\
& &Default: & True 
\\
refresh && \multicolumn{2}{p{3.36in}|}{If True, the plot is replotted based on the new parameter setting(s)}\\
& &allowed: & bool \\
& &Default: & True
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.plotter.set_layout
\newpage
\ahsdfunction{sd.plotter.set\_layout}{sd.plotter.set_layout}{Set the multi-panel layout}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

    Set the multi-panel layout, i.e. how many rows and columns plots are visible.

    Note that if no argument is given, the potter reverts to its auto-plot behaviour.

 
\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
rows && \multicolumn{2}{p{3.36in}|}{Number of rows of plots}\\
& &allowed: & integer \\
& &Default: & None 
\\
cols && \multicolumn{2}{p{3.36in}|}{Number of columns of plots}\\
& &allowed: & integer \\
& &Default: & None 
\\
refresh && \multicolumn{2}{p{3.36in}|}{If True, the plot is replotted based on the new parameter setting(s)}\\
& &allowed: & bool \\
& &Default: & True
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.plotter.set_legend
\newpage
\ahsdfunction{sd.plotter.set\_legend}{sd.plotter.set_legend}{Specify a mapping for the legend}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

    Specify a mapping for the legend instead of using the default indices.

    The list of legends should be given to the mp argument as a string.
    This should have the same length
    as the number of elements on the legend and then maps
    to the indeces in order. It is possible to uses latex
    math expression. These have to be enclosed in r'',
    e.g. \verb+r'$x^{2}$'+

    The mode argument controls where to display the legend. 
    It should be specified as an integer. The following list shows a meaning of each integer.

    \begin{longtable}{rl}
                    0: & auto \\
                    1: & upper right \\
                    2: & upper left \\
                    3: & lower left \\
                    4: & lower right \\
                    5: & right \\
                    6: & center left \\
                    7: & center right \\
                    8: & lower center \\
                    9: & upper center \\
                    10: & center \\
    \end{longtable}

 
\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
mp && \multicolumn{2}{p{3.36in}|}{A list of legend strings}\\
& &allowed: & string array \\
& &Default: & None 
\\
fontsize && \multicolumn{2}{p{3.36in}|}{The font size of the label}\\
& &allowed: & integer \\
& &Default: & None 
\\
mode && \multicolumn{2}{p{3.36in}|}{Where to display the legend}\\
& &allowed: & integer \\
& &Default: & 0 (auto)
\\
refresh && \multicolumn{2}{p{3.36in}|}{If True, the plot is replotted based on the new parameter setting(s)}\\
& &allowed: & bool \\
& &Default: & True
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\

\begin{verbatim}
         # If the data has two IFs/rest frequencies with index 0 and 1
         # for CO and SiO:
         sd.plotter.set_stacking('i')
         sd.plotter.set_legend(['CO','SiO'])
         sd.plotter.plot()
         sd.plotter.set_legend([r'$^{12}CO$', r'SiO'])
\end{verbatim}


%% sd.plotter.set_linestyles
\newpage
\ahsdfunction{sd.plotter.set\_linestyles}{sd.plotter.set_linestyles}{Set the linestyles to be used}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

    Set the linestyles to be used. The plotter will cycle through
    these linestyles when lines are overlaid (stacking mode) AND
    only one color has been set.

    Accepted linestyles are 'line', 'dashed', 'dotted', 'dashdot', 'dashdotdot' and 'dashdashdot'. 
 
\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
linestyles && \multicolumn{2}{p{3.36in}|}{A list of linestyles to use}\\
& &allowed: & string array \\
& &Default: & None 
\\
linewidth && \multicolumn{2}{p{3.36in}|}{A width of the line}\\
& &allowed: & integer \\
& &Default: & None 
\\
refresh && \multicolumn{2}{p{3.36in}|}{If True, the plot is replotted based on the new parameter setting(s)}\\
& &allowed: & bool \\
& &Default: & True
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\

\begin{verbatim}
         sd.plotter.set_colors("black")
         sd.plotter.set_linestyles("line dashed dotted dashdot")
         # If for example four lines are overlaid e.g I Q U V
         # 'I' will be 'solid', 'Q' will be 'dashed',
         # U will be 'dotted' and 'V' will be 'dashdot'.
\end{verbatim}


%% sd.plotter.set_mask
\newpage
\ahsdfunction{sd.plotter.set\_mask}{sd.plotter.set_mask}{Set a plotting mask for a specific selection of the data}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

    Set a plotting mask for a specific polarization.
    This is useful for masking out "noise" Pangle outside a source.
 
\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
mask && \multicolumn{2}{p{3.36in}|}{A mask from \ahlink{scantable.create\_mask}{sd:sd.scantable.create_mask}}\\
& &allowed: & bool array \\
& &Default: & None 
\\
selection && \multicolumn{2}{p{3.36in}|}{The spectra to apply the mask to}\\
& &allowed: & selector \\
& &Default: & None 
\\
refresh && \multicolumn{2}{p{3.36in}|}{If True, the plot is replotted based on the new parameter setting(s)}\\
& &allowed: & bool \\
& &Default: & True
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\

\begin{verbatim}
         select = sd.selector()
         select.setpolstrings("Pangle")
         sd.plotter.set_mask(mymask, select)
\end{verbatim}


%% sd.plotter.set_mode
\newpage
\ahsdfunction{sd.plotter.set\_mode}{sd.plotter.set_mode}{Set the plots look and feel}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

    Set the plots look and feel, i.e. what you want to see on the plot.
    Stacking is a plot as line color overlays, while panelling is a plot across multiple panels.
    By default, the stacking is set to 'pol' and the panelling is set to 'scan'.

    Valid modes are:

    \begin{longtable}{rl}
             'beam' 'Beam' 'b': &     Beams \\
             'if' 'IF' 'i': &        IFs \\
             'pol' 'Pol' 'p': &      Polarisations \\
             'scan' 'Scan' 's': &     Scans \\
             'time' 'Time' 't': &    Times \\
    \end{longtable}

 
\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
stacking && \multicolumn{2}{p{3.36in}|}{Tell the plotter which variable to plot as line colour overlays}\\
& &allowed: & string \\
& &Default: & None 
\\
panelling && \multicolumn{2}{p{3.36in}|}{Tell the plotter which variable to plot across multiple panels }\\
& &allowed: & string \\
& &Default: & None 
\\
refresh && \multicolumn{2}{p{3.36in}|}{If True, the plot is replotted based on the new parameter setting(s)}\\
& &allowed: & bool \\
& &Default: & True
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.plotter.set_ordinate
\newpage
\ahsdfunction{sd.plotter.set\_ordinate}{sd.plotter.set_ordinate}{Set y-axis label of the plot}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

    Set the y-axis label of the plot. If multiple panels are plotted,
    multiple labels have to be specified. If no ordinate is set, data determine the lebels.
 
\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
ordinate && \multicolumn{2}{p{3.36in}|}{A list of ordinate labels}\\
& &allowed: & string, string array \\
& &Default: & None 
\\
fontsize && \multicolumn{2}{p{3.36in}|}{A font size of the label}\\
& &allowed: & integer \\
& &Default: & None 
\\
refresh && \multicolumn{2}{p{3.36in}|}{If True, the plot is replotted based on the new parameter setting(s)}\\
& &allowed: & bool \\
& &Default: & True
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\

\begin{verbatim}
         # two panels are visible on the plotter
         sd.plotter.set_ordinate(["First Y-Axis","Second Y-Axis"])
\end{verbatim}



%% sd.plotter.set_panellayout
%\newpage
%\ahsdfunction{sd.plotter.set\_panellayout}{sd.plotter.set_panellayout}{Set layout of subplots}
%
%\flushleft\vspace{.20in}\textbf {Description}\\
%   \hfill \\
%
%    Set the layout of subplots.
%
%    The layout argument specifies a list of subplots layout in figure coordinate (0-1),
%    i.e., fraction of the figure width or height.
%    The order of elements should be: 
%    [left, bottom, right, top, horizontal space btw panels, vertical space btw panels].
% 
%    Note that, when layout is not specified, the values are reset to the defaults of matplotlib.
%    Note also that, if any element is set to be None, the current value is adopted.
%
%\flushleft\vspace{.20in}\textbf {Arguments}\\
%\hfill \\
%\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
%\hline
%Inputs && \multicolumn{2}{p{3.36in}|}{}\\
%layout && \multicolumn{2}{p{3.36in}|}{A list of subplots layout}\\
%& &allowed: & float array \\
%& &Default: & None 
%\\
%refresh && \multicolumn{2}{p{3.36in}|}{If True, the plot is replotted based on the new parameter setting(s)}\\
%& &allowed: & bool \\
%& &Default: & True
%\\
%
%\hline
%\end{tabular}
%
%\flushleft\vspace{.20in}\textbf {Returns}\newline
%
%\flushleft\vspace{.20in}\textbf {Example}\\
%\hfill \\


%% sd.plotter.set_panelling
\newpage
\ahsdfunction{sd.plotter.set\_panelling}{sd.plotter.set_panelling}{Set the panelling mode}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

    Set the 'panelling' mode i.e. which type of spectra should be
    spread across different panels.

    Valid modes are:

    \begin{longtable}{rl}
             'beam' 'Beam' 'b': &     Beams \\
             'if' 'IF' 'i': &        IFs \\
             'pol' 'Pol' 'p': &      Polarisations \\
             'scan' 'Scan' 's': &     Scans \\
             'time' 'Time' 't': &    Times \\
    \end{longtable}

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
what && \multicolumn{2}{p{3.36in}|}{Which type of spectra should be spread across different panels}\\
& &allowed: & string \\
& &Default: & None 
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.plotter.set_range
\newpage
\ahsdfunction{sd.plotter.set\_range}{sd.plotter.set_range}{Set the range of interest on the abcissa of the plot}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

    Set the range of interest on the abcissa of the plot.

    These become non-sensical when the unit changes. 
    In that case, use plotter.set\_range() without parameters to reset.
 
\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
xstart && \multicolumn{2}{p{3.36in}|}{The start point of the 'zoom' window}\\
& &allowed: & float \\
& &Default: & None 
\\
xend && \multicolumn{2}{p{3.36in}|}{The end point of the 'zoom' window}\\
& &allowed: & float \\
& &Default: & None 
\\
ystart && \multicolumn{2}{p{3.36in}|}{The start point of the 'zoom' window}\\
& &allowed: & float \\
& &Default: & None 
\\
yend && \multicolumn{2}{p{3.36in}|}{The end point of the 'zoom' window}\\
& &allowed: & float \\
& &Default: & None 
\\
refresh && \multicolumn{2}{p{3.36in}|}{If True, the plot is replotted based on the new parameter setting(s)}\\
& &allowed: & bool \\
& &Default: & True
\\
offset && \multicolumn{2}{p{3.36in}|}{Shift the abcissa by the given amount. The abcissa label will have '(relative)' appended to it.}\\
& &allowed: & float \\
& &Default: & True
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.plotter.set_selection
\newpage
\ahsdfunction{sd.plotter.set\_selection}{sd.plotter.set_selection}{Set selection to the data}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

   Set selection to the data. 
   The method allows both to set selector object directly and to pass arguments for constructor of the selector 
   to create new selector object internally.

   See \ahlink{selector}{sd:sd.selector} for valid arguments for constructor of the selector.

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
selection && \multicolumn{2}{p{3.36in}|}{A selector object}\\
& &allowed: & selector \\
& &Default: & None 
\\
refresh && \multicolumn{2}{p{3.36in}|}{If True, the plot is replotted based on the new parameter setting(s)}\\
& &allowed: & bool \\
& &Default: & True
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\

\begin{verbatim}
   # these are equivalent
   sel=sd.selector(ifs=[0])
   sd.plotter.set_selection(sel)
   sd.plotter.set_selection(ifs=[0])
\end{verbatim}


%% sd.plotter.set_stacking
\newpage
\ahsdfunction{sd.plotter.set\_stacking}{sd.plotter.set_stacking}{Set the stacking mode}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

    Set the 'stacking' mode i.e. which type of spectra should be
    overlayed.

    Valid modes are:

    \begin{longtable}{rl}
             'beam' 'Beam' 'b': &     Beams \\
             'if' 'IF' 'i': &        IFs \\
             'pol' 'Pol' 'p': &      Polarisations \\
             'scan' 'Scan' 's': &     Scans \\
             'time' 'Time' 't': &    Times \\
    \end{longtable}


\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
what && \multicolumn{2}{p{3.36in}|}{Which type of spectra should be overlayed}\\
& &allowed: & string \\
& &Default: & None 
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.plotter.set_title
\newpage
\ahsdfunction{sd.plotter.set\_title}{sd.plotter.set_title}{Set the title of the plot}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

    Set the title of the plot. If multiple panels are plotted,
    multiple titles have to be specified.
 
\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
title && \multicolumn{2}{p{3.36in}|}{The title}\\
& &allowed: & string, string array \\
& &Default: & None 
\\
fontsize && \multicolumn{2}{p{3.36in}|}{A font size of the title}\\
& &allowed: & integer \\
& &Default: & None 
\\
refresh && \multicolumn{2}{p{3.36in}|}{If True, the plot is replotted based on the new parameter setting(s)}\\
& &allowed: & bool \\
& &Default: & True
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\

\begin{verbatim}
         # two panels are visible on the plotter
         sd.plotter.set_title(["First Panel","Second Panel"])
\end{verbatim}


%% sd.plotter.text
\newpage
\ahfunction{sd.plotter.text}{Add text in a specified location}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

   Add text in string s to axis at location x,y (data coords).
   This is an interface for matplotlib.axes.Axes.text function.

   The interactive argument is specific to this method (not available 
   from matplotlib). If it is True, you can set positions interactively 
   using GUI panel.

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\

    See matplotlib help about detailed description of arguments.

\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
x && \multicolumn{2}{p{3.36in}|}{x position of the text}\\
& &allowed: & float \\
& &Default: & 
\\
y && \multicolumn{2}{p{3.36in}|}{y position of the text}\\
& &allowed: & float \\
& &Default: & 
\\
s && \multicolumn{2}{p{3.36in}|}{The text to be drawn}\\
& &allowed: & string \\
& &Default: & 
\\
interactive && \multicolumn{2}{p{3.36in}|}{Interactively set the position of the text if True}\\
& &allowed: & bool \\
& &Default: & 
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\



%%%%% sd.coordinate
%\newpage
\ahobject{sd.coordinate}{Single-dish specific spectral coordinate conversion}
%\ahfunction{sd.coordinate}{Single-dish specific spectral coordinate conversion}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

  The coordinate class is a representation of the spectral coordinate 
  (frequency axis) of the data. It handles a conversion between 
  pixel/channel values and frequency/velocity ones under the current 
  spectral coordinate.

  Spectral coordinate is composed of a set of three values: a reference pixel, 
  a frequency in Hz at the reference pixel, and an increment in Hz (width of each pixel). 

  Normally, the object of this class is not created from scratch. 
  Instead, the object can be obtained from \ahlink{scantable}{sd:sd.scantable} object 
  using \ahlink{get\_coordinate}{sd:sd.scantable.get_coordinate} method.
  Returned spectral coordinate contains spectral coordinate information and rest frequency value, 
  which is needed to handle velocity conversion, of the given row.  

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\

\begin{verbatim}
     # create a scantable object
     s=sd.scantable('OrionS_rawACSmod',average=False)
     # get coordinate system
     c=s.get_coordinate(0)
     # get coordinate system values
     c.get_increment()
     6104.2329788208008
     c.get_reference_pixel()
     4096.0
     c.get_reference_value()
     45489353563.344795
     # get pixel value
     c.to_pixel(4.5489e10)
     4038.0789891175605
     # get frequency at channel 0
     c.to_frequency(0)
     45464350625.063545
     # get velocity at channel 0
     c.to_velocity(0)
     170.73624010940924
\end{verbatim}

Methods
\begin{longtable}{ll}

	\ahlink{coordinate}{sd:sd.coordinate.coordinate} & Constructor \\

	\ahlink{coordinate.get\_increment}{sd:sd.coordinate.coordinate.get_increment} & Get increment of this coordinate system \\

	\ahlink{coordinate.get\_reference\_pixel}{sd:sd.coordinate.coordinate.get_reference_pixel} & Get reference pixel of this coordinate system \\

	\ahlink{coordinate.get\_reference\_value}{sd:sd.coordinate.coordinate.get_reference_value} & Get reference value of this coordinate system \\

	\ahlink{coordinate.to\_frequency}{sd:sd.coordinate.coordinate.to_frequency} & Convert a channel/pixel value to a frequency \\

	\ahlink{coordinate.to\_pixel}{sd:sd.coordinate.coordinate.to_pixel} & Convert a frequency value to a channel/pixel  \\

	\ahlink{coordinate.to\_velocity}{sd:sd.coordinate.coordinate.to_velocity} & Convert a channel/pixel value to a velocity \\

\end{longtable}


%% sd.coordinate.coordinate
\newpage
\ahfunction{sd.coordinate.coordinate}{Constructor}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

   Constructor of this class. Not useful any more.

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\flushleft\vspace{.20in}\textbf {Returns}\newline

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.coordinate.coordinate.get_increment
\newpage
\ahsdfunction{sd.coordinate.coordinate.get\_increment}{sd.coordinate.coordinate.get_increment}{Get increment of this coordinate system}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

   Return an increment of this spectral coordinate. The unit is Hz.

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\flushleft\vspace{.20in}\textbf {Returns}\newline
float

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.coordinate.coordinate.get_reference_pixel
\newpage
\ahsdfunction{sd.coordinate.coordinate.get\_reference\_pixel}{sd.coordinate.coordinate.get_reference_pixel}{Get reference pixel of this coordinate system}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

   Return a reference pixel of this spectral coordinate.

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\flushleft\vspace{.20in}\textbf {Returns}\newline
float

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.coordinate.coordinate.get_reference_value
\newpage
\ahsdfunction{sd.coordinate.coordinate.get\_reference\_value}{sd.coordinate.coordinate.get_reference_value}{Get reference value of this coordinate system}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

   Return a reference frequency of this spectral coordinate. The unit is Hz.

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\flushleft\vspace{.20in}\textbf {Returns}\newline

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.coordinate.coordinate.to_frequency
\newpage
\ahsdfunction{sd.coordinate.coordinate.to\_frequency}{sd.coordinate.coordinate.to_frequency}{Convert a channel/pixel value to a frequency}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

   The method converts a given channel/pixel value to a frequency under this spectral coordinate.
   Default unit of returned value is Hz.

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
pixel && \multicolumn{2}{p{3.36in}|}{Channel/pixel value where frequency wants to know}\\
& &allowed: & float\\
& &Default: & 
\\
unit&& \multicolumn{2}{p{3.36in}|}{Unit of the returned value}\\
& &allowed: & string ('Hz', 'kHz', 'MHz', 'GHz') \\
& &Default: & 'Hz'
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline
float

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.coordinate.coordinate.to_pixel
\newpage
\ahsdfunction{sd.coordinate.coordinate.to\_pixel}{sd.coordinate.coordinate.to_pixel}{Convert a frequency value to a channel/pixel}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

   The method converts a given frequency value to a channel/pixel under this spectral coordinate.

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
 && \multicolumn{2}{p{3.36in}|}{A frequency value that want to convert to channel/pixel}\\
& &allowed: & float\\
& &Default: & 
\\

\hline
\end{tabular}
\flushleft\vspace{.20in}\textbf {Returns}\newline
float

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.coordinate.coordinate.to_velocity
\newpage
\ahsdfunction{sd.coordinate.coordinate.to\_velocity}{sd.coordinate.coordinate.to_velocity}{Convert a channel/pixel value to a velocity}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

   The method converts a given channel/pixel value to a velocity under this spectral coordinate.
   Default unit of returned value is km/s.

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
pixel && \multicolumn{2}{p{3.36in}|}{Channel/pixel value where velocity wants to know}\\
& &allowed: & float\\
& &Default: & 
\\
unit&& \multicolumn{2}{p{3.36in}|}{Unit of the returned value}\\
& &allowed: & string ('km/s', 'm/s') \\
& &Default: & 'km/s'
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline
float

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\



%%%%% sd.opacity_model
\newpage
\ahsdobject{sd.opacity\_model}{sd.opacity_model}{Single dish specific opacity model}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

  This class implements opacity/atmospheric brightness temperature model
  equivalent to the model available in MIRIAD. The actual math is a
  convertion of the Fortran code written by Bob Sault for MIRIAD.
  It implements a simple model of the atmosphere and Liebe's model (1985)
  of the complex refractive index of air.
    
  The model of the atmosphere is one with an exponential fall-off in
  the water vapour content (scale height of 1540 m) and a temperature
  lapse rate of 6.5 mK/m. Otherwise the atmosphere obeys the ideal gas
  equation and hydrostatic equilibrium.
  
  Note that the model includes atmospheric lines up to 800 GHz, but was not
  rigorously tested above 100 GHz and for instruments located at
  a significant elevation. For high-elevation sites it may be necessary to
  adjust scale height and lapse rate.

  The constructor takes several arguments that specifies observatory and 
  weather informations.

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
temperature&& \multicolumn{2}{p{3.36in}|}{Air temperature at the observatory (K)}\\
& &allowed: & float\\
& &Default: & 288.0
\\
pressure&& \multicolumn{2}{p{3.36in}|}{Air pressure at the sea level if the observatory elevation is set to non-zero value (note, by default is set to 700m) or at the observatory ground level if the elevation is set to 0. The value is in Pascals or hPa.}\\
& &allowed: & float\\
& &Default: & 101325.0
\\
humidity&& \multicolumn{2}{p{3.36in}|}{Air humidity at the observatory (fractional)}\\
& &allowed: & float\\
& &Default: & 0.5
\\
elevation&& \multicolumn{2}{p{3.36in}|}{Observatory elevation about sea level (in meters)}\\
& &allowed: & float\\
& &Default: & 700.0
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\

\begin{verbatim}
     o=sd.opacity_model(temperature=300.0,elevation=1300.0)
     tau=sd.get_opacities([1.0e11,1.1e11])
     print tau
     [0.2363221976673901, 0.3068089293871521]
\end{verbatim}

Methods
\begin{longtable}{ll}

	\ahlink{get\_opacities}{sd:sd.opacity_model.get_opacities} & Get the opacity value(s) for the given frequency(ies) \\

	\ahlink{set\_observatory\_elevation}{sd:sd.opacity_model.set_observatory_elevation} & Update the model using the given observatory elevation \\

	\ahlink{set\_weather}{sd:sd.opacity_model.set_weather} & Update the model using the given environmental parameters \\

\end{longtable}


%% sd.opacity_model.get_opacities
\newpage
\ahsdfunction{sd.opacity\_model.get\_opacities}{sd.opacity_model.get_opacities}{Get the opacity value(s) for the given frequency(ies)}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

    Get the opacity value(s) for the given frequency(ies).
    If no elevation is given the opacities for the zenith are returned.
    If an elevation is specified refraction is also taken into account.
    The user is able to set frequency value(s) where the user want to compute opacity(ies).
    One opacity value per frequency is returned as a scalar or list.

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
freq && \multicolumn{2}{p{3.36in}|}{A frequency value in Hz, or a list of frequency values. }\\
& &allowed: & float, float array\\
& &Default: & 
\\
elevation&& \multicolumn{2}{p{3.36in}|}{The elevation in radian at which to compute the opacity.}\\
& &allowed: & float\\
& &Default: & None (zenith opacity)
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline
float, float array

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.opacity_model.set_observatory_elevation
\newpage
\ahsdfunction{sd.opacity\_model.set\_observatory\_elevation}{sd.opacity_model.set_observatory_elevation}{Update the model using the given observatory elevation}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

    Update the model using the given the observatory elevation in meter.
    Note that, in constructor, the default value for the observatory elevation is 700m.
 
\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
elevation&& \multicolumn{2}{p{3.36in}|}{The site elevation in meter at which to compute the opacity.}\\
& &allowed: & float\\
& &Default: & 
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.opacity_model.set_weather
\newpage
\ahsdfunction{sd.opacity\_model.set\_weather}{sd.opacity_model.set_weather}{Update the model using the given environmental parameters}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

    Update the model using the given environmental parameters.
    The pressure value will be a pressure at sea level is the observatory elevation is set to 
    non-zero value, while it will be a pressure at the observatory ground level if the elevation 
    is set to 0.
 
\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
temperature&& \multicolumn{2}{p{3.36in}|}{Air temperature at the observatory (K)}\\
& &allowed: & float\\
& &Default: & 
\\
pressure&& \multicolumn{2}{p{3.36in}|}{Air pressure in Pascals or hPa.}\\
& &allowed: & float\\
& &Default: & 
\\
humidity&& \multicolumn{2}{p{3.36in}|}{Air humidity at the observatory (fractional)}\\
& &allowed: & float\\
& &Default: & 
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%%%%% sd.asapgrid
\newpage
\ahobject{sd.asapgrid}{Tool to convolve map data onto regularly spaced grid}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

    The asapgrid class is defined to convolve data onto regular
    spatial grid. 

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
infile&& \multicolumn{2}{p{3.36in}|}{input data as a string or string list}\\
& &allowed: & string, list of string\\
& &Default: & 
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline
asapgrid instance

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\

\begin{verbatim}
       # create asapgrid instance with two input data
       g = asapgrid( ['testimage1.asap','testimage2.asap'] )
       # set IFNO if necessary
       g.setIF( 0 )
       # set POLNOs if necessary
       g.setPolList( [0,1] )
       # set SCANNOs if necessary
       g.setScanList( [22,23,24] )
       # define image with full specification
       # you can skip some parameters (see help for defineImage)
       g.defineImage( nx=12, ny=12, cellx='10arcsec', celly='10arcsec',
                      center='J2000 10h10m10s -5d05m05s' )
       # set convolution function
       g.setFunc( func='sf', width=3 )
       # enable min/max clipping
       g.enableClip()
       # or, disable min/max clipping
       #g.disableClip()
       # actual gridding
       g.grid()
       # save result
       g.save( outfile='grid.asap' )
       # plot result
       g.plot( plotchan=1246, plotpol=-1, plotgrid=True, plotobs=True )
\end{verbatim}

Methods
\begin{longtable}{ll}

	\ahlink{sd.asapgrid.defineImage}{sd:sd.asapgrid.defineImage} & Define spatial grid \\

	\ahlink{sd.asapgrid.disableClip}{sd:sd.asapgrid.disableClip} & Disable min/max clipping \\

	\ahlink{sd.asapgrid.enableClip}{sd:sd.asapgrid.enableClip} & Enable min/max clipping \\

	\ahlink{sd.asapgrid.grid}{sd:sd.asapgrid.grid} & Do gridding \\

	\ahlink{sd.asapgrid.plot}{sd:sd.asapgrid.plot} & Plot result \\

	\ahlink{sd.asapgrid.save}{sd:sd.asapgrid.save} & Save result \\

	\ahlink{sd.asapgrid.setData}{sd:sd.asapgrid.setData} & Set data to be processed \\

	\ahlink{sd.asapgrid.setFunc}{sd:sd.asapgrid.setFunc} & Set convolution function \\

	\ahlink{sd.asapgrid.setIF}{sd:sd.asapgrid.setIF} & Set IFNO to be processed \\

	\ahlink{sd.asapgrid.setPolList}{sd:sd.asapgrid.setPolList} & Set polarizations to be processed \\

	\ahlink{sd.asapgrid.setScanList}{sd:sd.asapgrid.setScanList} & Set scans to be processed \\

	\ahlink{sd.asapgrid.setWeight}{sd:sd.asapgrid.setWeight} & Set weight type \\

\end{longtable}


%% sd.asapgrid.defineImage
\newpage
\ahfunction{sd.asapgrid.defineImage}{Define spatial grid}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

    Define spatial grid.
    
    First two parameters, nx and ny, define number of pixels of
    the grid. If which of those is not specified, it will be set
    to the same value as the other. If none of them are specified,
    it will be determined from map extent and cell size.
    
    Next two parameters, cellx and celly, define size of pixel.
    You should set those parameters as string, which is constructed
    numerical value and unit, e.g. '0.5arcmin', or numerical value.
    If those values are specified as numerical value, their units
    will be assumed to 'arcmin'. If which of those is not specified,
    it will be set to the same value as the other. If none of them
    are specified, it will be determined from map extent and number
    of pixels, or set to '1arcmin' if neither nx nor ny is set.
    
    The last parameter, center, define the central coordinate of
    the grid. You should specify its value as a string, like,
    
       'J2000 05h08m50s -16d23m30s'
    
    or 
    
       'J2000 05:08:50 -16.23.30'
    
    You can omit equinox when you specify center coordinate. In that
    case, J2000 is assumed. If center is not specified, it will be
    determined from the observed positions of input data.
 
\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
nx && \multicolumn{2}{p{3.36in}|}{number of pixels along x (R.A.) direction}\\
& &allowed: & int \\
& &Default: & -1
\\
ny && \multicolumn{2}{p{3.36in}|}{number of pixels along y (Dec.) direction}\\
& &allowed: & int \\
& &Default: & -1 
\\
cellx && \multicolumn{2}{p{3.36in}|}{size of pixel in x (R.A.) direction}\\
& &allowed: & string, float\\
& &Default: & ''
\\
celly && \multicolumn{2}{p{3.36in}|}{size of pixel in y (Dec.) direction.}\\
& &allowed: & string, float\\
& &Default: & ''
\\
center && \multicolumn{2}{p{3.36in}|}{central position of the grid}\\
& &allowed: & string \\
& &Default: & ''
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\

%% sd.asapgrid.disableClip
\newpage
\ahfunction{sd.asapgrid.disableClip}{Disable min/max clipping}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

   Disable min/max clipping.

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\flushleft\vspace{.20in}\textbf {Returns}\newline

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\

%% sd.asapgrid.enableClip
\newpage
\ahfunction{sd.asapgrid.enableClip}{Enable min/max clipping}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

   Enable min/max clipping.

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\flushleft\vspace{.20in}\textbf {Returns}\newline

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\

%% sd.asapgrid.grid
\newpage
\ahfunction{sd.asapgrid.grid}{Do gridding}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

   Actual gridding which will be done based on several user inputs.

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\flushleft\vspace{.20in}\textbf {Returns}\newline

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\

%% sd.asapgrid.plot
\newpage
\ahfunction{sd.asapgrid.plot}{Plot result}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

   Plot gridded data. Data must be saved using \ahlink{save}{sd:sd.asapgrid.save} method.

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
plotchan && \multicolumn{2}{p{3.36in}|}{Which channel you want to plot. Default  is to average all the channels.}\\
& &allowed: & int \\
& &Default: & -1
\\
plotpol && \multicolumn{2}{p{3.36in}|}{Which polarization component you want to plot. Default is to average all the polarization components.}\\
& &allowed: & int \\
& &Default: & -1
\\
plotobs && \multicolumn{2}{p{3.36in}|}{Also plot observed position if True. Setting True for large amount of spectra might be time consuming.}\\
& &allowed: & bool \\
& &Default: & False
\\
plotgrid && \multicolumn{2}{p{3.36in}|}{Also plot grid center if True. Setting True for large number of grids might be time consuming.}\\
& &allowed: & bool \\
& &Default: & False
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\

%% sd.asapgrid.save
\newpage
\ahfunction{sd.asapgrid.save}{Save result}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

   Save result. By default, output data name will be constructed
   from first element of input data name list (e.g. 'input.asap.grid').

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
outfile && \multicolumn{2}{p{3.36in}|}{output data name}\\
& &allowed: & string \\
& &Default: & ''
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\

%% sd.asapgrid.setData
\newpage
\ahfunction{sd.asapgrid.setData}{Set data to be processed}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

   Set data to be processed.

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
infile && \multicolumn{2}{p{3.36in}|}{input data as a string or string list if you want to grid more than one data at once.}\\
& &allowed: & string, string list \\
& &Default: & ''
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\

%% sd.asapgrid.setFunc
\newpage
\ahfunction{sd.asapgrid.setFunc}{Set convolution function}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

    Set convolution function. Possible options are 'box' (Box-car,
    default), 'sf' (prolate spheroidal), and 'gauss' (Gaussian).
    Width of convolution function can be set using width parameter.
    By default (-1), width is automatically set depending on each
    convolution function. Default values for width are:
    
       'box': 1 pixel
       'sf': 3 pixels
       'gauss': 1 pixel (width is used as HWHM)
    

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
func && \multicolumn{2}{p{3.36in}|}{Function type ('box', 'sf', 'gauss')}\\
& &allowed: & string \\
& &Default: & box
\\
width && \multicolumn{2}{p{3.36in}|}{Width of convolution function. Default (-1) is to choose pre-defined value for each convolution function.}\\
& &allowed: & int \\
& &Default: & -1
\\

\hline
\end{tabular}
\flushleft\vspace{.20in}\textbf {Returns}\newline

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\

%% sd.asapgrid.setIF
\newpage
\ahfunction{sd.asapgrid.setIF}{Set IFNO to be processed}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

     Set IFNO to be processed. Currently, asapgrid allows to process
     only one IFNO for one gridding run even if the data contains
     multiple IFs. If you didn't specify IFNO, default value, which
     is IFNO in the first spectrum, will be processed.

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
ifno && \multicolumn{2}{p{3.36in}|}{IFNO to be processed}\\
& &allowed: & int \\
& &Default: & 
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\

%% sd.asapgrid.setPolList
\newpage
\ahfunction{sd.asapgrid.setPolList}{Set polarizations to be processed}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

     Set list of polarization components you want to process.
     If not specified, all POLNOs will be processed.


\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
pollist && \multicolumn{2}{p{3.36in}|}{list of POLNOs to be processed}\\
& &allowed: & int list \\
& &Default: & 
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\

%% sd.asapgrid.setScanList
\newpage
\ahfunction{sd.asapgrid.setScanList}{Set scans to be processed}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

     Set list of scans you want to process. If not specified, all
     scans will be processed.

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
scanlist && \multicolumn{2}{p{3.36in}|}{list of SCANNOs to be processed}\\
& &allowed: & int list \\
& &Default: & 
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\

%% sd.asapgrid.setWeight
\newpage
\ahfunction{sd.asapgrid.setWeight}{Set weight type}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

     Set weight type. Possible options are 'uniform' (default),
     'tint' (weight by integration time), 'tsys' (weight by
     Tsys: 1/Tsys**2), and 'tintsys' (weight by integration time
     as well as Tsys: tint/Tsys**2).

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
weightType && \multicolumn{2}{p{3.36in}|}{weight type ('uniform', 'tint', 'tsys', 'tintsys')}\\
& &allowed: & string \\
& &Default: & uniform
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\

%%%%% sd.asaplog
\newpage
\ahobject{sd.asaplog}{Wrapper object to allow for both casapy and asap logging}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

    Wrapper object to allow for both casapy and asap logging.
    
    Inside casapy this will connect to 'taskinit.casalog'. Otherwise it will
    create its own casa log sink.
    
    .. note:: Do not instantiate a new one - use the :obj:'asaplog' instead.

    In the ASAP logging system, log messages are accumulated to the 
    log buffer when you post any message using 
    \ahlink{sd.asaplog.push}{sd:sd.asaplog.push}. 
    Buffered messages are flushed when you call 
    \ahlink{sd.asaplog.post}{sd:sd.asaplog.post}.

Methods
\begin{longtable}{ll}

	\ahlink{sd.asaplog.clear}{sd:sd.asaplog.clear} & Clear buffer \\
	\ahlink{sd.asaplog.disable}{sd:sd.asaplog.disable} & Disable (or enable) logging \\
	\ahlink{sd.asaplog.enable}{sd:sd.asaplog.enable} & Enable (or disable) logging \\
	\ahlink{sd.asaplog.is\_enabled}{sd:sd.asaplog.is_enabled} & Query if logging is enabled \\
	\ahlink{sd.asaplog.post}{sd:sd.asaplog.post} & Post message to the logger \\
	\ahlink{sd.asaplog.push}{sd:sd.asaplog.push} & Push logs into the buffer \\

\end{longtable}


%% sd.asaplog.clear
\newpage
\ahfunction{sd.asaplog.clear}{Clear buffer}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

   Clear buffer. This is only effective for standalone ASAP.

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\

\flushleft\vspace{.20in}\textbf {Returns}\newline

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.asaplog.disable
\newpage
\ahfunction{sd.asaplog.disable}{Disable (or enable) logging}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

   Disable (or enable) logging.

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
flag && \multicolumn{2}{p{3.36in}|}{Set False to disable logging}\\
& &allowed: & bool \\
& &Default: & False
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\


%% sd.asaplog.enable
\newpage
\ahfunction{sd.asaplog.enable}{Enable (or disable) logging}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

   Enable (or disable) logging.

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
flag && \multicolumn{2}{p{3.36in}|}{Set True to enable logging}\\
& &allowed: & bool \\
& &Default: & True
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\

%% sd.asaplog.is_enabled
\newpage
\ahsdfunction{sd.asaplog.is\_enabled}{sd.asaplog.is_enabled}{Query if logging is enabled}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

   Query if logging is enabled.

\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\

\flushleft\vspace{.20in}\textbf {Returns}\newline

\flushleft\vspace{.20in}\textbf {Example}\\
bool
\hfill \\

%% sd.asaplog.post
\newpage
\ahfunction{sd.asaplog.post}{Post message to the logger}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

    Post the messages to the logger. This will clear the buffered
    logs.
 
\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
level && \multicolumn{2}{p{3.36in}|}{The log level (severity). One of INFO, WARN, ERROR.}\\
& &allowed: & string \\
& &Default: & INFO
\\
origin && \multicolumn{2}{p{3.36in}|}{Origin of the log message.}\\
& &allowed: & string \\
& &Default: & 
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\

%% sd.asaplog.push
\newpage
\ahfunction{sd.asaplog.push}{Push logs into the buffer}

\flushleft\vspace{.20in}\textbf {Description}\\
   \hfill \\

    Push logs into the buffer. post needs to be called to send them.
 
\flushleft\vspace{.20in}\textbf {Arguments}\\
\hfill \\
\begin{tabular}{|l p{0.25in}p{0.75in}p{2.38in}|}
\hline
Inputs && \multicolumn{2}{p{3.36in}|}{}\\
msg && \multicolumn{2}{p{3.36in}|}{the log message}\\
& &allowed: & string \\
& &Default: & 
\\
newline && \multicolumn{2}{p{3.36in}|}{should we terminate with a newline}\\
& &allowed: & bool \\
& &Default: & True
\\

\hline
\end{tabular}

\flushleft\vspace{.20in}\textbf {Returns}\newline

\flushleft\vspace{.20in}\textbf {Example}\\
\hfill \\

\newpage