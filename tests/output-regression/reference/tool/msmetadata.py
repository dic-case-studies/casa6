##################### generated by xml-casa (v2) from msmetadata.xml ################
##################### 070d15f712e50541f3c7b75887c70a2f ##############################
from __future__ import absolute_import 
from .__casac__ import msmetadata as _msmetadata
from .platform import str_encode as _str_ec
from .platform import str_decode as _str_dc
from .platform import dict_encode as _dict_ec
from .platform import dict_decode as _dict_dc
from .platform import encode as _any_ec
from .platform import decode as _any_dc
from .typecheck import validator as _pc
from .coercetype import coerce as _coerce


class msmetadata:
    ### self
    def __init__(self, *args, **kwargs):
        """
        """
        self._swigobj = kwargs.get('swig_object',None)
        if self._swigobj is None:
            self._swigobj = _msmetadata()

    def almaspws(self, chavg=False, fdm=False, sqld=False, tdm=False, wvr=False, complement=False):
        """Get spectral window IDs based on ALMA-specific criteria. The inputs are or'ed together
        to form the returned list. If complement=True, then the complement of the selection
        is returned.
        
        """
        schema = {'chavg': {'type': 'cBool'}, 'fdm': {'type': 'cBool'}, 'sqld': {'type': 'cBool'}, 'tdm': {'type': 'cBool'}, 'wvr': {'type': 'cBool'}, 'complement': {'type': 'cBool'}}
        doc = {'chavg': chavg, 'fdm': fdm, 'sqld': sqld, 'tdm': tdm, 'wvr': wvr, 'complement': complement}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _almaspws_result = self._swigobj.almaspws(_pc.document['chavg'], _pc.document['fdm'], _pc.document['sqld'], _pc.document['tdm'], _pc.document['wvr'], _pc.document['complement'])
        return _almaspws_result

    def antennadiameter(self, antenna=int(-1)):
        """Get the diameter for the specified antenna. The antenna can be specified either by
        its zero-based ID from the ANTENNA table or by its name in that table. The returned
        dictionary is a valid quantity. If a negative integer is provided for the antenna, then
        all atenna diameters will be returned in a dictionary that has keys that are the antenna IDs
        and values that are dictionaries, each being a valid quantity representing the diameter for
        that antenna ID.
        
        """
        schema = {'antenna': {'anyof': [{'type': 'cStr'}, {'type': 'cInt'}]}}
        doc = {'antenna': antenna}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _antennadiameter_result = _dict_dc(self._swigobj.antennadiameter(_any_ec(_pc.document['antenna'])))
        return _antennadiameter_result

    def antennaids(self, name='', mindiameter='0m', maxdiameter='1pc', obsid=int(-1)):
        """Get the zero-based antenna IDs for the specfied antenna names and the specified diameter
        range for the specified observation ID. An array of unique IDs in order of the specified names is returned.
        Note that if a specified name is listed mulitple times in the ANTENNA table, the largest
        ID is returned, unless the observation ID is specified to be non-negative, in which case, the
        returned IDs are filtered based on the specified observation ID.
        If no names and no diameter range is specified, all IDs are returned.
        
        """
        schema = {'name': {'anyof': [{'type': 'cStr'}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}]}, 'mindiameter': {'type': 'cVariant'}, 'maxdiameter': {'type': 'cVariant'}, 'obsid': {'type': 'cInt'}}
        doc = {'name': name, 'mindiameter': mindiameter, 'maxdiameter': maxdiameter, 'obsid': obsid}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _antennaids_result = self._swigobj.antennaids(_any_ec(_pc.document['name']), _any_ec(_pc.document['mindiameter']), _any_ec(_pc.document['maxdiameter']), _pc.document['obsid'])
        return _antennaids_result

    def antennanames(self, antennaids=int(-1)):
        """Get the name of the antenna for the specfied zero-based antenna ID. If antennaids is not specified,
        all antenna names are returned.
        
        """
        schema = {'antennaids': {'anyof': [{'type': 'cInt'}, {'type': 'cIntVec', 'coerce': [_coerce.to_list,_coerce.to_intvec]}]}}
        doc = {'antennaids': antennaids}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _antennanames_result = [_str_dc(_x) for _x in self._swigobj.antennanames(_any_ec(_pc.document['antennaids']))]
        return _antennanames_result

    def antennaoffset(self, which=int(0)):
        """Get the offset position of the specified antenna relative to the array reference position. Antenna may
        be specified as a zero-based integer (row number in the ANTENNA table) or a string representing a valid
        antenna name. The returned
        record contains the longitude, latitude, and elevation offsets as quantity records. The reported longitude and
        latitude offsets are measured along the surface of a sphere whose center is coincident with the center of
        the earth and whose surface contains the observatory reference position.
        
        """
        schema = {'which': {'anyof': [{'type': 'cStr'}, {'type': 'cInt'}]}}
        doc = {'which': which}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _antennaoffset_result = _dict_dc(self._swigobj.antennaoffset(_any_ec(_pc.document['which'])))
        return _antennaoffset_result

    def antennaposition(self, which=int(0)):
        """Get the position of the specified antenna. The returned record represents a position measure,
        and can be used as such by the measures (me) tool.
        
        """
        schema = {'which': {'anyof': [{'type': 'cInt'}, {'type': 'cStr'}]}}
        doc = {'which': which}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _antennaposition_result = _dict_dc(self._swigobj.antennaposition(_any_ec(_pc.document['which'])))
        return _antennaposition_result

    def antennastations(self, which=int(-1), obsid=int(-1)):
        """Get the station names of the specified antennas. If a specified antenna name is listed multiple
        times in the ANTENNA table, obsid is negative, and which is specified as an array of names, then
        the station associated with the largest ID for that antenna is returned. If obsid is nonnegative,
        returned stations are filtered based on that. If which is specified as a string (antenna name),
        then all the stations associated with that antenna are returned.
        
        """
        schema = {'which': {'anyof': [{'type': 'cInt'}, {'type': 'cStr'}, UNKNOWN, UNKNOWN]}, 'obsid': {'type': 'cInt'}}
        doc = {'which': which, 'obsid': obsid}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _antennastations_result = [_str_dc(_x) for _x in self._swigobj.antennastations(_any_ec(_pc.document['which']), _pc.document['obsid'])]
        return _antennastations_result

    def antennasforscan(self, scan=int(-1), obsid=int(-1), arrayid=int(-1)):
        """Get an array of the unique antennaIDs for the specified scan, observation ID, and array ID.
        
        """
        schema = {'scan': {'type': 'cInt'}, 'obsid': {'type': 'cInt'}, 'arrayid': {'type': 'cInt'}}
        doc = {'scan': scan, 'obsid': obsid, 'arrayid': arrayid}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _antennasforscan_result = self._swigobj.antennasforscan(_pc.document['scan'], _pc.document['obsid'], _pc.document['arrayid'])
        return _antennasforscan_result

    def bandwidths(self, spw=int(-1)):
        """Get the bandwidths in Hz for the specified spectral windows. If spw less than zero, return bandwidths for all spectral windows.
        
        """
        schema = {'spw': {'anyof': [{'type': 'cInt'}, UNKNOWN]}}
        doc = {'spw': spw}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _bandwidths_result = _any_dc(self._swigobj.bandwidths(_any_ec(_pc.document['spw'])))
        return _bandwidths_result

    def baseband(self, spw):
        """Get the baseband for the specified spectral window.
        
        """
        schema = {'spw': {'type': 'cInt'}}
        doc = {'spw': spw}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _baseband_result = self._swigobj.baseband(_pc.document['spw'])
        return _baseband_result

    def baselines(self):
        """Get a two dimensional boolean array representing baselines for data recorded in the MS. A value of True means
        there is at least one row in the MS main table for that baseline, False means no rows for that baseline. Autocorrelation
        "baseline" information is also present via the values along the diagonal.
        
        """
        _baselines_result = _any_dc(self._swigobj.baselines())
        return _baselines_result

    def chanavgspws(self):
        """Get an array of spectral window IDs used for channel averages. These are windows that do have 1 channel.
        
        """
        _chanavgspws_result = self._swigobj.chanavgspws()
        return _chanavgspws_result

    def chaneffbws(self, spw, unit='', asvel=False):
        """Get an array of channel effective bandwidths for the specified spectral window. The parameter
        asvel indicates if velocity widths (True) or frequency widths (False) should be returned.
        The unit parameter specifies the units that the returned values should have. If empty (default),
        "Hz" will be used if asvel=False, or "km/s" will be used if asvel=True.
        
        """
        schema = {'spw': {'type': 'cInt'}, 'unit': {'type': 'cStr'}, 'asvel': {'type': 'cBool'}}
        doc = {'spw': spw, 'unit': unit, 'asvel': asvel}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _chaneffbws_result = self._swigobj.chaneffbws(_pc.document['spw'], _str_ec(_pc.document['unit']), _pc.document['asvel'])
        return _chaneffbws_result

    def chanfreqs(self, spw, unit='Hz'):
        """Get an array of channel frequencies for the specified spectral window.
        
        """
        schema = {'spw': {'type': 'cInt'}, 'unit': {'type': 'cStr'}}
        doc = {'spw': spw, 'unit': unit}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _chanfreqs_result = self._swigobj.chanfreqs(_pc.document['spw'], _str_ec(_pc.document['unit']))
        return _chanfreqs_result

    def chanres(self, spw, unit='', asvel=False):
        """Get an array of channel resolutions for the specified spectral window. The parameter
        asvel indicates if velocity widths (True) or frequency widths (False) should be returned.
        The unit parameter specifies the units that the returned values should have. If empty (default),
        "Hz" will be used if asvel=False, or "km/s" will be used if asvel=True.
        
        """
        schema = {'spw': {'type': 'cInt'}, 'unit': {'type': 'cStr'}, 'asvel': {'type': 'cBool'}}
        doc = {'spw': spw, 'unit': unit, 'asvel': asvel}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _chanres_result = self._swigobj.chanres(_pc.document['spw'], _str_ec(_pc.document['unit']), _pc.document['asvel'])
        return _chanres_result

    def chanwidths(self, spw, unit='Hz'):
        """Get an array of channel widths for the specified spectral window.
        
        """
        schema = {'spw': {'type': 'cInt'}, 'unit': {'type': 'cStr'}}
        doc = {'spw': spw, 'unit': unit}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _chanwidths_result = self._swigobj.chanwidths(_pc.document['spw'], _str_ec(_pc.document['unit']))
        return _chanwidths_result

    def close(self):
        """This method will close the tool and reclaim system resources it has been using. Returns true if successful.
        
        """
        _close_result = self._swigobj.close()
        return _close_result

    def corrprodsforpol(self, pol=int(-1)):
        """Get the correlation products associated with the specified polarization ID.
        
        """
        schema = {'pol': {'type': 'cInt'}}
        doc = {'pol': pol}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _corrprodsforpol_result = _any_dc(self._swigobj.corrprodsforpol(_pc.document['pol']))
        return _corrprodsforpol_result

    def corrtypesforpol(self, pol=int(-1)):
        """Get the correlation types associated with the specified polarization ID.
        
        """
        schema = {'pol': {'type': 'cInt'}}
        doc = {'pol': pol}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _corrtypesforpol_result = self._swigobj.corrtypesforpol(_pc.document['pol'])
        return _corrtypesforpol_result

    def datadescids(self, spw=int(-1), pol=int(-1)):
        """Get a list of data description IDs associated with the specified spectral window ID
        and/or polarization ID. Values of less than zero for either means all IDs should be used
        in the selection.
        
        """
        schema = {'spw': {'type': 'cInt'}, 'pol': {'type': 'cInt'}}
        doc = {'spw': spw, 'pol': pol}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _datadescids_result = self._swigobj.datadescids(_pc.document['spw'], _pc.document['pol'])
        return _datadescids_result

    def done(self):
        """This method will close the tool and reclaim system resources it has been using. Returns true if successful.
        
        """
        _done_result = self._swigobj.done()
        return _done_result

    def effexposuretime(self):
        """Get the effective exposure time (equivalent to what might be more commonly known as total integration
        time or total sample time) is calculated by summing over all rows in the main MS table, excluding
        autocorrelations or rows where FLAG_ROW is false, thusly:
        
        sum[over i] (exposure[i]*sum[over j](UFBW[i, j])/ncorrelations[i] )/ nmaxbaselines
        
        where exposure[i] is the value of EXPOSURE for the ith row, the inner sum is performed over each correlation
        for that row, UFBW is the unflagged fractional bandwidth is determined by summing all the widths of the
        unflagged channels for that correlation and dividing by the total bandwidth of all spectral windows observed
        at the timestamp of row i, ncorrelations is the number of correlations determined by the number of rows in
        the FLAG matrix for MS row i, and nmaxbaselines is the maximum number of antenna pairs,
        nantennas*(nantennas-1)/2, where nantennas is the number of antennas in the ANTENNA table. This method returns
        a quantity (a dictionary having a numerical value and a string unit).
        
        """
        _effexposuretime_result = _dict_dc(self._swigobj.effexposuretime())
        return _effexposuretime_result

    def exposuretime(self, scan=int(0), spwid=int(0), polid=int(-1), obsid=int(0), arrayid=int(0)):
        """Get the exposure time for the specified scan, spwid, polarization ID, array ID, and observation ID.
        This is the exposure time of the record with the lowest time stamp of the records associated with
        these parameters. Returns a quantity dictionary. If polid is not specified (or specified and negative)
        and there is only one polarization ID in for the specified combination of scan, spwid, obsID, and
        arrayID, then that polarization ID is used. If there are multiple polarization IDs for the
        combination of other parameters, a list of these is logged and an empty dictionary is returned.
        
        """
        schema = {'scan': {'type': 'cInt'}, 'spwid': {'type': 'cInt'}, 'polid': {'type': 'cInt'}, 'obsid': {'type': 'cInt'}, 'arrayid': {'type': 'cInt'}}
        doc = {'scan': scan, 'spwid': spwid, 'polid': polid, 'obsid': obsid, 'arrayid': arrayid}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _exposuretime_result = _dict_dc(self._swigobj.exposuretime(_pc.document['scan'], _pc.document['spwid'], _pc.document['polid'], _pc.document['obsid'], _pc.document['arrayid']))
        return _exposuretime_result

    def fdmspws(self):
        """Get an array of spectral window IDs used for FDM. These are windows that do not have 64, 128, or 256 channels.
        
        """
        _fdmspws_result = self._swigobj.fdmspws()
        return _fdmspws_result

    def fieldnames(self):
        """Get an array of field names as they appear in the FIELD table.
        
        """
        _fieldnames_result = [_str_dc(_x) for _x in self._swigobj.fieldnames()]
        return _fieldnames_result

    def fieldsforintent(self, intent='', asnames=False):
        """Get an array of the unique fields for the specified intent. Note that * matches any number of characters of all character classes.
        
        """
        schema = {'intent': {'type': 'cStr'}, 'asnames': {'type': 'cBool'}}
        doc = {'intent': intent, 'asnames': asnames}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _fieldsforintent_result = _any_dc(self._swigobj.fieldsforintent(_str_ec(_pc.document['intent']), _pc.document['asnames']))
        return _fieldsforintent_result

    def fieldsforname(self, name=''):
        """Get an array of the unique, zero-based field IDs for the specified field name. If the field name is the
        empty string (the default), a list of all unique field IDs in the main table of the MS will be returned.
        
        """
        schema = {'name': {'type': 'cStr'}}
        doc = {'name': name}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _fieldsforname_result = self._swigobj.fieldsforname(_str_ec(_pc.document['name']))
        return _fieldsforname_result

    def fieldsforscan(self, scan=int(-1), asnames=False, obsid=int(-1), arrayid=int(-1)):
        """Get an array of the unique fields for the specified scan number, observation ID, and array ID.
        
        """
        schema = {'scan': {'type': 'cInt'}, 'asnames': {'type': 'cBool'}, 'obsid': {'type': 'cInt'}, 'arrayid': {'type': 'cInt'}}
        doc = {'scan': scan, 'asnames': asnames, 'obsid': obsid, 'arrayid': arrayid}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _fieldsforscan_result = _any_dc(self._swigobj.fieldsforscan(_pc.document['scan'], _pc.document['asnames'], _pc.document['obsid'], _pc.document['arrayid']))
        return _fieldsforscan_result

    def fieldsforscans(self, scans=[  ], asnames=False, obsid=int(-1), arrayid=int(-1), asmap=False):
        """Get an array or dictionary of the unique fields for the specified scan numbers, observation ID, and array ID.
        If asnames=True, the values returned will be the field names, if False, they will be field IDs.
        If asmap=True, the structure returned will be a dictionary which maps scan number (as a string) to fields.
        In this case, both obsid and arrayid must be nonnegative. If asmap=False, a single array of fields is returned
        that matches the query. In this case, if obsid and/or arrayid are negative, then it indicates that all
        fields matching any obsid and/or arrayid should be returned. An empty array specified for scans means
        that all scans for the selected obsid and arrayid should be included.
        
        """
        schema = {'scans': {'type': 'cIntVec', 'coerce': [_coerce.to_list,_coerce.to_intvec]}, 'asnames': {'type': 'cBool'}, 'obsid': {'type': 'cInt'}, 'arrayid': {'type': 'cInt'}, 'asmap': {'type': 'cBool'}}
        doc = {'scans': scans, 'asnames': asnames, 'obsid': obsid, 'arrayid': arrayid, 'asmap': asmap}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _fieldsforscans_result = _any_dc(self._swigobj.fieldsforscans(_pc.document['scans'], _pc.document['asnames'], _pc.document['obsid'], _pc.document['arrayid'], _pc.document['asmap']))
        return _fieldsforscans_result

    def fieldsforsource(self, source=int(-1), asnames=False):
        """Get an array of the unique fields for the specified source.
        
        """
        schema = {'source': {'type': 'cInt'}, 'asnames': {'type': 'cBool'}}
        doc = {'source': source, 'asnames': asnames}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _fieldsforsource_result = _any_dc(self._swigobj.fieldsforsource(_pc.document['source'], _pc.document['asnames']))
        return _fieldsforsource_result

    def fieldsforsources(self, asnames=False):
        """Get a map of source IDs to fields. The keys (source IDs) will be strings.
        
        """
        schema = {'asnames': {'type': 'cBool'}}
        doc = {'asnames': asnames}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _fieldsforsources_result = _dict_dc(self._swigobj.fieldsforsources(_pc.document['asnames']))
        return _fieldsforsources_result

    def fieldsforspw(self, spw=int(-1), asnames=False):
        """Get an array of the unique fields for the specified spectral window.
        
        """
        schema = {'spw': {'type': 'cInt'}, 'asnames': {'type': 'cBool'}}
        doc = {'spw': spw, 'asnames': asnames}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _fieldsforspw_result = _any_dc(self._swigobj.fieldsforspw(_pc.document['spw'], _pc.document['asnames']))
        return _fieldsforspw_result

    def fieldsfortimes(self, time=float(-1), tol=float(0)):
        """Get an array of the unique, zero-based, fieldIDs for the specified time range (time-tol to time+tol).
        
        """
        schema = {'time': {'type': 'cFloat', 'coerce': _coerce.to_float}, 'tol': {'type': 'cFloat', 'coerce': _coerce.to_float}}
        doc = {'time': time, 'tol': tol}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _fieldsfortimes_result = self._swigobj.fieldsfortimes(_pc.document['time'], _pc.document['tol'])
        return _fieldsfortimes_result

    def intents(self):
        """Get an array of the unique intents associated with the MS.
        
        """
        _intents_result = [_str_dc(_x) for _x in self._swigobj.intents()]
        return _intents_result

    def intentsforfield(self, field=int(0)):
        """Get an array of the unique intents for the specified field.
        
        """
        schema = {'field': {'anyof': [{'type': 'cInt'}, {'type': 'cStr'}]}}
        doc = {'field': field}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _intentsforfield_result = [_str_dc(_x) for _x in self._swigobj.intentsforfield(_any_ec(_pc.document['field']))]
        return _intentsforfield_result

    def intentsforscan(self, scan=int(-1), obsid=int(-1), arrayid=int(-1)):
        """Get an array of the unique intents for the specified scan, observation ID, and array ID.
        
        """
        schema = {'scan': {'type': 'cInt'}, 'obsid': {'type': 'cInt'}, 'arrayid': {'type': 'cInt'}}
        doc = {'scan': scan, 'obsid': obsid, 'arrayid': arrayid}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _intentsforscan_result = [_str_dc(_x) for _x in self._swigobj.intentsforscan(_pc.document['scan'], _pc.document['obsid'], _pc.document['arrayid'])]
        return _intentsforscan_result

    def intentsforspw(self, spw=int(-1)):
        """Get an array of the unique intents for the specified spectral window ID.
        
        """
        schema = {'spw': {'type': 'cInt'}}
        doc = {'spw': spw}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _intentsforspw_result = [_str_dc(_x) for _x in self._swigobj.intentsforspw(_pc.document['spw'])]
        return _intentsforspw_result

    def meanfreq(self, spw, unit='Hz'):
        """Get the mean frequency for the specified spectral window.
        
        """
        schema = {'spw': {'type': 'cInt'}, 'unit': {'type': 'cStr'}}
        doc = {'spw': spw, 'unit': unit}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _meanfreq_result = self._swigobj.meanfreq(_pc.document['spw'], _str_ec(_pc.document['unit']))
        return _meanfreq_result

    def name(self):
        """Get the name of the attached MS.
        
        """
        _name_result = _str_dc(self._swigobj.name())
        return _name_result

    def namesforfields(self, fieldids=''):
        """Get the name of the specified field.
        
        """
        schema = {'fieldids': {'anyof': [{'type': 'cStr'}, {'type': 'cInt'}, {'type': 'cIntVec', 'coerce': [_coerce.to_list,_coerce.to_intvec]}]}}
        doc = {'fieldids': fieldids}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _namesforfields_result = [_str_dc(_x) for _x in self._swigobj.namesforfields(_any_ec(_pc.document['fieldids']))]
        return _namesforfields_result

    def namesforspws(self, spwids=''):
        """Get the name of the specified spw(s).
        
        """
        schema = {'spwids': {'anyof': [{'type': 'cStr'}, {'type': 'cInt'}, {'type': 'cIntVec', 'coerce': [_coerce.to_list,_coerce.to_intvec]}]}}
        doc = {'spwids': spwids}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _namesforspws_result = [_str_dc(_x) for _x in self._swigobj.namesforspws(_any_ec(_pc.document['spwids']))]
        return _namesforspws_result

    def nantennas(self):
        """Get the number of antennas associated with the MS.
        
        """
        _nantennas_result = self._swigobj.nantennas()
        return _nantennas_result

    def narrays(self):
        """Get the number of arrays associated with the MS from the ARRAY table.
        
        """
        _narrays_result = self._swigobj.narrays()
        return _narrays_result

    def nbaselines(self, ac=False):
        """Get the number of unique baselines (antenna pairs) represented in the main MS table. This can, in theory, be less than
        n*(n-1)/2 (n being the number of antennas in the ANTENNA table), if data for certain baselines
        are not included in the main MS table. Autocorrelation "baselines" are included in this count if ac=True.
        
        """
        schema = {'ac': {'type': 'cBool'}}
        doc = {'ac': ac}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _nbaselines_result = self._swigobj.nbaselines(_pc.document['ac'])
        return _nbaselines_result

    def nchan(self, spw):
        """Get the number of channels associated with the specified spectral window.
        
        """
        schema = {'spw': {'type': 'cInt'}}
        doc = {'spw': spw}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _nchan_result = self._swigobj.nchan(_pc.document['spw'])
        return _nchan_result

    def ncorrforpol(self, polid=int(-1)):
        """Get the number of correlations for the specified polarization ID. If the specified polarization ID
        is negative, an array of numbers of correlations is returned. The indices of that array represent polarization IDs.
        
        """
        schema = {'polid': {'type': 'cInt'}}
        doc = {'polid': polid}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _ncorrforpol_result = _any_dc(self._swigobj.ncorrforpol(_pc.document['polid']))
        return _ncorrforpol_result

    def nfields(self):
        """Get the number of fields associated with the MS.
        
        """
        _nfields_result = self._swigobj.nfields()
        return _nfields_result

    def nobservations(self):
        """Get the number of observations associated with the MS from the OBSERVATIONS table.
        
        """
        _nobservations_result = self._swigobj.nobservations()
        return _nobservations_result

    def nspw(self, includewvr=True):
        """This method will return the number of spectral windows in the associated MS.
        
        """
        schema = {'includewvr': {'type': 'cBool'}}
        doc = {'includewvr': includewvr}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _nspw_result = self._swigobj.nspw(_pc.document['includewvr'])
        return _nspw_result

    def nstates(self):
        """This method will return the number of states (number of rows in the STATES table) in the associated MS.
        
        """
        _nstates_result = self._swigobj.nstates()
        return _nstates_result

    def nscans(self):
        """Get the number of scans associated with the MS.
        
        """
        _nscans_result = self._swigobj.nscans()
        return _nscans_result

    def nsources(self):
        """Get the number of unique values from the SOURCE_ID column in the SOURCE table. The number of rows in the
        SOURCE table may be greater than this value.
        
        """
        _nsources_result = self._swigobj.nsources()
        return _nsources_result

    def nrows(self, autoc=True, flagged=True):
        """Get the number of visibilities (from the main table) associated with the MS.
        
        """
        schema = {'autoc': {'type': 'cBool'}, 'flagged': {'type': 'cBool'}}
        doc = {'autoc': autoc, 'flagged': flagged}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _nrows_result = self._swigobj.nrows(_pc.document['autoc'], _pc.document['flagged'])
        return _nrows_result

    def observers(self):
        """Get an array of observers as they are listed in the OBSERVATIONS table.
        
        """
        _observers_result = [_str_dc(_x) for _x in self._swigobj.observers()]
        return _observers_result

    def observatorynames(self):
        """Get an array of MS telescope (observatory) names as they are listed in the OBSERVATIONS table.
        
        """
        _observatorynames_result = [_str_dc(_x) for _x in self._swigobj.observatorynames()]
        return _observatorynames_result

    def observatoryposition(self, which=int(0)):
        """Get the position of the specified telescope.
        
        """
        schema = {'which': {'type': 'cInt'}}
        doc = {'which': which}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _observatoryposition_result = _dict_dc(self._swigobj.observatoryposition(_pc.document['which']))
        return _observatoryposition_result

    def open(self, msfile='', maxcache=float(50)):
        """Attach this tool to the specified MS. This method runs a few basic MS validation tests, and if any of these
        fail (which indicates that the MS is invalid), an error occurs and the tool is not attached to the MS.
        Note that it is ultimately the user's responsibility to ensure that the MS is valid. Running the methods
        of this tool on an invalid MS may result in incorrect results or even a crash of CASA. Such invalidities
        include any MS subtable not having appropriate information (eg, an OBSERVATION subtable not having enough rows
        to account for all the OBSERVATION_IDs in the main table).
        
        """
        schema = {'msfile': {'type': 'cStr'}, 'maxcache': {'type': 'cFloat', 'coerce': _coerce.to_float}}
        doc = {'msfile': msfile, 'maxcache': maxcache}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _open_result = self._swigobj.open(_str_ec(_pc.document['msfile']), _pc.document['maxcache'])
        return _open_result

    def phasecenter(self, fieldid=int(0), epoch={ }):
        """Get a direction measures for the phasecenter of the field id and time specified
        
        """
        schema = {'fieldid': {'type': 'cInt'}, 'epoch': {'type': 'cDict'}}
        doc = {'fieldid': fieldid, 'epoch': epoch}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _phasecenter_result = _dict_dc(self._swigobj.phasecenter(_pc.document['fieldid'], _dict_ec(_pc.document['epoch'])))
        return _phasecenter_result

    def pointingdirection(self, rownum=int(0), interpolate=False, initialrow=int(0)):
        """Get the pointing direction for antennas at the specified row number in the main MS table. Returns a record
        containing the time, antenna IDs and corresponding pointing directions.
        
        """
        schema = {'rownum': {'type': 'cInt'}, 'interpolate': {'type': 'cBool'}, 'initialrow': {'type': 'cInt'}}
        doc = {'rownum': rownum, 'interpolate': interpolate, 'initialrow': initialrow}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _pointingdirection_result = _dict_dc(self._swigobj.pointingdirection(_pc.document['rownum'], _pc.document['interpolate'], _pc.document['initialrow']))
        return _pointingdirection_result

    def polidfordatadesc(self, ddid=int(-1)):
        """Get the polarization ID associated with the specified data description ID. If the specified data description ID
        is negative, an array of polarization IDs is returned. The indices of that array represent data description IDs.
        
        """
        schema = {'ddid': {'type': 'cInt'}}
        doc = {'ddid': ddid}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _polidfordatadesc_result = _any_dc(self._swigobj.polidfordatadesc(_pc.document['ddid']))
        return _polidfordatadesc_result

    def projects(self):
        """Get an array of projects as they are listed in the OBSERVATIONS table.
        
        """
        _projects_result = [_str_dc(_x) for _x in self._swigobj.projects()]
        return _projects_result

    def propermotions(self):
        """Get the values of the DIRECTION column from the SOURCE table. Returns a dictionary in which the
        keys are the associated zero-based row numbers, represented as strings, in the SOURCE table. The
        associated values are two element dictionaries, with keys "longitude" and "latitude", containing
        the longitudinal and latidinal components of the proper motion, which are valid quantity dictionaries.
        
        """
        _propermotions_result = _dict_dc(self._swigobj.propermotions())
        return _propermotions_result

    def refdir(self, field=int(0), epoch={ }):
        """Get a direction measure for the reference direction of the field and time specified
        
        """
        schema = {'field': {'anyof': [{'type': 'cStr'}, {'type': 'cInt'}]}, 'epoch': {'type': 'cDict'}}
        doc = {'field': field, 'epoch': epoch}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _refdir_result = _dict_dc(self._swigobj.refdir(_any_ec(_pc.document['field']), _dict_ec(_pc.document['epoch'])))
        return _refdir_result

    def reffreq(self, spw=int(-1)):
        """Get the reference frequency of the specified spectral window. The returned frequency is in
        the form of a valid measures dictionary.
        
        """
        schema = {'spw': {'type': 'cInt'}}
        doc = {'spw': spw}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _reffreq_result = _dict_dc(self._swigobj.reffreq(_pc.document['spw']))
        return _reffreq_result

    def restfreqs(self, sourceid=int(0), spw=int(0)):
        """Get the rest frequencies from the SOURCE table for the specified source and spectral window.
        The return value will be a dictionary of frequency measures if the rest frequencies are
        defined for the specified inputs, or False if they do not.
        
        """
        schema = {'sourceid': {'type': 'cInt'}, 'spw': {'type': 'cInt'}}
        doc = {'sourceid': sourceid, 'spw': spw}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _restfreqs_result = _any_dc(self._swigobj.restfreqs(_pc.document['sourceid'], _pc.document['spw']))
        return _restfreqs_result

    def scannumbers(self, obsid=int(-1), arrayid=int(-1)):
        """This method will return an array of unique scan numbers in the associated MS for the specified observation ID and array ID.
        
        """
        schema = {'obsid': {'type': 'cInt'}, 'arrayid': {'type': 'cInt'}}
        doc = {'obsid': obsid, 'arrayid': arrayid}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _scannumbers_result = self._swigobj.scannumbers(_pc.document['obsid'], _pc.document['arrayid'])
        return _scannumbers_result

    def scansforfield(self, intent='', obsid=int(-1), arrayid=int(-1)):
        """Get an array of the unique scan numbers associated with the specified field, observation ID, and array ID.
        
        """
        schema = {'intent': {'anyof': [{'type': 'cStr'}, {'type': 'cInt'}]}, 'obsid': {'type': 'cInt'}, 'arrayid': {'type': 'cInt'}}
        doc = {'intent': intent, 'obsid': obsid, 'arrayid': arrayid}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _scansforfield_result = self._swigobj.scansforfield(_any_ec(_pc.document['intent']), _pc.document['obsid'], _pc.document['arrayid'])
        return _scansforfield_result

    def scansforfields(self, obsid=int(0), arrayid=int(0)):
        """Get a dictionary of which maps field ID to scan numbers for the specified observation ID
        and array ID. The keys (field IDs) will be strings. obsid and arrayid must both
        be non-negative.
        
        """
        schema = {'obsid': {'type': 'cInt'}, 'arrayid': {'type': 'cInt'}}
        doc = {'obsid': obsid, 'arrayid': arrayid}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _scansforfields_result = _dict_dc(self._swigobj.scansforfields(_pc.document['obsid'], _pc.document['arrayid']))
        return _scansforfields_result

    def scansforintent(self, intent='', obsid=int(-1), arrayid=int(-1)):
        """Get an array of the unique scan numbers associated with the specified intent, observation ID, and arrayID.
        The "*" character matches any number of characters from all character classes.
        
        """
        schema = {'intent': {'type': 'cStr'}, 'obsid': {'type': 'cInt'}, 'arrayid': {'type': 'cInt'}}
        doc = {'intent': intent, 'obsid': obsid, 'arrayid': arrayid}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _scansforintent_result = self._swigobj.scansforintent(_str_ec(_pc.document['intent']), _pc.document['obsid'], _pc.document['arrayid'])
        return _scansforintent_result

    def scansforspw(self, spw=int(-1), obsid=int(-1), arrayid=int(-1)):
        """Get an array of the unique scan numbers associated with the specified zero-based spectral window ID, observation ID, and array ID.
        
        """
        schema = {'spw': {'type': 'cInt'}, 'obsid': {'type': 'cInt'}, 'arrayid': {'type': 'cInt'}}
        doc = {'spw': spw, 'obsid': obsid, 'arrayid': arrayid}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _scansforspw_result = self._swigobj.scansforspw(_pc.document['spw'], _pc.document['obsid'], _pc.document['arrayid'])
        return _scansforspw_result

    def scansforspws(self, obsid=int(0), arrayid=int(0)):
        """Get a dictionary of which maps spw ID to scan numbers for the specified observation ID
        and array ID. The keys (spectral window IDs) will be strings. obsid and arrayid must both
        be non-negative.
        
        """
        schema = {'obsid': {'type': 'cInt'}, 'arrayid': {'type': 'cInt'}}
        doc = {'obsid': obsid, 'arrayid': arrayid}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _scansforspws_result = _dict_dc(self._swigobj.scansforspws(_pc.document['obsid'], _pc.document['arrayid']))
        return _scansforspws_result

    def scansforstate(self, state=int(-1), obsid=int(-1), arrayid=int(-1)):
        """Get an array of the unique scan numbers for the specified state, observation ID, and array ID.
        
        """
        schema = {'state': {'type': 'cInt'}, 'obsid': {'type': 'cInt'}, 'arrayid': {'type': 'cInt'}}
        doc = {'state': state, 'obsid': obsid, 'arrayid': arrayid}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _scansforstate_result = self._swigobj.scansforstate(_pc.document['state'], _pc.document['obsid'], _pc.document['arrayid'])
        return _scansforstate_result

    def scansfortimes(self, time=float(-1), tol=float(0), obsid=int(-1), arrayid=int(-1)):
        """Get an array of the unique scan numbers for the specified time range (time-tol to time+tol), observation ID, and array ID.
        
        """
        schema = {'time': {'type': 'cFloat', 'coerce': _coerce.to_float}, 'tol': {'type': 'cFloat', 'coerce': _coerce.to_float}, 'obsid': {'type': 'cInt'}, 'arrayid': {'type': 'cInt'}}
        doc = {'time': time, 'tol': tol, 'obsid': obsid, 'arrayid': arrayid}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _scansfortimes_result = self._swigobj.scansfortimes(_pc.document['time'], _pc.document['tol'], _pc.document['obsid'], _pc.document['arrayid'])
        return _scansfortimes_result

    def schedule(self, obsid=int(-1)):
        """Get the schedule information for the specified observation ID.
        
        """
        schema = {'obsid': {'type': 'cInt'}}
        doc = {'obsid': obsid}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _schedule_result = [_str_dc(_x) for _x in self._swigobj.schedule(_pc.document['obsid'])]
        return _schedule_result

    def sideband(self, spw):
        """Get the sideband for the specified spectral window.
        
        """
        schema = {'spw': {'type': 'cInt'}}
        doc = {'spw': spw}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _sideband_result = self._swigobj.sideband(_pc.document['spw'])
        return _sideband_result

    def sourcedirs(self):
        """Get the values of the DIRECTION column from the SOURCE table. Returns a dictionary in which the
        keys are the associated row numbers, represented as strings, in the SOURCE table. Each value
        in the returned dictionary is a valid direction measure.
        
        """
        _sourcedirs_result = _dict_dc(self._swigobj.sourcedirs())
        return _sourcedirs_result

    def sourcetimes(self):
        """Get the values of the TIME column from the SOURCE table. Returns a dictionary in which the
        keys are the associated row numbers, represented as strings, in the SOURCE table. Each value
        in the returned dictionary is a valid time quantity.
        
        """
        _sourcetimes_result = _dict_dc(self._swigobj.sourcetimes())
        return _sourcetimes_result

    def sourceidforfield(self, field=int(-1)):
        """Get the source ID from the field table for the specified field ID.
        
        """
        schema = {'field': {'type': 'cInt'}}
        doc = {'field': field}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _sourceidforfield_result = self._swigobj.sourceidforfield(_pc.document['field'])
        return _sourceidforfield_result

    def sourceidsfromsourcetable(self):
        """Get the values of the SOURCE_ID column from the SOURCE table. It is unfortunate that the SOURCE
        table has a column named SOURCE_ID, because implicitly the "ID" of a row in an MS subtable is
        generally meant to reflect a row number in that table, but that is not the case for the SOURCE table.
        
        """
        _sourceidsfromsourcetable_result = self._swigobj.sourceidsfromsourcetable()
        return _sourceidsfromsourcetable_result

    def sourcenames(self):
        """Get the values of the SOURCE_NAME column from the SOURCE table.
        
        """
        _sourcenames_result = [_str_dc(_x) for _x in self._swigobj.sourcenames()]
        return _sourcenames_result

    def spwsforbaseband(self, baseband=int(-1), sqldmode='include'):
        """Get the spectral windows associated with the specified baseband or dictionary that maps baseband to spectral windows.
        
        """
        schema = {'baseband': {'type': 'cInt'}, 'sqldmode': {'type': 'cStr'}}
        doc = {'baseband': baseband, 'sqldmode': sqldmode}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _spwsforbaseband_result = _any_dc(self._swigobj.spwsforbaseband(_pc.document['baseband'], _str_ec(_pc.document['sqldmode'])))
        return _spwsforbaseband_result

    def spwfordatadesc(self, ddid=int(-1)):
        """Get the spectral window ID associated with the specified data description ID. If the specified data description ID
        is negative, an array of spectral window IDs is returned. The indices of that array represent data description IDs.
        
        """
        schema = {'ddid': {'type': 'cInt'}}
        doc = {'ddid': ddid}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _spwfordatadesc_result = _any_dc(self._swigobj.spwfordatadesc(_pc.document['ddid']))
        return _spwfordatadesc_result

    def spwsforfield(self, field=''):
        """Get an array of the unique spectral window IDs for the specified field.
        
        """
        schema = {'field': {'anyof': [{'type': 'cStr'}, {'type': 'cInt'}]}}
        doc = {'field': field}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _spwsforfield_result = self._swigobj.spwsforfield(_any_ec(_pc.document['field']))
        return _spwsforfield_result

    def spwsforfields(self):
        """Get a dictionary which maps field IDs to spectral window IDs. The field IDs are keys in the
        returned dictionary. To access a particular element, one must ensure the key is a string.
        
        """
        _spwsforfields_result = _dict_dc(self._swigobj.spwsforfields())
        return _spwsforfields_result

    def spwsforintent(self, intent=''):
        """Get an array of the unique spectral window IDs for the specified intent. The "*" character matches any number of characters from all character classes.
        
        """
        schema = {'intent': {'type': 'cStr'}}
        doc = {'intent': intent}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _spwsforintent_result = self._swigobj.spwsforintent(_str_ec(_pc.document['intent']))
        return _spwsforintent_result

    def spwsfornames(self, spwids=''):
        """Get the IDs of the specified spw(s). Returns a dictionary where the keys
        are the requested spectral window names that are present in the data set
        and the values are arrays of the spectral window IDs corresponding to the
        name. If a specified name is not present, a warning message is logged and
        that name is not included in the returned dictionary. Specifying no names
        results in a dictionary containing the name to spw ID mapping for the
        entire data set.
        
        """
        schema = {'spwids': {'anyof': [{'type': 'cStr'}, {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}]}}
        doc = {'spwids': spwids}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _spwsfornames_result = _dict_dc(self._swigobj.spwsfornames(_any_ec(_pc.document['spwids'])))
        return _spwsfornames_result

    def spwsforscan(self, scan=int(-1), obsid=int(-1), arrayid=int(-1)):
        """Get an array of the unique spectral window IDs for the specified scan number, observation ID, and array ID.
        
        """
        schema = {'scan': {'type': 'cInt'}, 'obsid': {'type': 'cInt'}, 'arrayid': {'type': 'cInt'}}
        doc = {'scan': scan, 'obsid': obsid, 'arrayid': arrayid}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _spwsforscan_result = self._swigobj.spwsforscan(_pc.document['scan'], _pc.document['obsid'], _pc.document['arrayid'])
        return _spwsforscan_result

    def spwsforscans(self, obsid=int(0), arrayid=int(0)):
        """Get a dictionary of which maps scan number to spectral windows for the specified observation ID and array ID. The keys (scan
        numbers) will be strings. obsid and arrayid must both be non-negative.
        
        """
        schema = {'obsid': {'type': 'cInt'}, 'arrayid': {'type': 'cInt'}}
        doc = {'obsid': obsid, 'arrayid': arrayid}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _spwsforscans_result = _dict_dc(self._swigobj.spwsforscans(_pc.document['obsid'], _pc.document['arrayid']))
        return _spwsforscans_result

    def statesforscan(self, scan=int(-1), obsid=int(-1), arrayid=int(-1)):
        """Get an array of the unique state IDs for the specified scan number, observation ID, and array ID.
        
        """
        schema = {'scan': {'type': 'cInt'}, 'obsid': {'type': 'cInt'}, 'arrayid': {'type': 'cInt'}}
        doc = {'scan': scan, 'obsid': obsid, 'arrayid': arrayid}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _statesforscan_result = self._swigobj.statesforscan(_pc.document['scan'], _pc.document['obsid'], _pc.document['arrayid'])
        return _statesforscan_result

    def statesforscans(self, obsid=int(0), arrayid=int(0)):
        """Get a dictionary which maps scan numbers to state IDs for the specified array and observation IDs. The returned dictionary
        will have scan numbers, as strings, as keys.
        
        """
        schema = {'obsid': {'type': 'cInt'}, 'arrayid': {'type': 'cInt'}}
        doc = {'obsid': obsid, 'arrayid': arrayid}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _statesforscans_result = _dict_dc(self._swigobj.statesforscans(_pc.document['obsid'], _pc.document['arrayid']))
        return _statesforscans_result

    def summary(self):
        """Get dictionary summarizing the MS.
        
        """
        _summary_result = _dict_dc(self._swigobj.summary())
        return _summary_result

    def tdmspws(self):
        """Get an array of spectral window IDs used for TDM. These are windows that have 64, 128, or 256 channels.
        
        """
        _tdmspws_result = self._swigobj.tdmspws()
        return _tdmspws_result

    def timerangeforobs(self, obsid=int(-1)):
        """Get the time range for the specified observation ID. The return value is a dictionary containing
        keys "begin" and "end". Each of the associated value are dictionaries representing epochs which
        are valid measure records. The values are taken directly from the OBSERVATION subtable; no
        half-intervals are added or subtracted.
        
        """
        schema = {'obsid': {'type': 'cInt'}}
        doc = {'obsid': obsid}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _timerangeforobs_result = _dict_dc(self._swigobj.timerangeforobs(_pc.document['obsid']))
        return _timerangeforobs_result

    def timesforfield(self, field=int(-1)):
        """Get an array of the unique times for the specified field.
        
        """
        schema = {'field': {'type': 'cInt'}}
        doc = {'field': field}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _timesforfield_result = self._swigobj.timesforfield(_pc.document['field'])
        return _timesforfield_result

    def timesforintent(self, intent=''):
        """Get an array of the unique times for the specified intent.
        
        """
        schema = {'intent': {'type': 'cStr'}}
        doc = {'intent': intent}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _timesforintent_result = self._swigobj.timesforintent(_str_ec(_pc.document['intent']))
        return _timesforintent_result

    def timesforscan(self, scan=int(-1), obsid=int(-1), arrayid=int(-1), perspw=False):
        """Get the unique times for the specified scan number, observation ID, and array ID. If perspw=True, the returned data structure is
        a dictionary that has keys representing zero-based spectral window IDs and values representing the unique values of the TIME column
        corrsponding to the specified scan and that corresponding spectral window ID. If False, an array of unique values from the TIME
        column for the specified scan is returned; there is no separation into spectral window IDs.
        
        """
        schema = {'scan': {'type': 'cInt'}, 'obsid': {'type': 'cInt'}, 'arrayid': {'type': 'cInt'}, 'perspw': {'type': 'cBool'}}
        doc = {'scan': scan, 'obsid': obsid, 'arrayid': arrayid, 'perspw': perspw}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _timesforscan_result = _any_dc(self._swigobj.timesforscan(_pc.document['scan'], _pc.document['obsid'], _pc.document['arrayid'], _pc.document['perspw']))
        return _timesforscan_result

    def timesforscans(self, scans=[ int(-1) ], obsid=int(-1), arrayid=int(-1)):
        """Get an array of the unique times for the specified scan numbers, observation ID, and array ID.
        
        """
        schema = {'scans': {'type': 'cIntVec', 'coerce': [_coerce.to_list,_coerce.to_intvec]}, 'obsid': {'type': 'cInt'}, 'arrayid': {'type': 'cInt'}}
        doc = {'scans': scans, 'obsid': obsid, 'arrayid': arrayid}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _timesforscans_result = self._swigobj.timesforscans(_pc.document['scans'], _pc.document['obsid'], _pc.document['arrayid'])
        return _timesforscans_result

    def timesforspws(self, spw=int(-1)):
        """Get the unique times corresponding to the specified spectral window(s). The input indicates the
        spws for which times are to be retrieved, and can be a single integer or an array of
        integers. If a single, non-negative integer, an array of unique times associated with
        that spectral window are returned. Otherwise, a dictionary of times associated with the
        specified spectral windows are returned, with the spws (as strings) as the keys and the
        times as the values. A negative integer will cause a dictionary of all spws and their
        associated times to be returned.
        
        """
        schema = {'spw': {'anyof': [{'type': 'cInt'}, {'type': 'cIntVec', 'coerce': [_coerce.to_list,_coerce.to_intvec]}]}}
        doc = {'spw': spw}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _timesforspws_result = _any_dc(self._swigobj.timesforspws(_any_ec(_pc.document['spw'])))
        return _timesforspws_result

    def transitions(self, sourceid=int(0), spw=int(0)):
        """Get the spectral transitions from the SOURCE table for the specified source and spectral window.
        The return value will be an array of transitions if the transitions are
        defined for the specified inputs, or False if they do not.
        
        """
        schema = {'sourceid': {'type': 'cInt'}, 'spw': {'type': 'cInt'}}
        doc = {'sourceid': sourceid, 'spw': spw}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _transitions_result = _any_dc(self._swigobj.transitions(_pc.document['sourceid'], _pc.document['spw']))
        return _transitions_result

    def wvrspws(self, complement=False):
        """Get an array of spectral window IDs used for WVR. These are windows that have 4 channels.
        If complement is True, return the complement set instead (all non-wvr spw IDs).
        
        """
        schema = {'complement': {'type': 'cBool'}}
        doc = {'complement': complement}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _wvrspws_result = self._swigobj.wvrspws(_pc.document['complement'])
        return _wvrspws_result

