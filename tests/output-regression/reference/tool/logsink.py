##################### generated by xml-casa (v2) from logsink.xml ###################
##################### 2c61a1398d9ef908298f9bf297e60b85 ##############################
from __future__ import absolute_import 
from .__casac__ import logsink as _logsink
from .platform import str_encode as _str_ec
from .platform import str_decode as _str_dc
from .platform import dict_encode as _dict_ec
from .platform import dict_decode as _dict_dc
from .platform import encode as _any_ec
from .platform import decode as _any_dc
from .typecheck import validator as _pc
from .coercetype import coerce as _coerce


class logsink:
    ### self, filename='casa.log'
    def __init__(self, filename='casa.log', *args, **kwargs):
        """
        """
        schema = {'filename': {'type': 'cStr'}}
        doc = {'filename': filename}
        assert _pc.validate(doc,schema), str(_pc.errors)
        self._swigobj = kwargs.get('swig_object',None)
        if self._swigobj is None:
            self._swigobj = _logsink(_str_ec(_pc.document['filename']))

    def origin(self, fromwhere):
        """Sets the origin of messages to be displayed
        """
        schema = {'fromwhere': {'type': 'cStr'}}
        doc = {'fromwhere': fromwhere}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _origin_result = self._swigobj.origin(_str_ec(_pc.document['fromwhere']))
        return _origin_result

    def processorOrigin(self, fromwhere):
        """Sets the CASA processor origin which is shown at the end of each log origin
        """
        schema = {'fromwhere': {'type': 'cStr'}}
        doc = {'fromwhere': fromwhere}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _processorOrigin_result = self._swigobj.processorOrigin(_str_ec(_pc.document['fromwhere']))
        return _processorOrigin_result

    def filter(self, level='DEBUG2'):
        """Set the filter level of logging messages to be displayed.
        This will determine what log messages go into the log file. The logger itself
        can adjust what gets displayed so you could set INFO5 and then filter in the
        logger everything above INFO1.
        """
        schema = {'level': {'type': 'cStr'}}
        doc = {'level': level}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _filter_result = self._swigobj.filter(_str_ec(_pc.document['level']))
        return _filter_result

    def filterMsg(self, msgList=[  ]):
        """Add messages to the filter out list
        """
        schema = {'msgList': {'type': 'cStrVec', 'coerce': [_coerce.to_list,_coerce.to_strvec]}}
        doc = {'msgList': msgList}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _filterMsg_result = self._swigobj.filterMsg([_str_ec(_x) for _x in _pc.document['msgList']])
        return _filterMsg_result

    def clearFilterMsgList(self):
        """Clear list of messages to be filter out
        """
        _clearFilterMsgList_result = self._swigobj.clearFilterMsgList()
        return _clearFilterMsgList_result

    def post(self, message, priority='INFO', origin=''):
        """If the message passes the filter, write it (same as postLocally)
        """
        schema = {'message': {'type': 'cStr'}, 'priority': {'type': 'cStr'}, 'origin': {'type': 'cStr'}}
        doc = {'message': message, 'priority': priority, 'origin': origin}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _post_result = self._swigobj.post(_str_ec(_pc.document['message']), _str_ec(_pc.document['priority']), _str_ec(_pc.document['origin']))
        return _post_result

    def postLocally(self, message, priority='INFO', origin=''):
        """If the message passes the filter, write it
        """
        schema = {'message': {'type': 'cStr'}, 'priority': {'type': 'cStr'}, 'origin': {'type': 'cStr'}}
        doc = {'message': message, 'priority': priority, 'origin': origin}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _postLocally_result = self._swigobj.postLocally(_str_ec(_pc.document['message']), _str_ec(_pc.document['priority']), _str_ec(_pc.document['origin']))
        return _postLocally_result

    def localId(self):
        """Returns the id for this class
        """
        _localId_result = _str_dc(self._swigobj.localId())
        return _localId_result

    def version(self):
        """Returns the version of CASA as well as sending it to the log
        """
        _version_result = _str_dc(self._swigobj.version())
        return _version_result

    def id(self):
        """Returns the ID of the LogSink in use
        """
        _id_result = _str_dc(self._swigobj.id())
        return _id_result

    def setglobal(self, isglobal=True):
        """
        """
        schema = {'isglobal': {'type': 'cBool'}}
        doc = {'isglobal': isglobal}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _setglobal_result = self._swigobj.setglobal(_pc.document['isglobal'])
        return _setglobal_result

    def setlogfile(self, filename='casapy.log'):
        """
        """
        schema = {'filename': {'type': 'cStr'}}
        doc = {'filename': filename}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _setlogfile_result = self._swigobj.setlogfile(_str_ec(_pc.document['filename']))
        return _setlogfile_result

    def showconsole(self, onconsole=False):
        """
        """
        schema = {'onconsole': {'type': 'cBool'}}
        doc = {'onconsole': onconsole}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _showconsole_result = self._swigobj.showconsole(_pc.document['onconsole'])
        return _showconsole_result

    def logfile(self):
        """Returns the full path of the log file
        """
        _logfile_result = _str_dc(self._swigobj.logfile())
        return _logfile_result

    def ompNumThreadsTest(self):
        """
        """
        _ompNumThreadsTest_result = self._swigobj.ompNumThreadsTest()
        return _ompNumThreadsTest_result

    def ompGetNumThreads(self):
        """
        """
        _ompGetNumThreads_result = self._swigobj.ompGetNumThreads()
        return _ompGetNumThreads_result

    def ompSetNumThreads(self, numThreads=int(1)):
        """
        """
        schema = {'numThreads': {'type': 'cInt'}}
        doc = {'numThreads': numThreads}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _ompSetNumThreads_result = self._swigobj.ompSetNumThreads(_pc.document['numThreads'])
        return _ompSetNumThreads_result

    def setMemoryTotal(self, memory=int(0)):
        """
        """
        schema = {'memory': {'type': 'cInt'}}
        doc = {'memory': memory}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _setMemoryTotal_result = self._swigobj.setMemoryTotal(_pc.document['memory'])
        return _setMemoryTotal_result

    def setMemoryFraction(self, memfrac=int(0)):
        """
        """
        schema = {'memfrac': {'type': 'cInt'}}
        doc = {'memfrac': memfrac}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _setMemoryFraction_result = self._swigobj.setMemoryFraction(_pc.document['memfrac'])
        return _setMemoryFraction_result

    def setNumCPUs(self, cores=int(0)):
        """
        """
        schema = {'cores': {'type': 'cInt'}}
        doc = {'cores': cores}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _setNumCPUs_result = self._swigobj.setNumCPUs(_pc.document['cores'])
        return _setNumCPUs_result

    def getMemoryTotal(self, use_aipsrc=True):
        """
        """
        schema = {'use_aipsrc': {'type': 'cBool'}}
        doc = {'use_aipsrc': use_aipsrc}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _getMemoryTotal_result = self._swigobj.getMemoryTotal(_pc.document['use_aipsrc'])
        return _getMemoryTotal_result

    def getNumCPUs(self, use_aipsrc=True):
        """
        """
        schema = {'use_aipsrc': {'type': 'cBool'}}
        doc = {'use_aipsrc': use_aipsrc}
        assert _pc.validate(doc,schema), str(_pc.errors)
        _getNumCPUs_result = self._swigobj.getNumCPUs(_pc.document['use_aipsrc'])
        return _getNumCPUs_result

