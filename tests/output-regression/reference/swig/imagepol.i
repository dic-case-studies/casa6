/******************** generated by xml-casa (v2) from imagepol.xml ******************
********************* a58d80f4dcac7048525d448c6bb6f548 *****************************/
%module imagepol
%include <casa_typemaps.i>
%feature("kwargs");
%feature("autodoc", "0");

%feature("docstring", "

Summary:
    Attach the Imagepol tool to a test image file

Description:



This function can be used to generate a test image and then
attach the Imagepol tool to it.

The test image is 4-dimensional (RA, DEC, Stokes and Frequency).  The
Stokes axis holds I,Q,U and V.  The source is just a constant I (if you
don't add noise all spatial pixels will be identical) and V.  Q and U
vary with frequency according to the specified Rotation Measure
components (no attempt to handle bandwidth smearing within channels is
made).  The actual values of I,Q,U, and V are chosen arbitrarily
otherwise (could be added as arguments if desired).

You can use this image, in particular, to explore the Rotation Measure
algorithms in functions rotationmeasure and
fourierrotationmeasure.

If you don't specify the Rotation Measure, then it is chosen for you so
that there is no position angle ambiguity between adjacent channels
(the value will be sent to the Logger).

The noise added to the image is specified as a fraction of the total
intensity (constant).  Gaussian noise with a standard deviation of
{stfaf sigma * $I_{max}$} is then added to the image.

Input Parameters:
    outfile                   Output image file name
    rm                        Rotation Measure (rad/m/m).  Default is auto no-ambiguity determine.
    pa0                       Position angle (degrees) at zero wavelength
    sigma                     Fractional noise level
    nx                        Shape of image in x direction
    ny                        Shape of image in y direction
    nf                        Shape of image in frequency direction
    f0                        Reference frequency (Hz)
    bw                        Bandwidth (Hz)

Example:


#
print 't----t imagepoltestimage Ex 1 t----'
po.imagepoltestimage(outfile='imagepoltestimage', rm=200)
po.rotationmeasure(rm='rm.out',rmmax=250)
ia.open('rm.out')
ia.statistics()
#viewer()
#


--------------------------------------------------------------------------------
") imagepoltestimage;

%feature("docstring", "

Summary:
    Complex linear polarization

Description:



This function  produces
the complex linear polarization; $Q+iU$ and writes
it to a disk image file.

The Image tool cannot yet handle Complex
images.  You must therefore write the Complex image to disk.  The
Viewer can display Complex images. Also the
Table tool can access Complex images.

Input Parameters:
    outfile                   Output image file name

Example:


#
print 't----t complexlinpol Ex 1 t----'
po.open('stokes.image')
po.complexlinpol('cplx')
tb.open('cplx')
#tb.browse()
#


--------------------------------------------------------------------------------
") complexlinpol;

%feature("docstring", "

Summary:
    Complex fractional linear polarization

Description:



This function produces
the complex fractional linear polarization; $(Q+iU)/I$ and writes
it to a disk image file.

The Image tool cannot yet handle Complex
images.  You must therefore write the Complex image to disk.  The
Viewer can display Complex images. Also the
Table tool can access Complex images.

Input Parameters:
    outfile                   Output image file name

Example:


#
print 't----t complexfraclinpol Ex 1 t----'
po.open('stokes.image')
po.complexfraclinpol('cplx2')
tb.open('cplx2')
#tb.browse()
#


--------------------------------------------------------------------------------
") complexfraclinpol;

%feature("docstring", "

Summary:
    Linear depolarization ratio

Description:



This function  returns the linear
depolarization ratio computed from two frequencies; this is the ratio of
the fractional linear polarization at the two frequencies.  Generally
this is done when you have generated two images, each at a different frequency
(continuum work). Thus if the fractional linear polarization images are
$m_{nu 1}$ and $m_{nu 2}$ then the depolarization ratio is
$m_{nu 1}/ m_{nu 2}$.

This function operates with two images; the first (at frequency $nu 1$)
is the one attached to your Imagepol tool.  The second (at
frequency $nu 2$) is supplied via the argument {stfaf infile}, which
is  a String holding the name of the
imagefile.

In generating the depolarization ratio, you may optionally debias the
linearly polarized intensity.  This requires the standard deviation of
the thermal noise.  You can either supply it if you know it, or it will
be worked out for you with outliers from the mean clipped at the
specified level.

You can get the depolarization ratio error image with function
sigmadepolratio.

Input Parameters:
    infile                    Other image
    debias                    Debias the linearly polarized intensity ?
    clip                      Clip level for auto-sigma determination
    sigma                     Standard deviation of thermal noise.  Default is auto determined.
    outfile                   Output image file name.  Default is unset.

Example:


#
#print 't----t depolratio Ex 1 t----'
#po.open('stokes.4800')
#dpr = po.depolratio(infile='stokes.8300')        # m_4800 / m_8300
#edpr = po.sigmadepolratio(infile='stokes.8300');
#dpr.done()
#edpr.done()
#


--------------------------------------------------------------------------------
") depolratio;

%feature("docstring", "

Summary:
    Close the image tool

Description:



This function closes the imagepol tool.  This means that it detaches
the tool from its imagefile (flushing all the changes first).  The
imagepol tool is ``null'' after this change (it is not destroyed) and
calling any toolfunction other than open will result in an
error.

Example:


#
print 't----t close Ex 1 t----'
# First create image and attach it to imagepol tool
po.imagepoltestimage('myimagepol')
po.close()              # Detaches image from Imagepol tool
print '!!!EXPECT ERROR HERE!!!'
po.summary()            # No image so this results in an error.
po.open('myimagepol')   # Image is reattached
po.summary()            # No error
po.close()
#


--------------------------------------------------------------------------------
") close;

%feature("docstring", "

Summary:
    Close this Imagepol tool

Description:





This function is the same as close().

Example:


#
print 't----t done Ex 1 t----'
po.open('myimagepol')
po.done()             # Detaches image from Imagepol tool
print '!!!EXPECT ERROR HERE!!!'
po.summary()          # No image so this results in an error.
po.open('myimagepol') # Image is reattached
po.summary()          # No error
po.done()
#


--------------------------------------------------------------------------------
") done;

%feature("docstring", "

Summary:
    Find Rotation Measure (Fourier approach)

Description:



This function  will only work if
you attach the Imagepol tool (using open) to an image containing
Stokes Q and U, and a regular frequency axis.  It Fourier transforms
the complex linear polarization (Q+iU) over the spectral axis to the
rotation measure axis.  Thus, if your input image contained
RA/DEC/Stokes/Frequency, the output image would be
RA/DEC/RotationMeasure.  The Rotation Measure axis has as many pixels
as the spectral axis.

This method enables you to see the polarization as a function of
Rotation Meausure.  Its main use is when searching for large RMs.  See
Killeen, Fluke, Zhao and Ekers (1999, preprint) for a description of
this method (or http://www.atnf.csiro.au/verb+~+nkilleen/rm.ps) and its
advantages over the traditional method
(rotationmeasure) of
extracting the Rotation Measure.

Although you can write out the complex polarization image with the
argument {stfaf complex}, you can't do much with it because Image
tools cannot handle complex images.  Hence you can
also write out the complex linear polarization image in any or all of
the other forms.

The argument {stfaf zerolag0} allows you to force the zero lag (or
central bin) of the Rotation Measure spectrum to zero (effectively by
subtracting the mean of Q and U from the Q and U images).  This may
avoid Gibbs phenomena from any strong low Rotation Measure signal which
would normally fall into the central bin.

Input Parameters:
    complex                   Output complex linear polarization image file name.  Default is unset.
    amp                       Output linear polarization amplitude image file name  Default is unset.
    pa                        Output linear polarization position angle (degrees) image file name  Default is unset.
    real                      Output linear polarization real image file name  Default is unset.
    imag                      Output linear polarization imaginary angle image file name  Default is unset.
    zerolag0                  Force zero lag to 0 ?

Example:


#
print 't----t fourierrotationmeasure Ex 1 t----'
po.imagepoltestimage(outfile='iquv.im', rm=[5.0e5,1e6], nx=8, ny=8, nf=512,
f0=1.4e9, bw=8e6)
po.fourierrotationmeasure(amp='amp')
ia.open('amp')
ia.statistics()
#viewer()                     # And reorder to put RM along X-axis
#


--------------------------------------------------------------------------------
") fourierrotationmeasure;

%feature("docstring", "

Summary:
    Fractional linear polarization

Description:

This function
returns the fractional linear polarization; $sqrt{(Q^2+U^2)}/I$.

You may optionally debias the polarized intensity.  This requires the
standard deviation of the thermal noise.  You can either supply it if
you know it, or it will be worked out for you with outliers from the
mean clipped at the specified level.

Input Parameters:
    debias                    Debias the linearly polarized intensity ?
    clip                      Clip level for auto-sigma determination
    sigma                     Standard deviation of thermal noise.  Default is auto determined.
    outfile                   Output image file name  Default is unset.

Example:


#
print 't----t fraclinpol Ex 1 t----'
po.open('stokes.image')
flp = po.fraclinpol()
flp.summary()
flp.done()
#


--------------------------------------------------------------------------------
") fraclinpol;

%feature("docstring", "

Summary:
    Fractional total polarization

Description:

This function
returns the fractional linear polarization; $sqrt{(Q^2+U^2+V^2)}/I$.

You may optionally debias the polarized intensity.  This requires the
standard deviation of the thermal noise.  You can either supply it if
you know it, or it will be worked out for you with outliers from the
mean clipped at the specified level.

If your image contains only Q and U, or only V, then just
those components contribute to the total polarized intensity.

Input Parameters:
    debias                    Debias the total polarized intensity ?
    clip                      Clip level for auto-sigma determination
    sigma                     Standard deviation of thermal noise.  Default is auto determined.
    outfile                   Output image file name.  Default is unset.

Example:


#
print 't----t fractotpol Ex 1 t----'
po.open('stokes.image')
ftp = po.fractotpol()
ftp.statistics()
ftp.done()
#


--------------------------------------------------------------------------------
") fractotpol;

%feature("docstring", "

Summary:
    Linearly polarized intensity

Description:


This application returns the linearly polarized intensity; $sqrt{(Q^2+U^2)}$.

The linearly polarized intensity may optionally be debiased (if debias=True).
This requires an estimate of the thermal noise level (sigma). The resulting
image will be computed using

$sqrt{(Q^2 + U^2 - sigma^2)}$

If the specified value of sigma is positive, that is the value that will
be used for debiasing. If it is not, the value used for sigma is computed
using the following algorithm:

1. First, a stokes plane(s) is chosen on which the sigma computation is performed.
If the V plane exists, that is used to compute sigma. If not, then the value of
sigma is computed to be the average of the sigma values of the Q and U planes.

2. For the relevant plane(s), the sigma value is computed for unmasked pixel values
which lie within +/- (clip * stddev) values of the mean for that plane, where the mean
and stddev (the standard deviation) are computed by using all unmasked pixel values
in the relevant plane. In this way, outliers (eg pixels due to possible
astronomical signals) are excluded in the computation of sigma.

In the output image, pixels for which the expression inside the square root is
negative are masked, and their values are set to zero.

If a region and/or mask is specified, debias=True and sigma is not positive so
that the value of sigma is determined using the algorithm above, the region and mask
are applied first to the plane(s) from which the value of sigma is determined and
then sigma is computed.

Input Parameters:
    debias                    Debias the linearly polarized intensity ?
    clip                      Clip level for auto-sigma determination
    sigma                     Standard deviation of thermal noise.  Default is auto determined.
    outfile                   Output image file name.  Default is unset.
    region                    Region selection. Default is to use the full image.
    mask                      Mask to use. Default setting is none.
    stretch                   Stretch the mask if necessary and possible? Default value is false.

Example:


#
print 't----t linpolint Ex 1 t----'
po.open('stokes.image')
lpi = po.linpolint()
lpi.statistics()
lpi.done()
#


--------------------------------------------------------------------------------
") linpolint;

%feature("docstring", "

Summary:
    Linearly polarized position angle

Description:



This function returns the linearly polarized position angle image 0.5*arctan(U/Q) in degrees.
The output image will not have a restoring beam, even if the input image does.

Input Parameters:
    outfile                   Output image file name.  Default is unset.
    region                    Region selection. Default is to use the full image.
    mask                      Mask to use. Default setting is none.
    stretch                   Stretch the mask if necessary and possible? Default value is false.

Example:


#
print 't----t linpolposang Ex 1 t----'
po.open('stokes.image')
lppa = po.linpolposang()
lppa.statistics()
lppa.done()
#


--------------------------------------------------------------------------------
") linpolposang;

%feature("docstring", "

Summary:
    Make a Complex image

Description:



This function generates a Complex imagefile from either
a real and imaginary, or an amplitude and phase pair of images.
If you give a linear position angle image for the phase,
it will be multipled by two before the real and imaginary
parts are formed.

Input Parameters:
    complex                   Output complex image file name.  Must be specified.
    real                      Input real image file name. Default is unset.
    imag                      Input imaginary image file name. Default is unset.
    amp                       Input amplitude image file name. Default is unset.
    phase                     Input phase image file name. Default is unset.

Example:


#
print 't----t makecomplex Ex 1 t----'
po.open('stokes.image')
po.complexlinpol('qu.cplx1')
q = po.stokesq()
u = po.stokesu()
q2 = q.subimage('q',overwrite=true)
u2 = u.subimage('u',overwrite=true)
po.makecomplex('qu.cplx2', real='q', imag='u')
po.close()
#


In this example we make two complex linear polarization
images which should be identical.

--------------------------------------------------------------------------------
") makecomplex;

%feature("docstring", "

Summary:
    Open a new image with this imagepol tool

Description:



Before polarimetric analysis can commence, an imagefile must be
attached to the imagepol tool using the open function.  Also, use this
function when you are finished analyzing the current imagefile and
want to attach to another one.  This function detaches the imagetool
from the current imagefile, if one exists, and reattaches it (opens)
to the new imagefile.

The input image file may be in native casa, fits, or Miriad
format.  Look htmlref{here}{IMAGES:FOREIGNIMAGES}  for more
information on foreign images.

The input image must have a Stokes axis. The exact collection of
Stokes that the image has, determines what the Imagepol tool can
compute. Stokes I, Q, U, and V refer to total intensity, two
components of linear polarization, and circular polatization,
respectively. Therefore, if you ask for linear polarization and the
image only has Stokes I and V, you will get an error.

The input image may contain data at many frequencies. For example, the
image may be a 4D image with axes RA, DEC, Stokes and Frequency (order
not important) where the Frequency axis is regularly sampled. However,
the image may also contain many frequencies at irregular
intervals. Such an image may be created with the Image tool function
imageconcat. It enables you to concatenate images along an axis, and
it allows irregular coordinate values along that axis.

Input Parameters:
    image                     image file name or image record (generated by ia.torecord()) 

Example:


#
print 't----t open Ex 1 t----'
po.open('stokes.image')
po.close()
#


The {stff open} function first closes the old imagefile if one exists.

--------------------------------------------------------------------------------
") open;

%feature("docstring", "

Summary:
    Polarized quantities

Description:



This function just packages the other specific polarization
functions into one where you specify an operation with the
argument {stfaf which} (can be useful for scripts).
This argument can take the values:

begin{itemize}
item 'lpi' - linearly polarized intensity (function
linpolint)

item 'tpi' - total polarized intensity (function
totpolint)

item 'lppa' linearly polarized position angle (function
linpolposang)

item 'flp' - fractional linear polarization (function
fraclinpol)

item 'ftp' - fractional total polarized intensity (function
fractotpol)

end{itemize}

Input Parameters:
    which                     Specify operation. One of 'lpi', 'tpi', 'lppa', 'flp', 'ftp' (case insensitive) 
    debias                    Debias the polarized intensity ?
    clip                      Clip level for auto-sigma determination
    sigma                     Standard deviation of thermal noise.  Default is auto determined.
    outfile                   Output image file name.  Default is unset.

Example:


#
print 't----t pol Ex 1 t----'
po.open('stokes.image')
lpi = po.pol('lpi')
lpi.statistics()
lpi.done()
#


--------------------------------------------------------------------------------
") pol;

%feature("docstring", "

Summary:
    Find Rotation Measure (traditional approach)

Description:



This function generates the rotation
measure image from a collection of different frequencies.  It will only
work if the Imagepol tool is attached to an image containing
Stokes $Q$ and $U$, and a frequency axis (regular or irregular) with at
least 2 pixels.  It will work out the position angle images for you.

See also the fourierrotationmeasure
function for a new Fourier-based approach.

Rotation Measure algorithms that work robustly are not common.  The main
problem is in trying to account for the $n- pi$ ambiguity (see Leahy et
al, Astronomy & Astrophysics, 156, 234 or Killeen et al;
http://www.atnf.csiro.au/verb+~+nkilleen/rm.ps).

The algorithm that this function uses is that of Leahy et al. (see Appendix A.1).  But as in all
these algorithms, the basic process is that for each spatial pixel, a
vector of position angles (i.e.  at the different frequencies) is fit to
determine the rotation measure and the position angle at zero wavelength
(and their errors).   An image containing
the number of $n- pi$ turns that were added to the data
at each spatial pixel and for which the best fit was found can be written.
The reduced chi-squared image for the fits can also be written.

Note that no assessment of curvature (i.e. deviation
from the simple linear position angle - $lambda^2$ functional form)
is made.

Any combination of output images can be written.

The argument {stfaf sigma} gives the thermal noise in Stokes Q and U.
By default it is determined automatically using the image data.  But if it proves
to be inaccurate (maybe not many signal-free pixels), it may be specified.
This is used for calculating the error in the
position angles (propagation of Gaussian errors).

The argument {stfaf maxpaerr} specifies the maximum allowable error in
the position angle that is acceptable.  The default is an infinite
value.  From the standard propagation of errors, the error in the
linearly polarized position angle is determined from the Stokes $Q$ and
$U$ images (at each spatial pixel for each frequency).  At each spatial
pixel we do a fit to the position angle vector (i.e.  at the different
frequencies) to determine the rotation measure.  If the position angle
error for any pixel in the vector exceeds the specified value, it is
dropped from the fit.     The process generates an error for the
fit and this is used to compute the errors in the output
images.

Note that {stfaf maxpaerr} is {it not} used to specify that any pixel
for which the output position angle error exceeds this value
should be masked out.

The argument {stfaf rmfg} is used to specify a foreground RM value.  For
example, you may know the mean RM in some direction out of the Galaxy,
then including this can aid the algorithm by reducing ambiguity.

The argument {stfaf rmmax} specifies the maximum absolute RM that
should be solved for.  This quite an important parameter.  If you leave
it at the default, zero, no ambiguity handling will be
used.  So some apriori information should be supplied; this
is the basic problem with rotation measure algorithms.

Input Parameters:
    rm                        Output Rotation Measure image file name. Default is unset.
    rmerr                     Output Rotation Measure error image file name. Default is unset.
    pa0                       Output position angle (degrees) at zero wavelength image file name. Default is unset.
    pa0err                    Output position angle (degrees) at zero wavelength error image file name. Default is unset.
    nturns                    Output number of turns image file name. Default is unset.
    chisq                     Output reduced chi squared image file name. Default is unset.
    sigma                     Estimate of the thermal noise.  Default is auto estimate.
    rmfg                      Foreground Rotation Measure (rad/m/m) to subtract.
    rmmax                     Maximum rotation measure (rad/m/m) to solve for. IMPORTANT TO SPECIFY.
    maxpaerr                  Maximum input position angle error (degrees) to allow
    plotter                   Name of plotter.  Default is none.
    nx                        Number of plots in x direction
    ny                        Number of plots in y direction

Example:


#
print 't----t rotationmeasure Ex 1 t----'
#im = ia.imageconcat(outfile='stokes.image',
#                    infiles='im.f1 im.f2 im.f3 im.f4 im.f5', axis=4)
po.open('stokes.image')
ok = po.rotationmeasure(rm='rm', rmerr='rmerr', rmmax=800, maxpaerr=10)
#



Say we have 5 images, each with axes RA, DEC, Stokes, and Frequency in
that order.  We use the Image tool to concatenate these images
along the frequency axis - you have ordered them in increasing or
decreasing frequency order.  We then compute the Rotation Measure
and Rotation Measure error images with the traditional method and
write them out to disk.

--------------------------------------------------------------------------------
") rotationmeasure;

%feature("docstring", "

Summary:
    Find best guess at thermal noise

Description:



This function returns the standard deviation from V, Q&U or I in that
order of precedence.  It is attempting to give you the best estimate of
the thermal noise it can from the data.  Outliers from the mean are
clipped at the specified level.

Input Parameters:
    clip                      Clip level for auto-sigma determination

Example:


#
print 't----t sigma Ex 1 t----'
po.open('stokes.image')
sigma = po.sigma()
print 'sigma=', sigma
#


--------------------------------------------------------------------------------
") sigma;

%feature("docstring", "

Summary:
    Error in linear depolarization ratio

Description:



This function  returns the error
in the linear depolarization ratio computed from two frequencies; this
is the ratio of the fractional linear polarization at the two
frequencies.  Generally this is done when you have generated two
images, each at a different frequency (continuum work). Thus if the
fractional linear polarzation images are $m1$ and $m2$ then the
depolarization ratio is $m1/m2$.

This function operates with two images; the first is attached
to the Imagepol tool.  The second is supplied via the
argument {stfaf infile}, which is  a String
holding the name of the imagefile.

In generating the depolarization ratio, and hence its error, you may
optionally debias the  linearly polarized intensity.  This requires the
standard deviation of the thermal noise.  You can either supply it if
you know it, or it will be worked out for you with outliers from the
mean clipped at the specified level.

You can get the depolarization ratio image with function
depolratio.

Input Parameters:
    infile                    Other image.  Required input.
    debias                    Debias the linearly polarized intensity ?
    clip                      Clip level for auto-sigma determination
    sigma                     Standard deviation of thermal noise.  Default is auto determined.
    outfile                   Output image file name.  Default is unset.

Example:


#
#print 't----t sigmadepolratio Ex 1 t----'
#po.open('stokes.4800')
#dpr = po.depolratio('stokes.8300')
#edpr = po.sigmadepolratio('stokes.8300');
#dpr.done()
#edpr.done()
#


--------------------------------------------------------------------------------
") sigmadepolratio;

%feature("docstring", "

Summary:
    Error in fractional linear polarization

Description:



This function  returns the
error (standard deviation) of the fractional linear polarization.
This result comes from standard propagation of errors.  The result is
an on-the-fly Image tool as the error is signal-to-noise ratio
dependent.

This function requires the standard deviation of the thermal noise.  You
can either supply it if you know it, or it will be worked out for you
with outliers from the mean clipped at the specified level.

Input Parameters:
    clip                      Clip level for auto-sigma determination
    sigma                     Standard deviation of thermal noise.  Default is auto determined.
    outfile                   Output image file name.  Default is unset.

Example:


#
print 't----t sigmafraclinpol Ex 1 t----'
po.open('stokes.image')
sigflp = po.sigmafraclinpol()
sigflp.statistics()
sigflp.done()           # free up resources
#


--------------------------------------------------------------------------------
") sigmafraclinpol;

%feature("docstring", "

Summary:
    Error in fractional total polarization

Description:



This function  returns the
error (standard deviation) of the fractional total polarization.  This
result comes from standard propagation of errors.  The result is an
on-the-fly Image tool as the error is signal-to-noise ratio dependent.

This function requires the standard deviation of the thermal noise.  You
can either supply it if you know it, or it will be worked out for you
with outliers from the mean clipped at the specified level.

Input Parameters:
    clip                      Clip level for auto-sigma determination
    sigma                     Standard deviation of thermal noise.  Default is auto determined.
    outfile                   Output image file name.  Default is unset.

Example:


#
print 't----t sigmafractotpol Ex 1 t----'
po.open('stokes.image')
sigftp = po.sigmafractotpol()
sigftp.statistics()
sigftp.done()
#


--------------------------------------------------------------------------------
") sigmafractotpol;

%feature("docstring", "

Summary:
    Error in linearly polarized intensity

Description:



This function  returns the error (standard
deviation) of the linearly polarized intensity; $sqrt{(Q^2+U^2)}$.
This result comes from standard propagation of statistical errors.
The result is a float as the error is not signal-to-noise
ratio dependent

This function requires the standard deviation of the thermal noise.  You
can either supply it if you know it, or it will be worked out for you
with outliers from the mean clipped at the specified level.

Input Parameters:
    clip                      Clip level for auto-sigma determination
    sigma                     Standard deviation of thermal noise.  Default is auto determined.
    outfile                   Output image file name.  Default is unset.

Example:


#
print 't----t sigmalinpolint Ex 1 t----'
po.open('stokes.image')
siglpi = po.sigmalinpolint()
print 'siglpi=', siglpi
#


--------------------------------------------------------------------------------
") sigmalinpolint;

%feature("docstring", "

Summary:
    Error in linearly polarized position angle

Description:



This function  returns the
error (standard deviation) of the linearly polarized position angle
($0.5 tan^{-1}(U/Q)$$sqrt{(Q^2+U^2)}$) in degrees.  This result
comes from standard propagation of errors.  The result is an
on-the-fly Image tool as the error is signal-to-noise ratio dependent.

This function requires the standard deviation of the thermal noise.  You
can either supply it if you know it, or it will be worked out for you
with outliers from the mean clipped at the specified level.

Input Parameters:
    clip                      Clip level for auto-sigma determination
    sigma                     Standard deviation of thermal noise.  Default is auto determined.
    outfile                   Output image file name.  Default is unset.

Example:


#
print 't----t sigmalinpolposang Ex 1 t----'
po.open('stokes.image')
siglppa = po.sigmalinpolposang()
siglppa.statistics()
siglppa.done()
#


--------------------------------------------------------------------------------
") sigmalinpolposang;

%feature("docstring", "

Summary:
    Find standard deviation of specified Stokes data

Description:



This function  returns the standard
deviation of the noise for the specified Stokes.  Outliers from the mean
are clipped at the specified level.

Input Parameters:
    which                     Must specify Stokes parameter. One of 'I', 'Q', 'U', 'V' (case insensitive) 
    clip                      Clip level for auto-sigma determination

Example:


#
print 't----t sigmastokes Ex 1 t----'
po.open('stokes.image')
sigq = po.sigmastokes('q', 10.0)
print 'sigq=', sigq
#


--------------------------------------------------------------------------------
") sigmastokes;

%feature("docstring", "

Summary:
    Find standard deviation of Stokes I data

Description:



This function  returns the standard deviation of the noise for the
Stokes I data.  Outliers from the mean are clipped at the specified
level.

Input Parameters:
    clip                      Clip level for auto-sigma determination

Example:


#
print 't----t sigmastokesi Ex 1 t----'
po.open('stokes.image')
sigi = po.sigmastokesi(10.0)
print 'sigi=', sigi
#


--------------------------------------------------------------------------------
") sigmastokesi;

%feature("docstring", "

Summary:
    Find standard deviation of Stokes Q data

Description:



This function  returns the standard deviation of the noise for the
Stokes Q data.  Outliers from the mean are clipped at the specified
level.

Input Parameters:
    clip                      Clip level for auto-sigma determination

Example:


#
print 't----t sigmastokesq Ex 1 t----'
po.open('stokes.image')
sigq = po.sigmastokesq(10.0)
print 'sigq=', sigq
#


--------------------------------------------------------------------------------
") sigmastokesq;

%feature("docstring", "

Summary:
    Find standard deviation of Stokes U data

Description:



This function  returns the standard
deviation of the noise for the Stokes U data.  Outliers from the mean
are clipped at the specified level.

Input Parameters:
    clip                      Clip level for auto-sigma determination

Example:


#
print 't----t sigmastokesu Ex 1 t----'
po.open('stokes.image')
sigu = po.sigmastokesu(10.0)
print 'sigu=', sigu
#


--------------------------------------------------------------------------------
") sigmastokesu;

%feature("docstring", "

Summary:
    Find standard deviation of Stokes V data

Description:



This function  returns the standard
deviation of the noise for the Stokes V data.  Outliers from the mean
are clipped at the specified level.

Input Parameters:
    clip                      Clip level for auto-sigma determination

Example:


#
print 't----t sigmastokesv Ex 1 t----'
po.open('stokes.image')
sigv = po.sigmastokesv(10.0)
print 'sigv=', sigv
#


--------------------------------------------------------------------------------
") sigmastokesv;

%feature("docstring", "

Summary:
    Error in total polarized intensity

Description:



This function  returns the error (standard
deviation) of the total polarized intensity; $sqrt{(Q^2+U^2+V^2)}$.
This result comes from standard propagation of statistical errors.
The result is a float as the error is not signal-to-noise
ratio dependent

This function requires the standard deviation of the thermal noise.  You
can either supply it if you know it, or it will be worked out for you
with outliers from the mean clipped at the specified level.

Input Parameters:
    clip                      Clip level for auto-sigma determination
    sigma                     Standard deviation of thermal noise.  Default is auto determined.

Example:


#
print 't----t sigmastotpolint Ex 1 t----'
po.open('stokes.image')
sigtpi = po.sigmatotpolint()
print 'sigtpi=', sigtpi
#


--------------------------------------------------------------------------------
") sigmatotpolint;

%feature("docstring", "

Summary:
    Stokes

Description:



This function returns an on-the-fly image tool containing the
specified Stokes only.  This interface can be useful for scripts.

Input Parameters:
    which                     Must specify Stokes. One of 'I', 'Q', 'U', 'V' (case insensitive) 
    outfile                   Output image file name.  Default is unset.

Example:


#
print 't----t stokes Ex 1 t----'
po.open('stokes.image')
q = po.stokes('q')
q.statistics()
q.done()
#


--------------------------------------------------------------------------------
") stokes;

%feature("docstring", "

Summary:
    Stokes I

Description:


This function returns an on-the-fly image tool containing Stokes I only.

Input Parameters:
    outfile                   Output image file name.  Default is unset.

Example:


#
print 't----t stokesi Ex 1 t----'
po.open('stokes.image')
i = po.stokesi()
i.statistics()
i.done()
#


--------------------------------------------------------------------------------
") stokesi;

%feature("docstring", "

Summary:
    Stokes Q

Description:


This function returns an on-the-fly image tool containing Stokes Q only.

Input Parameters:
    outfile                   Output image file name.  Default is unset.

Example:


#
print 't----t stokesq Ex 1 t----'
po.open('stokes.image')
q = po.stokesq()
q.statistics()
q.done()
#


--------------------------------------------------------------------------------
") stokesq;

%feature("docstring", "

Summary:
    Stokes U

Description:


This function returns an on-the-fly image tool containing Stokes U only.

Input Parameters:
    outfile                   Output image file name.  Default is unset.

Example:


#
print 't----t stokesu Ex 1 t----'
po.open('stokes.image')
u = po.stokesu()
u.statistics()
u.done()
#


--------------------------------------------------------------------------------
") stokesu;

%feature("docstring", "

Summary:
    Stokes V

Description:


This function returns an on-the-fly image tool containing Stokes V only.

Input Parameters:
    outfile                   Output image file name.  Default is unset.

Example:


#
print 't----t stokesv Ex 1 t----'
po.open('stokes.image')
v = po.stokesv()
v.statistics()
v.done()
#


--------------------------------------------------------------------------------
") stokesv;

%feature("docstring", "

Summary:
    Summarise Imagepol tool

Description:



This function just lists a summary of the Imagepol tool to the logger.
Currently it just summarizes the image to which the tool is attached.

Example:


#
print 't----t summary Ex 1 t----'
po.open('stokes.image')
po.summary()
#
#Image name       : stokes.image
#Object name      :
#Image type       : PagedImage
#Image quantity   : Intensity
#Pixel mask(s)    : None
#Region(s)        : None
#
#Direction reference : J2000
#Spectral  reference : TOPO
#Velocity  type      : RADIO
#Rest frequency      : 1.4e+09 Hz
#Telescope           : UNKNOWN
#Observer            : UNKNOWN
#Date observation    : UNKNOWN
#
#Axis Coord Type      Name             Proj Shape Tile   Coord value at pixel    Coord incr Units
#------------------------------------------------------------------------------------------------
#0    0     Direction Right Ascension   SIN    32   32  00:00:00.000    16.00 -6.000000e+01 arcsec
#1    0     Direction Declination       SIN    32   32 +00.00.00.000    16.00  6.000000e+01 arcsec
#2    1     Stokes    Stokes                    4    4       I Q U V
#3    2     Spectral  Frequency                32   32       1.4e+09    16.00  4.000000e+06 Hz
#                     Velocity                                     0    16.00 -8.565499e+02 km/s
#
#


--------------------------------------------------------------------------------
") summary;

%feature("docstring", "

Summary:
    Total polarized intensity

Description:


This application returns the total polarized intensity;

$sqrt{( Q^2+ U^2+ V^2)}$.

If the image contains only Q and U, or only V, then just
those components contribute to the total polarized intensity.

The polarized intensity may optionally be debiased (if debias=True).
This requires an estimate of the thermal noise level (sigma).
The resulting image will be computed using

$sqrt{(Q^2 + U^2 + V^2 - sigma^2)}$

If the specified value of sigma is positive, that is the value that will
be used for debiasing. If it is not, the value used for sigma is computed
using the following algorithm:

1. First, a stokes plane(s) is chosen on which the sigma computation is performed.
If the V plane exists, that is used to compute sigma. If not, then the value of
sigma is computed to be the average of the sigma values of the Q and U planes.

2. For the relevant plane(s), the sigma value is computed for unmasked pixel values
which lie within +/- (clip * stddev) values of the mean for that plane, where the mean
and stddev (the standard deviation) are computed by using all unmasked pixel values
in the relevant plane. In this way, outliers (eg pixels due to possible
astronomical signals) are excluded in the computation of sigma.

In the output image, pixels for which the expression inside the square root is
negative are masked, and their values are set to zero.

If a region and/or mask is specified, debias=True and sigma is not positive so
that the value of sigma is determined using the algorithm above, the region and mask
are applied first to the plane(s) from which the value of sigma is determined and
then sigma is computed.

Input Parameters:
    debias                    Debias the total polarized intensity ?
    clip                      Clip level for auto-sigma determination
    sigma                     Standard deviation of thermal noised.  Default is auto determined.
    outfile                   Output image file name.  Default is unset.
    region                    Region selection. Default is to use the full image.
    mask                      Mask to use. Default setting is none.
    stretch                   Stretch the mask if necessary and possible? Default value is false.

Example:


#
print 't----t totpolint Ex 1 t----'
po.open('stokes.image')
tpi = po.totpolint()
tpi.statistics()
tpi.done()
#


--------------------------------------------------------------------------------
") totpolint;

%exception {
   try {
      $action
      } catch (const casacore::AipsError &ae) {
         PyErr_SetString(PyExc_RuntimeError, ae.what());
	 //PyErr_Print();
         return NULL;
      }
}
%include "imagepol_cmpt.h"

%{
#include <exception>
#include <imagepol_cmpt.h>
%}

