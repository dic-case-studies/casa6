<casaxml xsi:schemaLocation="http://casa.nrao.edu/schema/casa.xsd file:///opt/casa/code/xmlcasa/xml/casa.xsd" xmlns="http://casa.nrao.edu/schema/psetTypes.html" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">


<task type="function" name="deconvolve" category="imaging">

  <shortdescription>Image-domain deconvolution</shortdescription>

  <description>Task deconvolve executes image-domain deconvolution with options for automasking and restoration. It can be viewed as the minor cycle of the iterative image reconstruction offered by the tclean task. The functionality that it introduces is the ability to just run the deconvolution step alone.
  </description>

  <input>

    <param type="any" name="imagename" required="true">
      <shortdescription>Pre-name of input and output images</shortdescription>
      <description>Pre-name of input and output images
                        example : imagename='try'
                        
                        Input images (* = required):
                        
                        try.psf*        - The point spread function
                        try.residual*   - The observed (or residual) image, such as one
                                          generated by tclean
                        try.model       - An existing model image from a previous run of
                                          tclean or deconvolve
                        try.mask        - A pre-defined mask to be either used directly or 
                                          combined with additional masking options
                        try.pb          - Primary beam model, if required for masking settings
                        
                        Output images:
                        
                        try.model       - A new or updated model image
                        try.residual    - An updated residual image
                        try.image       - A restored image, created only when restoration=True
                        try.mask        - The output mask
                        try.prev.mask   - An intermediate by-product of automasking
                                          (when usemask='auto-multithresh')
                        
                        For multi-term wideband imaging, all relevant images above will
                        have additional .tt0,.tt1, etc suffixes to indicate Taylor terms,
                        plus the following extra input images.
                        try.alpha       - spectral index
                        try.alpha.error - estimate of error on spectral index
                        try.beta        - spectral curvature (if nterms &gt; 2)
                        
                        Tip :  Include a directory name in 'imagename' for all
                               output images to be sent there instead of the
                               current working directory : imagename='mydir/try'
                        
                        Tip :  Restarting a deconvolution run without changing 'imagename'
                               implies continuation from the existing model image on disk.
                               By default, the residual image will be recomputed.
                        
                        Note : All deconvolution runs will by default produce restored images.
                               For a niter=0 run, this will be redundant and can optionally
                               be turned off via the 'restoration=T/F' parameter.
                               
                        Note : All input/output images should be 4D image cubes with axes
                               [ra,dec,chan,pol], as is the default for the task tclean. Any input
                               images without this format must be modified (eg with imregrid,
                               imtrans, image.adddegaxes) in order to be accepted.

      </description>
      <type>int</type><type>string</type><type>stringVec</type>
      <value type="string"/>
    </param>

    <param name="startmodel" type="any"> 
      <shortdescription>Name of starting model image</shortdescription>
      <description>Name of starting model image

                        The contents of the supplied starting model image will be
                        copied to the imagename.model before the run begins.

                        example : startmodel = 'singledish.im'

                        For deconvolver='mtmfs', one image per Taylor term must be provided.
                        example : startmodel = ['try.model.tt0', 'try.model.tt1']
                                  startmodel = ['try.model.tt0']  will use a starting model only
                                                       for the zeroth order term.
                                  startmodel = ['','try.model.tt1']  will use a starting model only
                                                       for the first order term.

                        This starting model can be of a different image shape and size from
                        what is currently being imaged. If so, an image regrid is first triggered
                        to resample the input image onto the target coordinate system.
                        
                        If the startmodel is supplied, but a copy of of the destination
                        imagename.model already exists, deconvolve will exit with an error.

                        A common usage is to set this parameter equal to a single dish image

                        Negative components in the model image will be included as is.

      </description>
      <value type="string"/>
    </param>

    <param type="string" name="deconvolver">
      <shortdescription>Minor cycle algorithm (hogbom,clark,multiscale,mtmfs,mem,clarkstokes)</shortdescription>
      <description>Name of minor cycle algorithm (hogbom,clark,multiscale,mtmfs,mem,clarkstokes)

                        Each of the following algorithms operate on residual images and psfs
                        from the gridder and produce output model and restored images.
                        Minor cycles stop when cyclethreshold or niter are reached. For all
                        methods, components are picked from the entire extent of the image or
                        (if specified) within a mask.

                        hogbom : An adapted version of Hogbom Clean [Hogbom, 1974]
                                - Find the location of the peak residual
                                - Add this delta function component to the model image
                                - Subtract a scaled and shifted PSF of the same size as the image
                                  from regions of the residual image where the two overlap.
                                - Repeat

                        clark : An adapted version of Clark Clean [Clark, 1980]
                                - Find the location of max(I^2+Q^2+U^2+V^2)
                                - Add delta functions to each stokes plane of the model image
                                - Subtract a scaled and shifted PSF within a small patch size
                                  from regions of the residual image where the two overlap.
                                - After several iterations trigger a Clark major cycle to subtract
                                  components from the visibility domain, but without de-gridding.
                                - Repeat

                                ( Note : 'clark' maps to imagermode='' in the old clean task.
                                         'clark_exp' is another implementation that maps to
                                          imagermode='mosaic' or 'csclean' in the old clean task
                                          but the behavior is not identical. For now, please
                                          use deconvolver='hogbom' if you encounter problems. )

                        clarkstokes : Clark Clean operating separately per Stokes plane

                                (Note : 'clarkstokes_exp' is an alternate version. See above.)

                        multiscale : MultiScale Clean [Cornwell, 2008]
                                - Smooth the residual image to multiple scale sizes
                                - Find the location and scale at which the peak occurs
                                - Add this multiscale component to the model image
                                - Subtract a scaled,smoothed,shifted PSF (within a small
                                  patch size per scale) from all residual images
                                - Repeat from step 2

                        mtmfs : Multi-term (Multi Scale) Multi-Frequency Synthesis [Rau and Cornwell, 2011]
                                - Smooth each Taylor residual image to multiple scale sizes
                                - Solve a NTxNT system of equations per scale size to compute
                                  Taylor coefficients for components at all locations
                                - Compute gradient chi-square and pick the Taylor coefficients
                                  and scale size at the location with maximum reduction in
                                  chi-square
                                - Add multi-scale components to each Taylor-coefficient
                                  model image
                                - Subtract scaled,smoothed,shifted PSF (within a small patch size
                                  per scale) from all smoothed Taylor residual images
                                - Repeat from step 2


                        mem : Maximum Entropy Method [Cornwell and Evans, 1985]
                                - Iteratively solve for values at all individual pixels via the
                                  MEM method. It minimizes an objective function of
                                  chi-square plus entropy (here, a measure of difference
                                  between the current model and a flat prior model).

                                (Note : This MEM implementation is not very robust.
                                             Improvements will be made in the future.)



      </description>
      <value type="string">hogbom</value>
      <allowed kind="enum">
        <value>hogbom</value>
        <value>clark</value>
        <value>clarkstokes</value>
        <value>clark_exp</value>
        <value>clarkstokes_exp</value>
        <value>multiscale</value>
        <value>mtmfs</value>
        <value>mem</value>

      </allowed>
    </param>

    <param type="any" name="scales" subparam="true">
      <shortdescription>List of scale sizes (in pixels) for multi-scale algorithms</shortdescription>
      <description>List of scale sizes (in pixels) for multi-scale and mtmfs algorithms.
                        --&gt;  scales=[0,6,20]
                        This set of scale sizes should represent the sizes
                        (diameters in units of number of pixels)
                        of dominant features in the image being reconstructed.

                        The smallest scale size is recommended to be 0 (point source),
                        the second the size of the synthesized beam and the third 3-5
                        times the synthesized beam, etc. For example, if the synthesized
                        beam is 10&quot; FWHM and cell=2&quot;,try scales = [0,5,15].

                        For numerical stability, the largest scale must be
                        smaller than the image (or mask) size and smaller than or
                        comparable to the scale corresponding to the lowest measured
                        spatial frequency (as a scale size much larger than what the
                        instrument is sensitive to is unconstrained by the data making
                        it harder to recovery from errors during the minor cycle).
      </description>
      <type>intVec</type><type>doubleVec</type>
      <value type="intVec"/>
    </param>

    <param subparam="true" name="nterms" type="int">
      <shortdescription>Number of Taylor coefficients in the spectral model</shortdescription>
      <description>Number of Taylor coefficients in the spectral model

                        - nterms=1 : Assume flat spectrum source
                        - nterms=2 : Spectrum is a straight line with a slope
                        - nterms=N : A polynomial of order N-1

                        From a Taylor expansion of the expression of a power law, the
                        spectral index is derived as alpha = taylorcoeff_1 / taylorcoeff_0

                        Spectral curvature is similarly derived when possible.

                        The optimal number of Taylor terms depends on the available
                        signal to noise ratio, bandwidth ratio, and spectral shape of the
                        source as seen by the telescope (sky spectrum x PB spectrum).

                        nterms=2 is a good starting point for wideband EVLA imaging
                        and the lower frequency bands of ALMA (when fractional bandwidth
                        is greater than 10%) and if there is at least one bright source for
                        which a dynamic range of greater than few 100 is desired.

                        Spectral artifacts for the VLA often look like spokes radiating out from
                        a bright source (i.e. in the image made with standard mfs imaging).
                        If increasing the number of terms does not eliminate these artifacts,
                        check the data for inadequate bandpass calibration. If the source is away
                        from the pointing center, consider including wide-field corrections too.

                        (Note : In addition to output Taylor coefficient images .tt0,.tt1,etc
                                images of spectral index (.alpha), an estimate of error on
                                spectral index (.alpha.error) and spectral curvature (.beta,
                                if nterms is greater than 2) are produced.
                                - These alpha, alpha.error and beta images contain
                                  internal T/F masks based on a threshold computed
                                  as peakresidual/10. Additional masking based on
                                  .alpha/.alpha.error may be desirable.
                                - .alpha.error is a purely empirical estimate derived
                                  from the propagation of error during the division of
                                  two noisy numbers (alpha = xx.tt1/xx.tt0) where the
                                  'error' on tt1 and tt0 are simply the values picked from
                                  the corresponding residual images. The absolute value
                                  of the error is not always accurate and it is best to interpret
                                  the errors across the image only in a relative sense.)


      </description>
      <value type="int">2</value>
    </param>

    <param type="double" name="smallscalebias" subparam="true">
      <shortdescription>Biases the scale selection when using multi-scale or mtmfs deconvolvers </shortdescription>
      <description>A numerical control to bias the scales when using multi-scale or mtmfs algorithms.
                        The peak from each scale's smoothed residual is
                        multiplied by ( 1 - smallscalebias * scale/maxscale )
                        to increase or decrease the amplitude relative to other scales,
                        before the scale with the largest peak is chosen. 
                        Smallscalebias can be varied between -1.0 and 1.0. 
                        A score of 0.0 gives all scales equal weight (default). 
                        A score larger than 0.0 will bias the solution towards smaller scales. 
                        A score smaller than 0.0 will bias the solution towards larger scales.
                        The effect of smallscalebias is more pronounced when using multi-scale relative to mtmfs. 
      </description>
      <value type="double">0.0</value>
    </param>


    <param type="bool" name="restoration">
      <shortdescription>Do restoration steps (or not)</shortdescription>
      <description> Restore the model image.

                        Construct a restored image : imagename.image by convolving the model
                        image with a clean beam and adding the residual image to the result.
                        If a restoringbeam is specified, the residual image is also
                        smoothed to that target resolution before adding it in.

                        If a .model does not exist, it will make an empty one and create
                        the restored image from the residuals ( with additional smoothing if needed ).
                        With algorithm='mtmfs', this will construct Taylor coefficient maps from
                        the residuals and compute .alpha and .alpha.error.

      </description>
      <value type="bool">True</value>
    </param>


    <param type="any" name="restoringbeam" subparam="true">
      <shortdescription>Restoring beam shape to use. Default is the PSF main lobe</shortdescription>
      <description> Restoring beam shape/size to use.

                        - restoringbeam='' or ['']
                          A Gaussian fitted to the PSF main lobe (separately per image plane).

                        - restoringbeam='10.0arcsec'
                          Use a circular Gaussian of this width for all planes

                        - restoringbeam=['8.0arcsec','10.0arcsec','45deg']
                          Use this elliptical Gaussian for all planes

                        - restoringbeam='common'
                          Automatically estimate a common beam shape/size appropriate for
                          all planes.

                        Note : For any restoring beam different from the native resolution
                               the model image is convolved with the beam and added to
                               residuals that have been convolved to the same target resolution.

      </description>
      <type>string</type><type>stringVec</type>
      <value type="stringVec"/>
    </param>

    <param type="int" name="niter">
      <shortdescription>Maximum number of iterations</shortdescription>
      <description>Maximum number of iterations

                        A stopping criterion based on total iteration count.
                        Currently the parameter type is defined as an integer therefore the integer value 
                        larger than 2147483647 will not be set properly as it causes an overflow.

                        Iterations are typically defined as the selecting one flux component
                        and partially subtracting it out from the residual image.

                        niter=0 : Skip the deconvolution step (only do restoration)

                        niter larger than zero : The minor cycle.

                        Note :  Global stopping criteria vs minor-cycle interrupt triggers

                                In addition to global stopping criteria, the following rules are
                                used to determine when to terminate a set of minor cycle iterations
                                and return [derived from Cotton-Schwab Clean, 1984]
                                
                                'cyclethreshold' : Automatically computed threshold related to the
                                                   max sidelobe level of the PSF and peak residual.
                                Divergence, detected as an increase of 10% in peak residual from the
                                minimum so far (during minor cycle iterations)
                                
                                The first criterion to be satisfied takes precedence.

                        Note :  Iteration counts for cubes or multi-field images :
                                For images with multiple planes (or image fields) on which the
                                deconvolver operates in sequence, iterations are counted across
                                all planes (or image fields). The iteration count is compared with
                                'niter' only after all channels/planes/fields have completed their
                                minor cycles and exited either due to 'niter' or 'cyclethreshold'.
                                Therefore, the actual number of iterations reported in the logger
                                can sometimes be larger than the user specified value in 'niter'.
                                For example, with niter=100, nchan=10,threshold=0,
                                a total of 1000 iterations will be done in the first set of minor cycles
                                before the total is compared with niter=100 and it exits.

      </description>
      <value type="int">100</value>
    </param>

    <param type="double" name="gain" subparam="true">
      <shortdescription>Loop gain</shortdescription>
      <description>Loop gain

                        Fraction of the source flux to subtract out of the residual image
                        for the CLEAN algorithm and its variants.

                        A low value (0.2 or less) is recommended when the sky brightness
                        distribution is not well represented by the basis functions used by
                        the chosen deconvolution algorithm. A higher value can be tried when
                        there is a good match between the true sky brightness structure and
                        the basis function shapes.  For example, for extended emission,
                        multiscale clean with an appropriate set of scale sizes will tolerate
                        a higher loop gain than Clark clean (for example).

                       

      </description>
      <value type="double">0.1</value>
    </param>

    <param type="any" name="cyclethreshold" subparam="true">
        <shortdescription>Stopping threshold </shortdescription>
        <description>Stopping threshold (number in units of Jy, or string)
          
                        A global stopping threshold that the peak residual (within clean mask)
                        across all image planes is compared to. If set, then this value will be used
                        to compare against. If left at the default (0.0), then a new value will be
                        computed using the other stopping criteria parameters (see threshold) and
                        used in place of cyclethreshold.

                        The 'cyclethreshold' value is also made visible and editable in the
                        interactive GUI when deconvolve is run with interactive=True.
        </description>

        <value type="double">0.0</value>
    </param>

    <param type="any" name="threshold" subparam="true">
      <shortdescription>Stopping threshold </shortdescription>
      <description>Tclean's stopping threshold (number in units of Jy, or string)

                        When cyclethreshold isn't set explicitly, the value of threshold is used as
                        part of the compilation to automatically determine a cyclethreshold value.
                        This is mainly for maintaing compatibility with tclean.

                        threshold = 0.005  : 5mJy
                        threshold = '5.0mJy'

                        Note : A 'cyclethreshold' is internally computed and used as a stopping
                               trigger. It is related what fraction of the PSF can be reliably
                               used during minor cycle updates of the residual image. By default
                               the minor cycle iterations terminate once the peak residual reaches
                               the first sidelobe level of the brightest source.
                               
                               'cyclethreshold' is computed as follows using the settings in
                               parameters 'cyclefactor','minpsffraction','maxpsffraction','threshold' :

                               psf_fraction = max_psf_sidelobe_level * 'cyclefactor'
                               psf_fraction = max(psf_fraction, 'minpsffraction');
                               psf_fraction = min(psf_fraction, 'maxpsffraction');
                               cyclethreshold = peak_residual * psf_fraction
                               cyclethreshold = max( cyclethreshold, 'threshold' )
                               
                               If nsigma is set (&gt;0.0), the N-sigma threshold is calculated (see
                               the description under nsigma), then cyclethreshold is further modified as,
                               
                               cyclethreshold = max( cyclethreshold, nsgima_threshold )
      </description>

      <value type="double">0.0</value>
    </param>

    <param type="double" name="nsigma" subparam="true">
      <shortdescription>Multiplicative factor for rms-based threshold stopping</shortdescription>
      <description>Multiplicative factor for rms-based threshold stopping

                        N-sigma threshold is calculated as nsigma * rms value per image plane determined
                        from a robust statistics. For nsigma &gt; 0.0, in a minor cycle, a maximum of the two values,
                        the N-sigma threshold and cyclethreshold, is used as a stopping trigger
                        (see also the descreption under 'threshold').
                        Set nsigma=0.0 to preserve the previous deconvolve behavior without this feature.
                        The top level parameter, fastnoise is relevant for the rms noise calculation which is used 
                        to determine the threshold. 

      </description>
      <value type="double">0.0</value>
    </param>

    <param type="double" name="cyclefactor" subparam="true">
      <shortdescription>Scaling on PSF sidelobe level to compute the minor-cycle stopping threshold.</shortdescription>
      <description>Scaling on PSF sidelobe level to compute the minor-cycle stopping threshold.

                        Please refer to the Note under the documentation for 'threshold' that
                        discussed the calculation of 'cyclethreshold'

                        cyclefactor=1.0 results in a cyclethreshold at the first sidelobe level of
                        the brightest source in the residual image before the minor cycle starts.

                        cyclefactor=0.5 allows the minor cycle to go deeper.
                        cyclefactor=2.0 triggers stopping the minor cycle sooner.

      </description>
      <value type="double">1.0</value>
    </param>

    <param type="double" name="minpsffraction" subparam="true">
      <shortdescription>PSF fraction that marks the max depth of cleaning in the minor cycle</shortdescription>
      <description>PSF fraction that marks the max depth of cleaning in the minor cycle

                        Please refer to the Note under the documentation for 'threshold' that
                        discussed the calculation of 'cyclethreshold'

                        For example, minpsffraction=0.5 will stop cleaning at half the height of
                        the peak residual.

      </description>
      <value type="double">0.05</value>
    </param>

    <param type="double" name="maxpsffraction" subparam="true">
      <shortdescription>PSF fraction that marks the minimum depth of cleaning in the minor cycle </shortdescription>
      <description>PSF fraction that marks the minimum depth of cleaning in the minor cycle

                        Please refer to the Note under the documentation for 'threshold' that
                        discussed the calculation of 'cyclethreshold'

                        For example, maxpsffraction=0.8 will ensure that at least the top 20
                        percent of the source will be subtracted out in the minor cycle even if
                        the first PSF sidelobe is at the 0.9 level (an extreme example), or if the
                        cyclefactor is set too high for anything to get cleaned.

      </description>
      <value type="double">0.8</value>
    </param>


    <param type="any" name="interactive">
      <shortdescription>Modify masks and parameters at runtime</shortdescription>
      <description>Modify masks and parameters at runtime

                        interactive=True will trigger an interactive GUI after deconvolution finishes.

                        The interactive mode is currently not available for parallel cube imaging (please also
                        refer to the Note under the documentation for 'parallel' below).

                        Options for runtime parameter modification are :

                        Interactive clean mask : Draw a 1/0 mask (appears as a contour) by hand.
                                                 If a mask is supplied at the task interface or if
                                                 automasking is invoked, the current mask is
                                                 displayed in the GUI and is available for manual
                                                 editing.
                                                 
                                                 Note : If a mask contour is not visible, please
                                                            check the cursor display at the bottom of
                                                            GUI to see which parts of the mask image
                                                            have ones and zeros. If the entire mask=1
                                                            no contours will be visible.


                        Operation buttons : -- For the task deconvolve, all options stop the minor cycle.

                        Iteration control : -- max cycleniter :  For task deconvolve, this contol has no effect.
                                            -- iterations left : Sets the limit on the number of iterations
                                                                 about to be done.
                                            -- threshold :       Sets the peak residual stopping threshold for
                                                                 for this execution of deconvolve. The max
                                                                 between &quot;threshold&quot; and &quot;cyclethreshold&quot; is
                                                                 used for this stopping criteria.
                                            -- cyclethreshold :  See description for &quot;-- threshold&quot;.


                        [ For scripting purposes, replacing True/False with 1/0 will get deconvolve to
                          return an imaging summary dictionary to python ]

      </description>
      <type>bool</type><type>int</type>
      <value type="bool">False</value>
    </param>
    
    <param type="bool" name="fastnoise" subparam="true">
      <shortdescription>True: use the faster (old) noise calculation. False: use the new improved noise calculations</shortdescription>
      <value type="bool">True</value>
      <description> Only relevant when automask (user='multi-autothresh') and/or n-sigma stopping threshold
                        (nsigma&gt;0.0) are/is used. If it is set to True,  a simpler but faster noise calucation is used. 
                        In this case, the threshold values are determined based on classic statistics (using all
                        unmasked pixels for the calculations).

                        If it is set to False,  the new noise calculation
                        method is used based on pre-existing mask.   

                        Case 1: no exiting mask
                        Calculate image statistics using Chauvenet algorithm 

                        Case 2: there is an existing mask
                        Calculate image statistics by classical method on the region
                        outside the mask and inside the primary beam mask.

                        In all cases above RMS noise is calculated from MAD. 
      </description>
    </param>

    <param type="string" name="usemask">
      <shortdescription>Type of mask(s) for deconvolution:  user, pb, or auto-multithresh</shortdescription>

      <description>Type of mask(s) to be used for deconvolution

                        user: (default) mask image(s) or user specified region file(s) or string CRTF expression(s)
                              subparameters: mask, pbmask
                        pb: primary beam mask
                              subparameter: pbmask
                              
                              Example: usemask=&quot;pb&quot;, pbmask=0.2
                                              Construct a mask at the 0.2 pb gain level.
                                              (Currently, this option will work only with
                                              gridders that produce .pb (i.e. mosaic and awproject)
                                              or if an externally produced .pb image exists on disk)
                            
                        auto-multithresh : auto-masking by multiple thresholds for deconvolution
                              subparameters : sidelobethreshold, noisethreshold, lownoisethreshold,
                                              negativethrehsold,  smoothfactor, minbeamfrac, cutthreshold,
                                              pbmask, growiterations, dogrowprune, minpercentchange, verbose
                              Additional top level parameter relevant to auto-multithresh: fastnoise
                              
                              if pbmask is &gt;0.0, the region outside the specified pb gain level is excluded from
                              image statistics in determination of the threshold.




                        Note: By default the intermediate mask generated by automask at each deconvolution cycle
                              is over-written in the next cycle but one can save them by setting
                              the environment variable, SAVE_ALL_AUTOMASKS=&quot;true&quot;.
                              (e.g. in the CASA prompt, os.environ['SAVE_ALL_AUTOMASKS']=&quot;true&quot; )
                              The saved CASA mask image name will be imagename.mask.autothresh#, where
                              # is the iteration cycle number.

      </description>
      <value type="string">user</value>
      <allowed kind="enum">
              <value>user</value>
              <value>pb</value>
              <value>auto-multithresh</value>
      </allowed>
    </param>

    
    <param type="any" name="mask" subparam="true">
      <shortdescription>Mask (a list of image name(s) or region file(s) or region string(s) )</shortdescription>
      <description>Mask (a list of image name(s) or region file(s) or region string(s)

    
                        The name of a CASA image or region file or region string that specifies
                        a 1/0 mask to be used for deconvolution. Only locations with value 1 will
                        be considered for the centers of flux components in the minor cycle.
                        If regions specified fall completely outside of the image, deconvolve will throw an error.

                        Manual mask options/examples :

                        mask='xxx.mask'  : Use this CASA image named xxx.mask and containing
                                           ones and zeros as the mask. 
                                           If the mask is only different in spatial coordinates from what is being made 
                                           it will be resampled to the target coordinate system before being used.
                                           The mask has to have the same shape in velocity and Stokes planes
                                           as the output image. Exceptions are single velocity and/or single
                                           Stokes plane masks. They will be expanded to cover all velocity and/or
                                           Stokes planes of the output cube.
                                           
                                           [ Note : If an error occurs during image resampling or
                                                    if the expected mask does not appear, please try
                                                    using tasks 'imregrid' or 'makemask' to resample
                                                    the mask image onto a CASA image with the target
                                                    shape and coordinates and supply it via the 'mask'
                                                    parameter. ]


                        mask='xxx.crtf' : A text file with region strings and the following on the first line
                                             ( #CRTFv0 CASA Region Text Format version 0 )
                                          This is the format of a file created via the viewer's region
                                          tool when saved in CASA region file format.

                        mask='circle[[40pix,40pix],10pix]'  : A CASA region string.

                        mask=['xxx.mask','xxx.crtf', 'circle[[40pix,40pix],10pix]']  : a list of masks





                        Note : Mask images for deconvolution must contain 1 or 0 in each pixel.
                               Such a mask is different from an internal T/F mask that can be
                               held within each CASA image. These two types of masks are not
                               automatically interchangeable, so please use the makemask task
                               to copy between them if you need to construct a 1/0 based mask
                               from a T/F one.

                        Note : Work is in progress to generate more flexible masking options and
                               enable more controls.

      </description>


      <type>string</type><type>stringVec</type>
      <value type="string"/>
    </param>


    <param type="double" name="pbmask" subparam="true">
      <shortdescription>primary beam mask</shortdescription>
      <description>Sub-parameter for usemask='auto-multithresh': primary beam mask

                        Examples : pbmask=0.0 (default, no pb mask)
                                   pbmask=0.2 (construct a mask at the 0.2 pb gain level)

      </description>
      <value type="double">0.0</value>
    </param>
    
    
    
    
    <param type="double" name="sidelobethreshold" subparam="true">
      <shortdescription>sidelobethreshold *  the max sidelobe level * peak residual</shortdescription>
      <value type="double">3.0</value>
      <description>Sub-parameter for &quot;auto-multithresh&quot;: mask threshold based on sidelobe levels:
                        sidelobethreshold * max_sidelobe_level * peak residual

      </description>
    </param>

    <param subparam="true" name="noisethreshold" type="double">
      <shortdescription>noisethreshold * rms in residual image + location(median) </shortdescription>
      <value type="double">5.0</value>
      <description>Sub-parameter for &quot;auto-multithresh&quot;: mask threshold based on the noise level:
                        noisethreshold * rms + location (=median)

                        The rms is calculated from MAD with rms = 1.4826*MAD.
      </description>
    </param>

    <param type="double" name="lownoisethreshold" subparam="true">
      <shortdescription>lownoisethreshold * rms in residual image + location(median) </shortdescription>
      <value type="double">1.5</value>
      <description>Sub-parameter for &quot;auto-multithresh&quot;: mask threshold to grow previously masked regions via binary dilation:
                        lownoisethreshold * rms in residual image + location (=median)

                        The rms is calculated from MAD with rms = 1.4826*MAD.
      </description>
    </param>
    <param type="double" name="negativethreshold" subparam="true">
      <shortdescription>negativethreshold * rms in residual image + location(median) </shortdescription>
      <value type="double">0.0</value>
      <description>Sub-parameter for &quot;auto-multithresh&quot;: mask threshold for negative features:
                        -1.0* negativethreshold * rms + location(=median)

                        The rms is calculated from MAD with rms = 1.4826*MAD.
      </description>
    </param>
    <param type="double" name="smoothfactor" subparam="true">
      <shortdescription>smoothing factor in a unit of the beam</shortdescription>
      <value type="double">1.0</value>
      <description>Sub-parameter for &quot;auto-multithresh&quot;: smoothing factor in a unit of the beam
      </description>
    </param>
    <param type="double" name="minbeamfrac" subparam="true">
      <shortdescription>minimum beam fraction for pruning</shortdescription>
      <value type="double">0.3</value>
      <description>Sub-parameter for &quot;auto-multithresh&quot;: minimum beam fraction in size to prune masks smaller than mimbeamfrac * beam
                       &lt;=0.0 : No pruning
      </description>
    </param>
    <param type="double" name="cutthreshold" subparam="true">
      <shortdescription>threshold to cut the smoothed mask to create a final mask</shortdescription>
      <value type="double">0.01</value>
      <description>Sub-parameter for &quot;auto-multithresh&quot;: threshold to cut the smoothed mask to create a final mask:
                        cutthreshold * peak of the smoothed mask
      </description>
    </param>
    <param type="int" name="growiterations" subparam="true">
      <shortdescription>number of binary dilation iterations for growing the mask</shortdescription>
      <value type="int">75</value>
      <description>Sub-parameter for &quot;auto-multithresh&quot;: Maximum number of iterations to perform using binary dilation for growing the mask
      </description>
    </param>

    <param type="bool" name="dogrowprune" subparam="true">
      <shortdescription>Do pruning on the grow mask</shortdescription>
      <value type="bool">True</value>
      <description>Experimental sub-parameter for &quot;auto-multithresh&quot;: Do pruning on the grow mask
      </description>
    </param>

    <param type="bool" name="verbose" subparam="true">
      <shortdescription>True: print more automasking information in the logger</shortdescription>
      <value type="bool">False</value>
      <description> If it is set to True, the summary of automasking at the end of each automasking process
                        is printed in the logger.  Following information per channel will be listed in the summary.

                        chan: channel number
                        masking?: F - stop updating automask for the subsequent iteration cycles
                        RMS: robust rms noise
                        peak: peak in residual image
                        thresh_type: type of threshold used (noise or sidelobe)
                        thresh_value: the value of threshold used
                        N_reg: number of the automask regions
                        N_pruned: number of the automask regions removed by pruning
                        N_grow: number of the grow mask regions
                        N_grow_pruned: number of the grow mask regions removed by pruning
                        N_neg_pix: number of pixels for negative mask regions

                        Note that for a large cube, extra logging may slow down the process.
      </description>
    </param>

    <constraints>

      <when param="deconvolver">
        <equals type="string" value="hogbom">
        </equals>
        <equals type="string" value="clark">
        </equals>
        <equals type="string" value="multiscale">
          <default param="scales"><value type="intVec"/></default>
          <default param="smallscalebias"><value>0.0</value></default>
        </equals>
        <equals type="string" value="mtmfs">
          <default param="scales"><value type="intVec"/></default>
          <default param="nterms"><value type="int">2</value></default>
          <default param="smallscalebias"><value>0.0</value></default>
        </equals>
        <equals type="string" value="aasp">
        </equals>
      </when>

      <when param="restoration">
        <equals type="bool" value="True">
          <default param="restoringbeam"><value type="stringVec"/></default>
        </equals>
      </when>

      <when param="niter">
        <notequals type="int" value="0">
          <default param="gain"><value>0.1</value></default>
          <default param="threshold"><value>0.0</value></default>
          <default param="nsigma"><value>0.0</value></default>
         
          <default param="cyclefactor"><value>1.0</value></default>
          <default param="minpsffraction"><value>0.05</value></default>
          <default param="maxpsffraction"><value>0.8</value></default>
          <default param="fastnoise"><value>True</value></default>

        </notequals>

      </when>




      <when param="usemask">
        <equals type="string" value="user">
          <default param="mask"><value>&quot;&quot;</value></default>
          <default param="pbmask"><value>0.0</value></default>
        </equals>
        <equals type="string" value="pb">
          <default param="pbmask"><value type="double">0.2</value></default>
        </equals>
       
       
       
       
       
        <equals type="string" value="auto-multithresh">
          <default param="pbmask"><value>0.2</value></default>
          <default param="sidelobethreshold"><value>3.0</value></default>
         
          <default param="lownoisethreshold"><value>1.5</value></default>
          <default param="negativethreshold"><value>0.0</value></default>
          <default param="smoothfactor"><value>1.0</value></default>
          <default param="minbeamfrac"><value type="double">0.3</value></default>
          <default param="cutthreshold"><value>0.01</value></default>
          <default param="growiterations"><value>75</value></default>
          <default param="dogrowprune"><value type="bool">True</value></default>
         
          <default param="verbose"><value type="bool">False</value></default>
         
        </equals>
       
      </when>



   </constraints>

  </input>

  <returns type="void"/>

  <example>

    Please refer to the CASAdocs pages for the task deconvolve for examples.

  </example>

</task>

</casaxml>
