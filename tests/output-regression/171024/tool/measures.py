##################### generated by xml-casa (v2) from measures.xml ##################
##################### 2840c0752d528fd6314567967456757c ##############################
from __future__ import absolute_import 
from CASAtools.__casac__ import measures as _measures
from CASAtools.typecheck import validator as _pc
from CASAtools.coercetype import coerce as _coerce


class measures:
    ### self
    def __init__(self, *args, **kwargs):
        """Create a measures tool on the specified host (or by default the
        host you are running on).
        """
        self._swigobj = kwargs.get('swig_object',None)
        if self._swigobj is None:
            self._swigobj = _measures()

    def dirshow(self, v):
        """dirshow will convert a direction measure to a string
        """
        schema = {'v': {'type': 'cDict'}}
        doc = {'v': v}
        assert _pc.validate(doc,schema), str(_pc.errors)
        return self._swigobj.dirshow(_pc.document['v'])

    def show(self, v, refcode=True):
        """show will convert a measure to a string.
        
        All measures are catered for (at this moment {em direction, position, epoch,
        radialvelocity, frequency, doppler, baseline, uvw, earthmagnetic} ).
        """
        schema = {'v': {'type': 'cDict'}, 'refcode': {'type': 'cBool'}}
        doc = {'v': v, 'refcode': refcode}
        assert _pc.validate(doc,schema), str(_pc.errors)
        return self._swigobj.show(_pc.document['v'], _pc.document['refcode'])

    def epoch(self, rf='UTC', v0=[ ], off={ }):
        """epoch defines an epoch measure from the CLI. It has to specify a
        reference code, an epoch quantity value (see introduction for the
        action on a scalar quantity with either a vector or scalar value),
        
        and optionally it can specify an offset, which in itself has to be an
        epoch. Allowable reference codes are:
        {em UTC TAI LAST LMST GMST1 GAST UT1 UT2 TDT TCG TDB TCB}.
        Note that additional ones may become available. Check in casa with:
        
        begin{verbatim}
        print "t----t epoch Ex 1 t----"
        print me.listcodes(me.epoch())
        #{'normal': ['LAST', 'LMST', 'GMST1', 'GAST', 'UT1', 'UT2', 'UTC', 'TAI',
        # 'TDT', 'TCG', 'TDB', 'TCB', 'IAT', 'GMST', 'TT', 'ET', 'UT'], 'extra': []}
        #
        end{verbatim}
        
        See quantity for possible time formats.
        """
        schema = {'rf': {'type': 'cStr'}, 'v0': {'type': 'cVariant'}, 'off': {'type': 'cDict'}}
        doc = {'rf': rf, 'v0': v0, 'off': off}
        assert _pc.validate(doc,schema), str(_pc.errors)
        return self._swigobj.epoch(_pc.document['rf'], _pc.document['v0'], _pc.document['off'])

    def direction(self, rf='J2000', v0=[ ], v1=[ ], off={ }):
        """direction defines a direction measure from the CLI. It has to specify a
        reference code, direction quantity values (see introduction for the action on a
        scalar quantity with either a vector or scalar value),
        
        and optionally it can specify an
        offset, which in itself has to be a direction. Allowable reference codes are:
        {em J2000 JMEAN JTRUE APP B1950 BMEAN BTRUE GALACTIC HADEC AZEL
        SUPERGAL ECLIPTIC MECLIPTIC TECLIPTIC MERCURY
        VENUS MARS JUPITER SATURN URANUS NEPTUNE PLUTO MOON SUN COMET}.
        Note that additional ones may become available. Check in casa with:
        
        begin{verbatim}
        print "t----t direction Ex 1 t----"
        print me.listcodes(me.direction())
        #{'normal': ['J2000', 'JMEAN', 'JTRUE', 'APP', 'B1950', 'BMEAN',
        #'BTRUE', 'GALACTIC', 'HADEC', 'AZEL', 'AZELSW', 'AZELNE', 'AZELGEO',
        #'AZELSWGEO', 'AZELNEGEO', 'JNAT', 'ECLIPTIC', 'MECLIPTIC',
        #'TECLIPTIC', 'SUPERGAL', 'ITRF', 'TOPO', 'ICRS'], 'extra': ['MERCURY',
        #'VENUS', 'MARS', 'JUPITER', 'SATURN', 'URANUS', 'NEPTUNE', 'PLUTO',
        #'SUN', 'MOON', 'COMET']}
        end{verbatim}
        
        The direction quantity values should be longitude(angle) and
        latitude(angle) (none needed for planets: the frame epoch defines coordinates).
        See quantity for possible angle formats.
        """
        schema = {'rf': {'type': 'cStr'}, 'v0': {'type': 'cVariant'}, 'v1': {'type': 'cVariant'}, 'off': {'type': 'cDict'}}
        doc = {'rf': rf, 'v0': v0, 'v1': v1, 'off': off}
        assert _pc.validate(doc,schema), str(_pc.errors)
        return self._swigobj.direction(_pc.document['rf'], _pc.document['v0'], _pc.document['v1'], _pc.document['off'])

    def getvalue(self, v):
        """getvalue gets the actual implementation value of the measure.
        """
        schema = {'v': {'type': 'cDict'}}
        doc = {'v': v}
        assert _pc.validate(doc,schema), str(_pc.errors)
        return self._swigobj.getvalue(_pc.document['v'])

    def gettype(self, v):
        """gettype gets the actual type of the measure.
        """
        schema = {'v': {'type': 'cDict'}}
        doc = {'v': v}
        assert _pc.validate(doc,schema), str(_pc.errors)
        return self._swigobj.gettype(_pc.document['v'])

    def getref(self, v):
        """gettype gets the actual reference code of the measure.
        """
        schema = {'v': {'type': 'cDict'}}
        doc = {'v': v}
        assert _pc.validate(doc,schema), str(_pc.errors)
        return self._swigobj.getref(_pc.document['v'])

    def getoffset(self, v):
        """getoff gets the actual offset of the measure (as a measure) or F if no offset
        given.
        """
        schema = {'v': {'type': 'cDict'}}
        doc = {'v': v}
        assert _pc.validate(doc,schema), str(_pc.errors)
        return self._swigobj.getoffset(_pc.document['v'])

    def cometname(self):
        """cometname gets the name of the current comet (if any).
        """
        return self._swigobj.cometname()

    def comettype(self):
        """comettype gets the comet table type (apparent or topocentric)
        """
        return self._swigobj.comettype()

    def cometdist(self):
        """cometdist returns the distance in AU of the current comet in the current frame,
        as a quantity.  It will return -1 AU on failure!
        
        """
        return self._swigobj.cometdist()

    def cometangdiam(self):
        """cometdist returns the angular diameter (as seen from Earth) in AU of the current
        comet in the current frame, as a quantity.  It will return -1 radians on failure!
        
        """
        return self._swigobj.cometangdiam()

    def comettopo(self):
        """comettopo gets the comet table's topographic coordinates used.
        """
        return self._swigobj.comettopo()

    def framecomet(self, v=''):
        """framecomet will put the specified comet table in the frame.
        """
        schema = {'v': {'type': 'cReqPath', 'coerce': _coerce.expand_path}}
        doc = {'v': v}
        assert _pc.validate(doc,schema), str(_pc.errors)
        return self._swigobj.framecomet(_pc.document['v'])

    def position(self, rf='WGS84', v0=[ ], v1=[ ], v2=[ ], off={ }):
        """position defines a position measure from the CLI. It has to specify a
        reference code, position quantity values (see introduction for the action on a
        scalar quantity with either a vector or scalar value),
        
        and optionally it can specify an
        offset, which in itself has to be a position. Allowable reference codes are:
        {em WGS84 ITRF} (World Geodetic System and International Terrestrial
        Reference Frame).
        Note that additional ones may become available. Check in casa with:
        
        begin{verbatim}
        print "t----t position Ex 1 t----"
        print me.listcodes(me.position())
        #{'normal': ['ITRF', 'WGS84'], 'extra': []}
        end{verbatim}
        
        The position quantity values should be either longitude
        (angle), latitude(angle) and height(length); or x,y,z (length).
        See quantity for possible angle formats.
        """
        schema = {'rf': {'type': 'cStr'}, 'v0': {'type': 'cVariant'}, 'v1': {'type': 'cVariant'}, 'v2': {'type': 'cVariant'}, 'off': {'type': 'cDict'}}
        doc = {'rf': rf, 'v0': v0, 'v1': v1, 'v2': v2, 'off': off}
        assert _pc.validate(doc,schema), str(_pc.errors)
        return self._swigobj.position(_pc.document['rf'], _pc.document['v0'], _pc.document['v1'], _pc.document['v2'], _pc.document['off'])

    def observatory(self, name='ALMA'):
        """observatory will give you the position of an observatory as given in the
        system. At the time of writing the following observatories are recognised
        (but check e.g. the position GUI for currently known ones, or the
        me.obslist() tool function):
        {em'ALMA' 'ARECIBO' 'ATCA' 'BIMA' 'CLRO' 'DRAO' 'DWL' 'GB' 'GBT' 'GMRT'
        'IRAM PDB' 'IRAM_PDB' 'JCMT' 'MOPRA' 'MOST' 'NRAO12M' 'NRAO_GBT' 'PKS'
        'SAO SMA' 'SMA' 'VLA' 'VLBA' 'WSRT' 'ATF' 'ATA' 'CARMA' 'ACA' 'OSF'
        'OVRO_MMA' 'EVLA' 'ASKAP' 'APEX' 'SMT' 'NRO' 'ASTE' 'LOFAR' 'MeerKAT'
        'KAT-7' 'EVN' 'LWA1' 'PAPER_SA' 'PAPER_GB' 'e-MERLIN' 'MERLIN2'
        'Effelsberg' 'MWA32T' }.
        """
        schema = {'name': {'type': 'cStr'}}
        doc = {'name': name}
        assert _pc.validate(doc,schema), str(_pc.errors)
        return self._swigobj.observatory(_pc.document['name'])

    def obslist(self):
        """obslist will give you an array of strings of the
        observatories known in the Observatories table.
        """
        return self._swigobj.obslist()

    def linelist(self):
        """linelist will give you a string with a space separated list of spectral lines
        known in the Lines table.
        
        A number of lines are available now, but tables with many lines are
        already online, and will be interfaced once a nomenclature can be defined for
        the tens of thousands of lines.
        """
        return self._swigobj.linelist()

    def spectralline(self, name='HI'):
        """spectralline will give you the frequency of a spectral line. The known list
        can be obtained by me.linelist().
        """
        schema = {'name': {'type': 'cStr'}}
        doc = {'name': name}
        assert _pc.validate(doc,schema), str(_pc.errors)
        return self._swigobj.spectralline(_pc.document['name'])

    def sourcelist(self):
        """sourcelist will give you a string with the space separated list of sources
        known in the Sources table.
        """
        return self._swigobj.sourcelist()

    def source(self, name=[ ]):
        """source will give you the direction of a source. The known list
        can be obtained by me.sourcelist().
        """
        schema = {'name': {'type': 'cVariant'}}
        doc = {'name': name}
        assert _pc.validate(doc,schema), str(_pc.errors)
        return self._swigobj.source(_pc.document['name'])

    def frequency(self, rf='LSRK', v0=[ ], off={ }):
        """frequency defines a frequency measure from the CLI. It has to specify a
        reference code, frequency quantity value (see introduction for the action on a
        scalar quantity with either a vector or scalar value),
        
        and optionally it can specify an
        offset, which in itself has to be a frequency. Allowable reference codes are:
        {em REST LSRK LSRD BARY GEO TOPO GALACTO LGROUP CMB}.
        Note that additional ones may become available. Check in casa with:
        begin{verbatim}
        print "t----t frequency Ex 1 t----"
        print me.listcodes(me.frequency())
        #{'normal': ['REST', 'LSRK', 'LSRD', 'BARY', 'GEO', 'TOPO',
        # 'GALACTO', 'LGROUP', 'CMB'], 'extra': []}
        end{verbatim}
        
        The frequency quantity values should be in one of the recognised units
        (examples all give same frequency):
        begin{itemize}
        item value with time units: a period (0.5s)
        item value as frequency: 2Hz
        item value in angular frequency: 720deg/s
        item value as length: 149896km
        item value as wave number: 4.19169e-8m-1
        item value as energy (h.nu): 8.27134e-9ueV
        item value as momentum: 4.42044e-42kg.m
        end{itemize}
        """
        schema = {'rf': {'type': 'cStr'}, 'v0': {'type': 'cVariant'}, 'off': {'type': 'cDict'}}
        doc = {'rf': rf, 'v0': v0, 'off': off}
        assert _pc.validate(doc,schema), str(_pc.errors)
        return self._swigobj.frequency(_pc.document['rf'], _pc.document['v0'], _pc.document['off'])

    def doppler(self, rf='RADIO', v0=[ ], off={ }):
        """doppler defines a doppler measure from the CLI. It has to specify a
        reference code, doppler quantity value (see introduction for the action on a
        scalar quantity with either a vector or scalar value),
        
        and optionally it can specify an offset,
        which in itself has to be a doppler. Allowable reference codes are:
        {em RADIO Z RATIO BETA GAMMA OPTICAL TRUE RELATIVISTIC}.
        Note that additional ones may become available. Check in casa with:
        
        begin{verbatim}
        print "t----t doppler Ex 1 t----"
        print me.listcodes(me.doppler())
        #{'normal': ['RADIO', 'Z', 'RATIO', 'BETA', 'GAMMA', 'OPTICAL',
        # 'TRUE', 'RELATIVISTIC'], 'extra': []}
        end{verbatim}
        
        The doppler quantity values should be either non-dimensioned to specify a
        ratio of the light velocity, or in velocity.
        """
        schema = {'rf': {'type': 'cStr'}, 'v0': {'type': 'cVariant'}, 'off': {'type': 'cDict'}}
        doc = {'rf': rf, 'v0': v0, 'off': off}
        assert _pc.validate(doc,schema), str(_pc.errors)
        return self._swigobj.doppler(_pc.document['rf'], _pc.document['v0'], _pc.document['off'])

    def radialvelocity(self, rf='LSRK', v0=[ ], off={ }):
        """radialvelocity defines a radialvelocity measure from the CLI. It has to
        specify a reference code, radialvelocity quantity value (see introduction for
        the action on a
        scalar quantity with either a vector or scalar value),
        
        and optionally it
        can specify an offset, which in itself has to be a radialvelocity.
        Allowable reference codes are:
        {em LSRK LSRD BARY GEO TOPO GALACTO LGROUP CMB}.
        Note that additional ones may become available. Check in casa with:
        
        begin{verbatim}
        print "t----t radialvelocity Ex 1 t----"
        print me.listcodes(me.radialvelocity())
        #  Out[17]:
        #{'extra': [],
        # 'normal': ['LSRK', 'LSRD', 'BARY', 'GEO', 'TOPO', 'GALACTO',
        # 'LGROUP', 'CMB']}
        end{verbatim}
        The radialvelocity quantity values should be given as velocity.
        """
        schema = {'rf': {'type': 'cStr'}, 'v0': {'type': 'cVariant'}, 'off': {'type': 'cDict'}}
        doc = {'rf': rf, 'v0': v0, 'off': off}
        assert _pc.validate(doc,schema), str(_pc.errors)
        return self._swigobj.radialvelocity(_pc.document['rf'], _pc.document['v0'], _pc.document['off'])

    def shift(self, v={ }, offset=[ ], pa=[ ]):
        """This method calculates the direction measure located at the specified offset angular amount along the specified
        position angle from the specified direction measure.
        
        """
        schema = {'v': {'type': 'cDict'}, 'offset': {'type': 'cVariant'}, 'pa': {'type': 'cVariant'}}
        doc = {'v': v, 'offset': offset, 'pa': pa}
        assert _pc.validate(doc,schema), str(_pc.errors)
        return self._swigobj.shift(_pc.document['v'], _pc.document['offset'], _pc.document['pa'])

    def uvw(self, rf='ITRF', v0=[ ], v1=[ ], v2=[ ], off={ }):
        """uvw defines a uvw measure from the CLI. It has to specify a
        reference code, uvw quantity values (see introduction for the action on a
        scalar quantity with either a vector or scalar value),  and optionally it can specify an
        offset, which in itself has to be a uvw. Allowable reference codes are
        ITRF and the direction ones.
        Note that additional ones may become available. Check in casa with:
        begin{verbatim}
        print "t----t uvw Ex 1 t----"
        print me.listcodes(me.uvw())
        #{'normal': ['J2000', 'JMEAN', 'JTRUE', 'APP', 'B1950', 'BMEAN',
        # 'BTRUE', 'GALACTIC', 'HADEC', 'AZEL', 'AZELSW', 'AZELNE',
        # 'AZELGEO', 'AZELSWGEO', 'AZELNEGEO', 'JNAT', 'ECLIPTIC',
        # 'MECLIPTIC', 'TECLIPTIC', 'SUPERGAL', 'ITRF', 'TOPO',
        # 'ICRS'], 'extra': []}
        end{verbatim}
        
        The uvw quantity values should be either longitude
        (angle), latitude(angle) and height(length); or x,y,z (length).
        See quantity for possible angle formats.
        """
        schema = {'rf': {'type': 'cStr'}, 'v0': {'type': 'cVariant'}, 'v1': {'type': 'cVariant'}, 'v2': {'type': 'cVariant'}, 'off': {'type': 'cDict'}}
        doc = {'rf': rf, 'v0': v0, 'v1': v1, 'v2': v2, 'off': off}
        assert _pc.validate(doc,schema), str(_pc.errors)
        return self._swigobj.uvw(_pc.document['rf'], _pc.document['v0'], _pc.document['v1'], _pc.document['v2'], _pc.document['off'])

    def touvw(self, v={ }, dot={ }, xyz={ }):
        """touvw calculates a uvw measure from a baseline.   Note that the
        baseline does not have to be a proper {em baseline}, but can be a
        series of positions (to call positions baselines see
        asbaseline ) for speed reasons:
        operations are linear and can be done on positions, which are
        converted to baseline values at the end (with
        expand ).
        
        Whatever the reference code of the baseline, the returned {em uvw} will be
        given in J2000. If the {em dot} argument is given, that variable
        will be filled with a quantity array consisting of the time
        derivative of the uvw (note that only the sidereal rate is taken
        into account; not precession, earth tides and similar variations,
        which are much smaller). If the {em xyz} variable is given, it will
        be filled with the quantity values of the uvw measure.
        
        The values of the input baselines can be given as a quantity
        vector per x, y or z value.
        
        uvw coordinates are calculated for a certain direction in the sky;
        hence the frame has to contain the direction for the calculation to
        work. Since the baseline and the sky rotate with respect of each
        other, the time should be specified as well.
        """
        schema = {'v': {'type': 'cDict'}, 'dot': {'type': 'cDict'}, 'xyz': {'type': 'cDict'}}
        doc = {'v': v, 'dot': dot, 'xyz': xyz}
        assert _pc.validate(doc,schema), str(_pc.errors)
        return self._swigobj.touvw(_pc.document['v'], _pc.document['dot'], _pc.document['xyz'])

    def expand(self, v={ }, xyz={ }):
        """expand calculates the differences between a series of given measure
        values: it calculates baseline values from position values. The
        returned value is a measure, but the value of the optional output
        variable {em xyz} will be set to an array of values.
        """
        schema = {'v': {'type': 'cDict'}, 'xyz': {'type': 'cDict'}}
        doc = {'v': v, 'xyz': xyz}
        assert _pc.validate(doc,schema), str(_pc.errors)
        return self._swigobj.expand(_pc.document['v'], _pc.document['xyz'])

    def earthmagnetic(self, rf='IGRF', v0=[ ], v1=[ ], v2=[ ], off={ }):
        """earthmagnetic defines an earthmagnetic measure from the CLI. It needs
        a reference code, earthmagnetic quantity values
        (see introduction for the action on a
        scalar quantity with either a vector or scalar value)  if the reference code is not
        for a model, and optionally it
        can specify an offset, which in itself has to be a earthmagnetic. In general
        you specify a model (IGRF is the default and the only one known) and convert
        it to an explicit field.  (See
        
        http://fdd.gsfc.nasa.gov/IGRF.html
        
        for information on the International Geomagnetic Reference Field). The
        earthmagnetic quantity values should be either longitude (angle),
        latitude(angle) and length(field strength); or x,y,z (field).
        See quantity for possible angle formats.
        """
        schema = {'rf': {'type': 'cStr'}, 'v0': {'type': 'cVariant'}, 'v1': {'type': 'cVariant'}, 'v2': {'type': 'cVariant'}, 'off': {'type': 'cDict'}}
        doc = {'rf': rf, 'v0': v0, 'v1': v1, 'v2': v2, 'off': off}
        assert _pc.validate(doc,schema), str(_pc.errors)
        return self._swigobj.earthmagnetic(_pc.document['rf'], _pc.document['v0'], _pc.document['v1'], _pc.document['v2'], _pc.document['off'])

    def baseline(self, rf='ITRF', v0=[ ], v1=[ ], v2=[ ], off={ }):
        """baseline defines a baseline measure from the CLI. It has to specify a
        reference code, baseline quantity values (see introduction for the action on a
        scalar quantity with either a vector or scalar value, and when a vector of
        quantities is given), and optionally it can specify an
        offset, which in itself has to be a baseline. Allowable reference codes are
        ITRF and the direction ones.
        Note that additional ones may become available. Check in casa with:
        
        begin{verbatim}
        print "t----t baseline Ex 1 t----"
        print me.listcodes(me.baseline())
        #{'normal': ['J2000', 'JMEAN', 'JTRUE', 'APP', 'B1950', 'BMEAN', 'BTRUE',
        # 'GALACTIC', 'HADEC', 'AZEL', 'AZELSW', 'AZELNE', 'AZELGEO', 'AZELSWGEO',
        # 'AZELNEGEO', 'JNAT', 'ECLIPTIC', 'MECLIPTIC', 'TECLIPTIC', 'SUPERGAL',
        # 'ITRF', 'TOPO', 'ICRS'], 'extra': []}
        end{verbatim}
        
        The baseline quantity values should be either longitude
        (angle), latitude(angle) and height(length); or x,y,z (length).
        See quantity for possible angle formats.
        """
        schema = {'rf': {'type': 'cStr'}, 'v0': {'type': 'cVariant'}, 'v1': {'type': 'cVariant'}, 'v2': {'type': 'cVariant'}, 'off': {'type': 'cDict'}}
        doc = {'rf': rf, 'v0': v0, 'v1': v1, 'v2': v2, 'off': off}
        assert _pc.validate(doc,schema), str(_pc.errors)
        return self._swigobj.baseline(_pc.document['rf'], _pc.document['v0'], _pc.document['v1'], _pc.document['v2'], _pc.document['off'])

    def asbaseline(self, pos):
        """asbaseline converts a position measure into a baseline measure. No
        actual baseline is calculated, since operations can be done on
        positions, with subtractions to obtain baselines at a later stage.
        """
        schema = {'pos': {'type': 'cDict'}}
        doc = {'pos': pos}
        assert _pc.validate(doc,schema), str(_pc.errors)
        return self._swigobj.asbaseline(_pc.document['pos'])

    def listcodes(self, ms):
        """listcodes will produce the known reference codes for a specified measure
        type. It will return a record with two entries. The first is a string vector
        of all normal codes; the second a string vector (maybe empty) with all extra
        codes (like planets).
        NOTE: Synonyms and different code groups may be present in the code name lists.
        The indices in these lists therefore do not necessarily correspond to
        the internal CASA enumeration indices.
        """
        schema = {'ms': {'type': 'cDict'}}
        doc = {'ms': ms}
        assert _pc.validate(doc,schema), str(_pc.errors)
        return self._swigobj.listcodes(_pc.document['ms'])

    def measure(self, v, rf, off={ }):
        """measure converts measures (epoch, direction etc.) from one reference to
        another. It will, for instance, convert a direction from J2000 to AZEL
        representation. 
        Its arguments are a measure, an output reference code (see the individual
        measures for the allowable codes (direction,
        position,
        epoch,
        frequency,
        doppler,
        radialvelocity,
        baseline,
        uvw,
        earthmagnetic)), and an optional offset of
        the same type as the main measure. The offset will be subtracted from the
        result before it is returned.
        In some cases (see the individual measures for when), more information than
        just a reference code is necessary. E.g. the above example of a conversion to
        AZEL, needs to know for when, and where on Earth we want it. This information
        is stored in a reference frame. Measures are set in the reference frame with
        the doframe function. The frame is tool
        wide.
        
        {bf IMPORTANT NOTE:}
        To get an accurate conversion of solar system objects direction to a celestial frame, one should convert to AZEL or HADEC before to get parallax accounted for. Thus if you want to get the moon's position in J2000..one would do it in 2 stages
        i.e (after setting the appropriate frames) 
        
        moonazel=me.measure(me.direction('moon'), 'AZELGEO')
        moonJ2000=me.measure(moonazel, 'J2000')
        """
        schema = {'v': {'type': 'cDict'}, 'rf': {'type': 'cStr'}, 'off': {'type': 'cDict'}}
        doc = {'v': v, 'rf': rf, 'off': off}
        assert _pc.validate(doc,schema), str(_pc.errors)
        return self._swigobj.measure(_pc.document['v'], _pc.document['rf'], _pc.document['off'])

    def doframe(self, v):
        """doframe will set the measure specified as part of a frame.
        
        If conversion from one type to another is necessary,  with the
        measure function,
        the following frames
        should be set if one of the reference types involved in the conversion is as
        in the following lists.
        {em Epoch}
        
        UTC
        TAI
        LASTposition
        LMST position
        GMST1
        GAST
        UT1
        UT2
        TDT
        TCG
        TDB
        TCD
        
        {em Direction}
        
        J2000
        JMEANepoch
        JTRUE epoch
        APP epoch
        B1950
        BMEAN epoch
        BTRUE epoch
        GALACTIC
        HADEC epochposition
        AZELepoch position
        SUPERGALACTIC
        ECLIPTIC
        MECLIPTIC      epoch
        TECLIPTICepoch
        PLANETepoch   [position]
        
        {em Position}
        
        WGS84
        ITRF
        
        {em Radial Velocity}
        
        LSRK direction
        LSRD direction
        BARY direction
        GEO directionepoch
        TOPO directionepochposition
        GALACTOdirection
        
        {em Doppler}
        
        RADIO
        OPTICAL
        Z
        RATIO
        RELATIVISTIC
        BETA
        GAMMA
        
        {em Frequency}
        
        REST directionradialvelocity
        LSRK direction
        LSRD direction
        BARY direction
        GEO directionepoch
        TOPO directionepochposition
        GALACTO
        """
        schema = {'v': {'type': 'cDict'}}
        doc = {'v': v}
        assert _pc.validate(doc,schema), str(_pc.errors)
        return self._swigobj.doframe(_pc.document['v'])

    def framenow(self):
        """framenow will fill the active frame time with the current date and time.
        The different frame values necessary are described in the
        doframe function
        """
        return self._swigobj.framenow()

    def showframe(self):
        """showframe will display the currently active reference frame values  on the
        terminal.  The
        different frame values necessary are described in the
        doframe function.
        The frame is
        displayed on the terminal using the formatting as done for the
        show function.
        """
        return self._swigobj.showframe()

    def toradialvelocity(self, rf, v0):
        """toradialvelocity will convert a Doppler type value (e.g. in radio mode) to a
        real radialvelocity. The type of velocity (e.g. LSRK) should be specified
        """
        schema = {'rf': {'type': 'cStr'}, 'v0': {'type': 'cDict'}}
        doc = {'rf': rf, 'v0': v0}
        assert _pc.validate(doc,schema), str(_pc.errors)
        return self._swigobj.toradialvelocity(_pc.document['rf'], _pc.document['v0'])

    def tofrequency(self, rf, v0, rfq):
        """tofrequency will convert a Doppler type value (e.g. in radio mode) to a
        frequency. The type of frequency (e.g. LSRK) and a rest frequency (either as a
        frequency quantity (e.g. qa.constants('HI')) or a frequency measure (e.g.
        me.frequency('rest','5100MHz')) should be specified
        """
        schema = {'rf': {'type': 'cStr'}, 'v0': {'type': 'cDict'}, 'rfq': {'type': 'cDict'}}
        doc = {'rf': rf, 'v0': v0, 'rfq': rfq}
        assert _pc.validate(doc,schema), str(_pc.errors)
        return self._swigobj.tofrequency(_pc.document['rf'], _pc.document['v0'], _pc.document['rfq'])

    def todoppler(self, rf, v0, rfq=[ ]):
        """todoppler will convert a radialvelocity measure or a frequency measure to a
        doppler measure. In the case of a frequency, a rest frequency has to be
        specified. The type of doppler wanted (e.g. RADIO) has to be specified.
        """
        schema = {'rf': {'type': 'cStr'}, 'v0': {'type': 'cDict'}, 'rfq': {'type': 'cVariant'}}
        doc = {'rf': rf, 'v0': v0, 'rfq': rfq}
        assert _pc.validate(doc,schema), str(_pc.errors)
        return self._swigobj.todoppler(_pc.document['rf'], _pc.document['v0'], _pc.document['rfq'])

    def torestfrequency(self, v0, d0):
        """torestfrequency will convert a frequency measure and a doppler measure
        (e.g. obtained from another spectral line with a known rest frequency) to a
        rest frequency.
        """
        schema = {'v0': {'type': 'cDict'}, 'd0': {'type': 'cDict'}}
        doc = {'v0': v0, 'd0': d0}
        assert _pc.validate(doc,schema), str(_pc.errors)
        return self._swigobj.torestfrequency(_pc.document['v0'], _pc.document['d0'])

    def rise(self, crd=[ ], ev=[ ]):
        """rise will give the rise/set hour-angles of a source. It needs the position
        in the frame, and a time. If the latter is not set, the current time will be
        used.
        """
        schema = {'crd': {'type': 'cVariant'}, 'ev': {'type': 'cVariant'}}
        doc = {'crd': crd, 'ev': ev}
        assert _pc.validate(doc,schema), str(_pc.errors)
        return self._swigobj.rise(_pc.document['crd'], _pc.document['ev'])

    def riseset(self, crd=[ ], ev=[ ]):
        """rise will give the rise/set times of a source. It needs the position
        in the frame, and a time. If the latter is not set, the current time will be
        used. The returned value is a record with a 'solved' field, which is F if the
        source is always below or above the horizon. In that case the rise and set
        fields will all have a string value. The record also returns a rise and set
        record, with 'last' and 'utc' fields showing the rise and set times as epochs.
        """
        schema = {'crd': {'type': 'cVariant'}, 'ev': {'type': 'cVariant'}}
        doc = {'crd': crd, 'ev': ev}
        assert _pc.validate(doc,schema), str(_pc.errors)
        return self._swigobj.riseset(_pc.document['crd'], _pc.document['ev'])

    def posangle(self, m1, m2):
        """posangle will give the position angle from a direction to another. I.e. the
        angle in a direction between the direction to the North pole and the other
        direction.
        The posiation angle is calculated in the frame of the first argument. m2 is thus converted to the frame of m1 before calculating the position angle.
        """
        schema = {'m1': {'type': 'cDict'}, 'm2': {'type': 'cDict'}}
        doc = {'m1': m1, 'm2': m2}
        assert _pc.validate(doc,schema), str(_pc.errors)
        return self._swigobj.posangle(_pc.document['m1'], _pc.document['m2'])

    def separation(self, m1, m2):
        """separation will give the separation of a direction from another as an angle.
        """
        schema = {'m1': {'type': 'cDict'}, 'm2': {'type': 'cDict'}}
        doc = {'m1': m1, 'm2': m2}
        assert _pc.validate(doc,schema), str(_pc.errors)
        return self._swigobj.separation(_pc.document['m1'], _pc.document['m2'])

    def addxvalue(self, a):
        """addxvalue will give some additional information about some measures as a vector
        of quantities. It is used internally to get the rectangular coordinates of
        measures that are normally given in angles. The casual user will probably in
        general not interested in this function.
        """
        schema = {'a': {'type': 'cDict'}}
        doc = {'a': a}
        assert _pc.validate(doc,schema), str(_pc.errors)
        return self._swigobj.addxvalue(_pc.document['a'])

    def type(self):
        """type will return the tool name.
        """
        return self._swigobj.type()

    def done(self):
        """In general you will not want to call this method.  It removes and then
        recreates the default measures tool.
        """
        return self._swigobj.done()

    def ismeasure(self, v):
        """Checks if the operand is a correct measure
        """
        schema = {'v': {'type': 'cDict'}}
        doc = {'v': v}
        assert _pc.validate(doc,schema), str(_pc.errors)
        return self._swigobj.ismeasure(_pc.document['v'])

